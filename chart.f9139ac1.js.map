{"version":3,"sources":["aktiengraphen/chart.js"],"names":["global","factory","exports","module","define","amd","globalThis","self","Chart","requestAnimFrame","window","callback","requestAnimationFrame","throttled","fn","thisArg","updateFn","updateArgs","args","Array","prototype","slice","call","ticking","rest","apply","debounce","delay","timeout","clearTimeout","setTimeout","_toLeftRightCenter","align","_alignStartEnd","start","end","_textX","left","right","animator","_request","_charts","Map","_running","_lastDate","undefined","chart","anims","date","type","callbacks","listeners","numSteps","duration","forEach","currentStep","Math","min","me","_update","_refresh","Date","now","remaining","running","items","length","i","item","draw","_active","_total","tick","pop","_notify","charts","get","complete","progress","set","event","cb","_getAnims","push","reduce","acc","cur","max","_duration","cancel","delete","map","A","B","C","D","E","F","a","b","c","d","e","f","hex","h1","h2","eq","hexString","v","isShort","r","g","round","lim","l","h","p2b","n2b","b2n","n2p","RGB_RE","HUE_RE","hsl2rgbn","s","n","k","hsv2rgbn","hwb2rgbn","w","rgb","rgb2hsl","range","calln","isArray","hsl2rgb","hue","hueParse","str","m","exec","p1","p2","hwb2rgb","hsv2rgb","map$1","names$1","x","Z","Y","X","W","V","U","T","S","R","Q","P","O","N","M","L","K","G","H","I","J","names","OiceXe","antiquewEte","aqua","aquamarRe","azuY","beige","bisque","black","blanKedOmond","Xe","XeviTet","bPwn","burlywood","caMtXe","KartYuse","KocTate","cSO","cSnflowerXe","cSnsilk","crimson","cyan","xXe","xcyan","xgTMnPd","xWay","xgYF","xgYy","xkhaki","xmagFta","xTivegYF","xSange","xScEd","xYd","xsOmon","xsHgYF","xUXe","xUWay","xUgYy","xQe","xviTet","dAppRk","dApskyXe","dimWay","dimgYy","dodgerXe","fiYbrick","flSOwEte","foYstWAn","fuKsia","gaRsbSo","ghostwEte","gTd","gTMnPd","Way","gYF","gYFLw","gYy","honeyMw","hotpRk","RdianYd","Rdigo","ivSy","khaki","lavFMr","lavFMrXsh","lawngYF","NmoncEffon","ZXe","ZcSO","Zcyan","ZgTMnPdLw","ZWay","ZgYF","ZgYy","ZpRk","ZsOmon","ZsHgYF","ZskyXe","ZUWay","ZUgYy","ZstAlXe","ZLw","lime","limegYF","lRF","magFta","maPon","VaquamarRe","VXe","VScEd","VpurpN","VsHgYF","VUXe","VsprRggYF","VQe","VviTetYd","midnightXe","mRtcYam","mistyPse","moccasR","navajowEte","navy","Tdlace","Tive","TivedBb","Sange","SangeYd","ScEd","pOegTMnPd","pOegYF","pOeQe","pOeviTetYd","papayawEp","pHKpuff","peru","pRk","plum","powMrXe","purpN","YbeccapurpN","Yd","Psybrown","PyOXe","saddNbPwn","sOmon","sandybPwn","sHgYF","sHshell","siFna","silver","skyXe","UXe","UWay","UgYy","snow","sprRggYF","stAlXe","tan","teO","tEstN","tomato","Qe","viTet","JHt","wEte","wEtesmoke","Lw","LwgYF","nameParse","unpack","unpacked","j","ok","nk","keys","Object","tkeys","replace","parseInt","transparent","toLowerCase","modHSL","ratio","tmp","clone$1","proto","assign","fromObject","input","functionParse","charAt","rgbParse","Color","ret","len","_rgb","_valid","obj","rgbString","hslString","color","weight","c1","w2","c2","p","w1","val","deg","rotate","index_esm","isPatternOrGradient","value","CanvasGradient","CanvasPattern","getHoverColor","saturate","darken","noop","uid","id","isNullOrUndef","toString","substr","isObject","isNumberFinite","Number","isFinite","finiteOrDefault","defaultValue","valueOrDefault","toPercentage","dimension","endsWith","parseFloat","toDimension","each","loopable","reverse","_elementsEqual","a0","a1","ilen","v0","v1","datasetIndex","index","clone","source","target","create","klen","isValidKey","key","indexOf","_merger","options","tval","sval","merge","sources","merger","mergeIf","_mergerIf","hasOwnProperty","emptyString","dot","indexOfDotOrLength","idx","resolveObjectKey","pos","_capitalize","toUpperCase","defined","isFunction","overrides","descriptors","getScope$1","node","split","root","scope","values","Defaults","defaults","_descriptors","animation","backgroundColor","borderColor","datasets","devicePixelRatio","context","platform","getDevicePixelRatio","elements","events","font","family","size","style","lineHeight","hover","hoverBackgroundColor","ctx","hoverBorderColor","hoverColor","indexAxis","interaction","mode","intersect","maintainAspectRatio","onHover","onClick","parsing","plugins","responsive","scale","scales","showLine","describe","name","targetScope","targetName","scopeObject","targetScopeObject","privateName","defineProperties","writable","enumerable","local","_scriptable","startsWith","_indexable","_fallback","PI","TAU","PITAU","INFINITY","POSITIVE_INFINITY","RAD_PER_DEG","HALF_PI","QUARTER_PI","TWO_THIRDS_PI","log10","sign","niceNum","niceRange","pow","floor","fraction","niceFraction","_factorize","result","sqrt","sort","isNumber","isNaN","almostEquals","y","epsilon","abs","almostWhole","rounded","_setMinAndMaxByKey","array","property","toRadians","degrees","toDegrees","radians","_decimalPlaces","getAngleFromPoint","centrePoint","anglePoint","distanceFromXCenter","distanceFromYCenter","radialDistanceFromCenter","angle","atan2","distance","distanceBetweenPoints","pt1","pt2","_angleDiff","_normalizeAngle","_angleBetween","angleToStart","angleToEnd","startToAngle","endToAngle","_limitValue","_int16Range","toFontString","_measureText","data","gc","longest","string","textWidth","measureText","width","_longestText","arrayOfThings","cache","garbageCollect","save","jlen","thing","nestedThing","restore","gcLen","splice","_alignPixel","pixel","currentDevicePixelRatio","halfWidth","clearCanvas","canvas","getContext","resetTransform","clearRect","height","drawPoint","xOffset","yOffset","cornerRadius","pointStyle","rotation","radius","rad","translate","drawImage","beginPath","arc","closePath","moveTo","sin","cos","lineTo","SQRT1_2","rect","fill","borderWidth","stroke","_isPointInArea","point","area","margin","top","bottom","clipArea","clip","unclipArea","_steppedLineTo","previous","flip","midpoint","_bezierCurveTo","bezierCurveTo","cp1x","cp2x","cp1y","cp2y","renderText","text","opts","line","lines","strokeWidth","strokeColor","translation","fillStyle","textAlign","textBaseline","strokeStyle","lineWidth","strokeText","maxWidth","fillText","strikethrough","underline","metrics","actualBoundingBoxLeft","actualBoundingBoxRight","actualBoundingBoxAscent","actualBoundingBoxDescent","yDecoration","decorationWidth","_lookup","table","cmp","hi","mid","lo","_lookupByKey","_rlookupByKey","_filterBetween","arrayEvents","listenArrayEvents","listener","_chartjs","defineProperty","configurable","method","base","res","object","unlistenArrayEvents","stub","_arrayUnique","Set","add","_getParentNode","domNode","parent","parentNode","host","parseMaxStyle","styleValue","parentProperty","valueInPixels","getComputedStyle","element","getStyle","el","getPropertyValue","positions","getPositionedStyle","styles","suffix","useOffsetPos","shadowRoot","getRelativePosition$1","evt","borderBox","boxSizing","paddings","borders","getCanvasPosition","native","touches","offsetX","offsetY","box","getBoundingClientRect","clientX","clientY","round1","getMaximumSize","bbWidth","bbHeight","aspectRatio","margins","maxHeight","containerSize","getContainerSize","container","containerStyle","containerBorder","containerPadding","clientWidth","clientHeight","retinaScale","forceRatio","forceStyle","pixelRatio","setTransform","supportsEventListenerOptions","passiveSupported","passive","addEventListener","removeEventListener","readUsedSize","matches","match","getRelativePosition","binarySearch","metaset","axis","controller","_sorted","iScale","_cachedMeta","lookupMethod","_reversePixels","_sharedOptions","getRange","optimizedEvaluateItems","position","handler","metasets","getSortedVisibleDatasetMetas","skip","getIntersectItems","useFinalPosition","chartArea","_minPadding","inRange","getNearestItems","distanceMetric","getDistanceMetricForAxis","useX","useY","deltaX","deltaY","minDistance","center","getCenterPoint","getAxisItems","rangeMethod","intersectsItem","evaluateAllVisibleItems","Interaction","modes","meta","dataset","getDatasetMeta","nearest","LINE_HEIGHT","RegExp","toLineHeight","numberOrZero$1","readValueToProps","props","objProps","read","prop","toTRBL","toTRBLCorners","toPadding","toFont","fallback","resolve","inputs","info","cacheable","_addGrace","minmax","grace","STATIC_POSITIONS","filterByPosition","filter","filterDynamicPositionByAxis","sortByWeight","getCombinedMax","maxPadding","updateMaxPadding","boxPadding","updateDims","params","layout","same","other","horizontal","getPadding","newWidth","outerWidth","newHeight","outerHeight","widthChanged","heightChanged","getMargins","marginForPositions","fitBoxes","boxes","refitBoxes","refit","changed","update","fullSize","placeBoxes","userPadding","padding","layouts","addBox","_layers","z","removeBox","layoutItem","configure","minPadding","availableWidth","availableHeight","buildLayoutBoxes","layoutBoxes","wrapBoxes","isHorizontal","wrap","centerHorizontal","centerVertical","leftAndTop","concat","rightAndBottom","vertical","verticalBoxes","horizontalBoxes","beforeLayout","visibleVerticalBoxCount","total","display","freeze","vBoxMaxWidth","hBoxMaxHeight","setLayoutDims","handleMaxPadding","updatePos","change","BasePlatform","BasicPlatform","EXPANDO_KEY","EVENT_TYPES","touchstart","touchmove","touchend","pointerenter","pointerdown","pointermove","pointerup","pointerleave","pointerout","isNullOrEmpty","eventListenerOptions","removeListener","createAttachObserver","observer","MutationObserver","entries","entry","addedNodes","added","observe","document","childList","subtree","createDetachObserver","removedNodes","drpListeningCharts","oldDevicePixelRatio","onWindowResize","dpr","resize","createResizeObserver","ResizeObserver","contentRect","listenDevicePixelRatioChanges","releaseObserver","disconnect","unlistenDevicePixelRatioChanges","createProxyAndListen","proxy","fromNativeEvent","addListener","DomPlatform","initCanvas","renderHeight","getAttribute","renderWidth","initial","displayWidth","displayHeight","removeAttribute","setAttribute","proxies","$proxies","attach","detach","platforms","__proto__","atEdge","t","elasticIn","elasticOut","effects","linear","easeInQuad","easeOutQuad","easeInOutQuad","easeInCubic","easeOutCubic","easeInOutCubic","easeInQuart","easeOutQuart","easeInOutQuart","easeInQuint","easeOutQuint","easeInOutQuint","easeInSine","easeOutSine","easeInOutSine","easeInExpo","easeOutExpo","easeInOutExpo","easeInCirc","easeOutCirc","easeInOutCirc","easeInElastic","easeOutElastic","easeInOutElastic","easeInBack","easeOutBack","easeInOutBack","easeInBounce","easeOutBounce","easeInOutBounce","interpolators","boolean","from","to","factor","c0","valid","mix","number","Animation","cfg","currentValue","_fn","_easing","easing","_start","_loop","loop","_target","_prop","_from","_to","_promises","elapsed","remain","promises","Promise","rej","resolved","animationOptions","colors","properties","numbers","active","show","animations","visible","hide","Animations","config","_chart","_properties","animatedProps","getOwnPropertyNames","option","has","newOptions","resolveTargetOptions","$shared","$animations","_createAnimations","awaitAll","anim","wait","all","then","_animateOptions","scaleClip","allowedOverflow","getSortedDatasetIndices","filterVisible","_getSortedDatasetMetas","applyStack","stack","dsIndex","otherValue","singleMode","isStacked","stacked","getOrCreateStack","stacks","stackKey","indexValue","subStack","updateStacks","parsed","_stacks","vScale","iAxis","vAxis","getStackKey","indexScale","valueScale","getFirstScaleId","shift","clearStacks","_parsed","isDirectUpdateMode","cloneIfNotShared","cached","shared","DatasetController","_ctx","_cachedDataOpts","getMeta","_type","_parsing","_data","_objectData","_drawStart","_drawCount","enableOptionSharing","$context","initialize","linkScales","_stacked","addElements","getDataset","chooseId","xid","xAxisID","yid","yAxisID","rid","rAxisID","iid","iAxisID","vid","vAxisID","xScale","getScaleForId","yScale","rScale","scaleID","convertObjectDataToArray","adata","isExtensible","_dataCheck","datasetElementType","resetNewElements","stackChanged","_resyncElements","scopeKeys","datasetScopeKeys","scopes","getOptionScopes","createResolver","count","sorted","prev","parseArrayData","parseObjectData","parsePrimitiveData","labels","getLabels","singleScale","parse","xAxisKey","yAxisKey","parsedValue","NaN","canStack","otherScale","_getOtherScale","NEGATIVE_INFINITY","getUserBounds","minDefined","maxDefined","otherMin","otherMax","_skip","updateRangeFromParsed","getParsed","label","getLabelForValue","_clip","defaultClip","getMaxOverflow","resolveDatasetElementOptions","resolveDataElementOptions","createDataContext","dataIndex","raw","createDatasetContext","_resolveElementOptions","dataElementType","elementType","cacheKey","sharing","datasetElementScopeKeys","prefixes","resolveNamedOptions","transition","datasetAnimationScopeKeys","_cacheable","sharedOptions","_animationsDisabled","_resolveAnimations","getSharedOptions","_setStyle","numMeta","numData","_insertElements","_removeElements","move","arr","updateElements","removed","arguments","Element","getProps","final","defaultRoutes","intlCache","formatNumber","num","locale","getNumberFormat","JSON","stringify","formatter","Intl","NumberFormat","format","formatters","numeric","tickValue","ticks","notation","delta","maxTick","calculateDelta","logDelta","numDecimal","minimumFractionDigits","maximumFractionDigits","logarithmic","Ticks","autoSkip","tickOpts","ticksLimit","maxTicksLimit","determineMaxTicks","offset","tickLength","_tickSize","maxScale","_length","maxChart","_maxLength","majorIndices","major","enabled","getMajorIndices","numMajorIndices","first","last","newTicks","skipMajors","spacing","next","ceil","calculateSpacing","evenMajorSpacing","getEvenSpacing","diff","factors","avgMajorSpacing","majorStart","majorEnd","beginAtZero","bounds","grid","drawBorder","drawOnChartArea","drawTicks","tickWidth","tickColor","borderDash","borderDashOffset","title","minRotation","maxRotation","mirror","textStrokeWidth","textStrokeColor","autoSkipPadding","labelOffset","minor","crossAlign","route","reverseAlign","offsetFromEdge","edge","sample","numItems","increment","getPixelForGridLine","offsetGridLines","validIndex","_startPixel","_endPixel","lineValue","getPixelForTick","getTickMarkLength","getTitleHeight","titleAlign","Scale","_margins","paddingTop","paddingBottom","paddingLeft","paddingRight","labelRotation","_gridLineItems","_labelItems","_labelSizes","_longestTextCache","_userMax","_userMin","_suggestedMax","_suggestedMin","_ticksLength","_borderValue","_cache","_dataLimitsCached","suggestedMin","suggestedMax","metas","getMatchingVisibleMetas","getMinMax","xLabels","yLabels","beforeUpdate","sampleSize","beforeSetDimensions","setDimensions","afterSetDimensions","beforeDataLimits","determineDataLimits","afterDataLimits","beforeBuildTicks","buildTicks","afterBuildTicks","samplingEnabled","_convertTicksToLabels","beforeCalculateLabelRotation","calculateLabelRotation","afterCalculateLabelRotation","beforeFit","fit","afterFit","afterUpdate","startPixel","endPixel","reversePixels","_alignToPixels","alignToPixels","notifyPlugins","_callHooks","beforeTickToLabelConversion","afterTickToLabelConversion","maxLabelDiagonal","numTicks","_isVisible","labelSizes","_getLabelSizes","maxLabelWidth","widest","maxLabelHeight","highest","asin","minSize","titleOpts","gridOpts","titleHeight","tickPadding","angleRadians","labelHeight","labelWidth","_calculatePadding","_handleMargins","isRotated","labelsBelowTicks","offsetLeft","offsetRight","generateTickLabels","_computeLabelSizes","tickFont","fontString","nestedLabel","caches","widths","heights","widestLabelSize","highestLabelSize","_resolveTickFontOptions","valueAt","getPixelForValue","decimal","getBaseValue","createTickContext","optionTicks","rot","borderValue","alignedLineValue","tx1","ty1","tx2","ty2","x1","y1","x2","y2","ticksLength","tl","borderOpts","setContext","axisWidth","axisHalfWidth","alignBorderValue","positionAxisID","optsAtIndex","lineColor","tickBorderDash","tickBorderDashOffset","lineCount","textOffset","tickAndPadding","_getXAxisLabelAlignment","_getYAxisLabelAlignment","halfCount","fillRect","findIndex","_computeGridLineItems","drawLine","setLineDash","lineDashOffset","edgeOpts","lastLineWidth","_computeLabelArea","_computeLabelItems","titleArgs","titleX","titleY","drawBackground","drawGrid","drawTitle","drawLabels","tz","gz","axisID","_createResolver","rootScopes","_resolve","Symbol","toStringTag","Proxy","deleteProperty","_keys","_cached","_resolveWithPrefixes","prefix","readKey","needsSubResolver","createSubResolver","getOwnPropertyDescriptor","Reflect","_scopes","getPrototypeOf","getKeysFromAllScopes","includes","ownKeys","_attachContext","subProxy","descriptorDefaults","_proxy","_context","_subProxy","_stack","override","receiver","_resolveWithContext","isScriptable","_resolveScriptable","Error","join","_resolveArray","isIndexable","resolver","allKeys","scriptable","indexable","_allKeys","resolveFallback","getScope","addScopes","parentScopes","parentFallback","_rootScopes","allScopes","firstParent","addScopesFromKey","resolveKeysFromAllScopes","EPSILON","getPoint","points","splineCurve","firstPoint","middlePoint","afterPoint","current","d01","d12","s01","s12","fa","fb","splineCurveMonotone","pointsLen","pointBefore","pointCurrent","deltaK","mK","pointAfter","slopeDeltaX","monotoneAdjust","alphaK","betaK","tauK","squaredMagnitude","monotoneCompute","capControlPoint","pt","_updateBezierControlPoints","controlPoints","spanGaps","cubicInterpolationMode","tension","capBezierPoints","inArea","inAreaPrev","inAreaNext","_pointInLine","_steppedInterpolation","_bezierInterpolation","cp1","cp2","getRightToLeftAdapter","rectX","setWidth","xPlus","leftForLtr","itemWidth","getLeftToRightAdapter","_itemWidth","getRtlAdapter","rtl","overrideTextDirection","direction","original","getPropertyPriority","setProperty","prevTextDirection","restoreTextDirection","propertyFn","between","compare","normalize","makeSubSegment","_boundSegment","segment","prevValue","startBound","endBound","getSegment","inside","subStart","shouldStart","shouldStop","_boundSegments","segments","sub","_computeSegments","findStartAndEnd","solidSegments","stop","_fullLoop","helpers","easingEffects","_deprecated","console","warn","pixelSize","fontStyle","fontFamily","TypedRegistry","isPrototypeOf","parentScope","isIChartComponent","register","registerDefaults","itemDefaults","routeDefaults","routes","propertyParts","sourceName","sourceScope","parts","Registry","registry","controllers","_typedRegistries","_each","_get","typedRegistry","arg","reg","_getRegistryForType","isForType","_exec","itemReg","component","camelMethod","PluginService","_init","hook","_createDescriptors","descriptor","plugin","cancelable","_oldCache","_notifyStateChanges","allPlugins","getPlugin","createDescriptors","getOpts","pluginOpts","previousDescriptors","some","pluginScopeKeys","getIndexAxis","datasetDefaults","datasetOptions","determineAxis","scaleOptions","axisFromPosition","initOptions","mergeScaleConfig","chartDefaults","configScales","chartIndexAxis","firstIDs","scaleConf","defaultId","getDefaultScaleIDFromAxis","defaultScaleOptions","defaultID","getAxisFromDefaultScaleID","keyCache","keysCached","cachedKeys","generate","addIfFound","Config","_config","initConfig","_scopeCache","_resolverCache","clearCache","clear","datasetType","additionalOptionScopes","mainScope","resetCache","keyLists","_cachedScopes","getResolver","subPrefixes","needContext","resolverCache","version","KNOWN_POSITIONS","positionIsHorizontal","compare2Level","l1","l2","onAnimationsComplete","onComplete","onAnimationProgress","onProgress","isDomSupported","getCanvas","getElementById","instances","getChart","initialCanvas","existingChart","chartOptionScopes","_initializePlatform","acquireContext","_options","_aspectRatio","_metasets","_lastEvent","_listeners","_sortedMetasets","_plugins","_hiddenIndices","attached","_doResize","resizeDelay","listen","_initialize","error","bindEvents","OffscreenCanvas","_resizeBeforeDraw","_resize","newSize","oldRatio","newRatio","onResize","render","axisOptions","scaleOpts","updated","isRadial","dposition","dtype","scaleType","getScale","init","hasUpdated","oldIndex","_destroyDatasetMeta","_dataset","newControllers","_removeUnreferencedMetasets","order","_updateMetasetIndex","isDatasetVisible","updateIndex","ControllerClass","getController","getElement","_updateMetasets","reset","_resetElements","animsDisabled","ensureScalesHaveIDs","buildOrUpdateScales","invalidate","buildOrUpdateControllers","buildOrUpdateElements","_updateLayout","_updateDatasets","_eventHandler","noArea","_idx","_updateDataset","layers","_drawDatasets","_drawDataset","hidden","setDatasetVisibility","_updateDatasetVisibility","_destroy","remove","unbindEvents","releaseContext","toDataURL","_add","_remove","detached","isAttached","activeElements","lastActive","_updateHoverStyles","notify","replay","hoverOptions","deactivated","activated","updateHoverStyle","_handleEvent","lastEvent","getElementsAtEventForMode","invalidatePlugins","abstract","unregister","DateAdapter","timestamp","amount","unit","weekday","members","_adapters","_date","computeMinSampleSize","curr","getAllScaleValues","$bar","getAllParsedValues","updateMinAndPrev","parseValue","parseFloatBar","startValue","endValue","barStart","barEnd","_custom","parseArrayOrPrimitive","isFloatBar","custom","BarController","iAxisKey","vAxisKey","bars","getBasePixel","ruler","_getRuler","firstOpts","includeOptions","updateSharedOptions","vpixels","head","_calculateBarValuePixels","ipixels","_calculateBarIndexPixels","updateElement","_getStacks","pixels","barThickness","stackCount","_getStackCount","grouped","categoryPercentage","barPercentage","baseValue","minBarLength","floating","getDataVisibility","actualBase","halfGrid","getLineWidthForValue","maxBarThickness","Infinity","skipNull","computeFlexCategoryTraits","percent","chunk","computeFitCategoryTraits","thickness","stackIndex","_getStackIndex","rects","_index_","_value_","BubbleController","getPixelForDecimal","tooltip","DoughnutController","innerRadius","outerRadius","circumference","_getRotation","_getCircumference","arcs","getMaxBorderWidth","getMaxOffset","maxSize","cutout","chartWeight","_getRingWeight","_getRotationExtents","getRatioAndOffset","ratioX","ratioY","startAngle","endAngle","startX","startY","endX","endY","calcMax","calcMin","maxX","maxY","minX","minY","maxRadius","radiusLength","_getVisibleDatasetWeightTotal","calculateTotal","_getRingWeightOffset","animateRotate","calculateCircumference","animationOpts","centerX","centerY","animateScale","_circumference","metaData","borderAlign","hoverBorderWidth","hoverOffset","ringWeightOffset","legend","generateLabels","legendItem","toggleDataVisibility","tooltipItem","dataLabel","formattedValue","LineController","animationsDisabled","getStartAndCountOfVisiblePoints","pointCount","scaleRangesChanged","_scaleRanges","newRanges","xmin","xmax","ymin","ymax","_decimated","animated","maxGapLength","directUpdate","prevParsed","border","lastPoint","updateControlPoints","PolarAreaController","_updateRadius","cutoutPercentage","getVisibleDatasetCount","xCenter","yCenter","datasetStartAngle","getIndexAngle","defaultAngle","countVisibleElements","_computeAngle","getDistanceFromCenterForValue","angleLines","circular","pointLabels","PieController","RadarController","pointPosition","getPointPositionForValue","ScatterController","clipArc","pixelMargin","angleMargin","pathArc","inner","lineJoin","fullCircles","drawFullCircleBorders","ArcElement","chartX","chartY","betweenAngles","halfAngle","halfRadius","drawArc","pathVars","pathSegment","lineMethod","getLineMethod","stepped","fastPathSegment","prevX","lastY","avgX","countX","pointIndex","drawX","truncX","_getSegmentMethod","useFastPath","usePath2D","strokePath","Path2D","strokePathWithCache","path","_path","strokePathDirect","LineElement","_points","_segments","_pointsUpdated","_interpolate","_getInterpolationMethod","interpolated","segmentMethod","setStyle","vm","lineCap","borderCapStyle","borderJoinStyle","inRange$1","hitRadius","PointElement","mouseX","mouseY","hoverRadius","getBarBounds","bar","half","parseBorderSkipped","borderSkipped","parseEdge","swap","orig","v2","startEnd","skipOrLimit","boundingRects","parseBorderWidth","maxW","maxH","o","parseBorderRadius","borderRadius","maxR","topLeft","topRight","bottomLeft","bottomRight","outer","skipX","skipY","addRoundedRectPath","addNormalRectPath","BarElement","addRectPath","plugin_decimation","algorithm","beforeElementsUpdate","xAxis","decimated","lttbDecimation","samples","maxAreaPoint","maxArea","nextA","bucketWidth","sampledIndex","avgY","avgRangeStart","avgRangeEnd","avgRangeLength","rangeOffs","rangeTo","pointAx","pointAy","minMaxDecimation","minIndex","maxIndex","startIndex","xMin","dx","lastIndex","intermediateIndex1","intermediateIndex2","destroy","decodeFill","parseFillOption","fillOption","simpleArc","computeBoundary","computeCircularBoundary","computeLinearBoundary","buildStackLine","sourcePoints","linesBelow","getLinesBelow","below","isLineAndNotInHideAnimation","unshift","createBoundaryLine","addPointsBelow","sourcePoint","postponed","findPoint","interpolate","pointValue","linePoints","firstValue","lastValue","boundary","pointsFromSegments","resolveTarget","propagate","visited","clipY","getBounds","_getEdge","clipBounds","interpolatedLineTo","interpolatedPoint","_fill","tpoints","subs","subBounds","fillSources","src","tgt","lineLoop","targetLoop","plugin_filler","afterDatasetsUpdate","_args","$filler","beforeDatasetsDraw","beforeDatasetDraw","getTarget","getLineByIndex","lineOpts","above","doFill","getBoxSize","labelOpts","fontSize","boxHeight","boxWidth","usePointStyle","itemHeight","Legend","_added","legendHitBoxes","_hoveredItem","doughnutMode","legendItems","columnSizes","lineWidths","buildLabels","labelFont","_computeTitleHeight","_fitRows","_fitCols","hitboxes","totalHeight","row","heightLimit","totalWidth","currentColWidth","currentColHeight","col","hitbox","_draw","cursor","defaultColor","rtlHelper","fontColor","halfFontSize","textDirection","lineDash","drawOptions","SQRT2","yBoxTop","strokeRect","drawLegendBox","titleFont","titlePadding","topPaddingPlusHalfFontSize","hitBox","lh","isListened","onLeave","hoveredItem","_getLegendItemAt","sameItem","plugin_legend","_element","adjustHitBoxes","afterEvent","handleEvent","ci","Title","_padding","textSize","fontOpts","_drawArgs","plugin_title","createTitle","titleBlock","positioners","average","hasValue","tooltipPosition","eventPosition","nearestElement","tp","pushOrConcat","toPush","splitNewlines","String","getTooltipSize","body","footer","bodyFont","footerFont","titleLineCount","footerLineCount","bodyLineItemCount","combinedBodyLength","bodyItem","before","after","beforeBody","afterBody","titleSpacing","titleMarginBottom","displayColors","bodySpacing","footerMarginTop","footerSpacing","widthPadding","maxLineWidth","determineXAlign","yAlign","chartWidth","xAlign","doesNotFitWithAlign","caret","caretSize","caretPadding","determineAlignment","determineYAlign","getBackgroundPoint","alignment","paddingAndSize","radiusAndPadding","alignX","alignY","getAlignedX","getBeforeAfterBodyLines","overrideCallbacks","Tooltip","opacity","_eventPosition","_size","_cachedAnimations","_tooltipItems","dataPoints","caretX","caretY","labelColors","labelPointStyles","labelTextColors","tooltipItems","beforeTitle","afterTitle","bodyItems","scoped","beforeLabel","afterLabel","beforeFooter","afterFooter","getLabelAndValue","itemSort","labelColor","labelPointStyle","labelTextColor","_createItems","getTitle","getBeforeBody","getBody","getAfterBody","getFooter","positionAndSize","backgroundPoint","external","tooltipPoint","caretPosition","getCaretPosition","x3","y3","ptX","ptY","titleColor","colorX","rtlColorX","yOffSet","colorY","multiKeyBackground","textColor","bodyAlign","bodyLineHeight","xLinePadding","fillLineOfText","bodyAlignForCalculation","bodyColor","_drawColorBox","footerAlign","footerColor","tooltipSize","drawCaret","quadraticCurveTo","animX","animY","_updateAnimationTarget","hasTooltipContent","globalAlpha","drawBody","drawFooter","positionChanged","_positionChanged","plugin_tooltip","afterInit","afterDraw","labelCount","Decimation","Filler","addIfString","CategoryScale","_startValue","_valueRange","findOrAddLabel","lastIndexOf","getDecimalForPixel","LinearScaleBase","_endValue","setMin","setMax","minSign","maxSign","maxTicks","stepSize","computeTickLimit","getTickLimit","generateTicks$1","generationOptions","dataRange","niceMin","niceMax","numSpaces","step","precision","maxSpaces","rmin","rmax","countDefined","LinearScale","handleTickRangeOptions","isMajor","tickVal","LogarithmicScale","_zero","exp","generateTicks","endExp","endSignificand","significand","lastTick","getTickBackdropHeight","backdropPadding","determineLimits","getTextAlignForAngle","adjustPointPositionForLabelHeight","pathRadiusLine","getPointPosition","numberOrZero","param","RadialLinearScale","drawingArea","_pointLabels","_pointLabelItems","fitWithPointLabels","furthestLimits","furthestAngles","valueCount","plFont","hLimits","vLimits","_setReductions","tickBackdropHeight","outerDistance","extra","pointLabelPosition","setCenterPoint","largestPossibleRadius","radiusReductionLeft","radiusReductionRight","radiusReductionTop","radiusReductionBottom","leftMovement","rightMovement","topMovement","bottomMovement","maxRight","maxLeft","maxTop","maxBottom","scalingFactor","scaledDistance","distanceFromCenter","drawPointLabels","backdropColor","drawRadiusLine","gridLineOpts","showLabelBackdrop","animate","INTERVALS","millisecond","common","steps","second","minute","hour","day","week","month","quarter","year","UNITS","sorter","adapter","_adapter","time","parser","isoWeekday","startOf","determineUnitForAutoTicks","minUnit","capacity","interval","MAX_SAFE_INTEGER","addTick","timestamps","ticksFromTimestamps","majorUnit","setMajorTicks","TimeScale","_unit","_majorUnit","_offsets","_normalized","adapters","displayFormats","formats","normalized","_applyBounds","_getLabelBounds","endOf","getLabelTimestamps","timeOpts","_generate","_getLabelCapacity","determineUnitForFormatting","determineMajorUnit","initOffsets","getDecimalForValue","limit","hasWeekday","getDataTimestamps","tooltipFormat","datetime","minorFormat","majorFormat","_tickFormatFunction","offsets","ticksOpts","tickLabelWidth","cosRotation","sinRotation","tickFontSize","exampleTime","exampleLabel","_getLabelSize","prevSource","nextSource","prevTarget","nextTarget","span","TimeSeriesScale","_table","_maxIndex","_getTimestampsForTable","buildLookupTable"],"mappings":";;;AAMA,IAAA,EAAA,EAAA,UAAA,GAAA,SAAA,EAAA,EAAA,GAAA,IAAA,EAAA,OAAA,KAAA,GAAA,GAAA,OAAA,sBAAA,CAAA,IAAA,EAAA,OAAA,sBAAA,GAAA,IAAA,EAAA,EAAA,OAAA,SAAA,GAAA,OAAA,OAAA,yBAAA,EAAA,GAAA,cAAA,EAAA,KAAA,MAAA,EAAA,GAAA,OAAA,EAAA,SAAA,EAAA,GAAA,IAAA,IAAA,EAAA,EAAA,EAAA,UAAA,OAAA,IAAA,CAAA,IAAA,EAAA,MAAA,UAAA,GAAA,UAAA,GAAA,GAAA,EAAA,EAAA,EAAA,OAAA,IAAA,GAAA,QAAA,SAAA,GAAA,EAAA,EAAA,EAAA,EAAA,MAAA,OAAA,0BAAA,OAAA,iBAAA,EAAA,OAAA,0BAAA,IAAA,EAAA,OAAA,IAAA,QAAA,SAAA,GAAA,OAAA,eAAA,EAAA,EAAA,OAAA,yBAAA,EAAA,MAAA,OAAA,EAAA,SAAA,EAAA,EAAA,EAAA,GAAA,OAAA,EAAA,oBAAA,SAAA,QAAA,IAAA,QAAA,IAAA,SAAA,EAAA,EAAA,GAAA,IAAA,EAAA,EAAA,EAAA,GAAA,GAAA,EAAA,CAAA,IAAA,EAAA,OAAA,yBAAA,EAAA,GAAA,OAAA,EAAA,IAAA,EAAA,IAAA,KAAA,GAAA,EAAA,SAAA,EAAA,EAAA,GAAA,GAAA,SAAA,EAAA,EAAA,GAAA,MAAA,OAAA,UAAA,eAAA,KAAA,EAAA,IAAA,QAAA,EAAA,EAAA,MAAA,OAAA,EAAA,SAAA,EAAA,EAAA,GAAA,GAAA,mBAAA,GAAA,OAAA,EAAA,MAAA,IAAA,UAAA,sDAAA,EAAA,UAAA,OAAA,OAAA,GAAA,EAAA,UAAA,CAAA,YAAA,CAAA,MAAA,EAAA,UAAA,EAAA,cAAA,KAAA,GAAA,EAAA,EAAA,GAAA,SAAA,EAAA,EAAA,GAAA,OAAA,EAAA,OAAA,gBAAA,SAAA,EAAA,GAAA,OAAA,EAAA,UAAA,EAAA,IAAA,EAAA,GAAA,SAAA,EAAA,GAAA,IAAA,EAAA,IAAA,OAAA,WAAA,IAAA,EAAA,EAAA,EAAA,GAAA,GAAA,EAAA,CAAA,IAAA,EAAA,EAAA,MAAA,YAAA,EAAA,QAAA,UAAA,EAAA,UAAA,QAAA,EAAA,EAAA,MAAA,KAAA,WAAA,OAAA,EAAA,KAAA,IAAA,SAAA,EAAA,EAAA,GAAA,OAAA,GAAA,WAAA,EAAA,IAAA,mBAAA,EAAA,EAAA,GAAA,EAAA,SAAA,EAAA,GAAA,QAAA,IAAA,EAAA,MAAA,IAAA,eAAA,6DAAA,OAAA,EAAA,SAAA,IAAA,GAAA,oBAAA,UAAA,QAAA,UAAA,OAAA,EAAA,GAAA,QAAA,UAAA,KAAA,OAAA,EAAA,GAAA,mBAAA,MAAA,OAAA,EAAA,IAAA,OAAA,QAAA,UAAA,QAAA,KAAA,QAAA,UAAA,QAAA,GAAA,gBAAA,EAAA,MAAA,GAAA,OAAA,GAAA,SAAA,EAAA,GAAA,OAAA,EAAA,OAAA,eAAA,OAAA,eAAA,SAAA,GAAA,OAAA,EAAA,WAAA,OAAA,eAAA,KAAA,GAAA,SAAA,EAAA,EAAA,GAAA,IAAA,EAAA,GAAA,oBAAA,QAAA,MAAA,EAAA,OAAA,UAAA,CAAA,GAAA,MAAA,QAAA,KAAA,EAAA,EAAA,KAAA,GAAA,GAAA,iBAAA,EAAA,OAAA,CAAA,IAAA,EAAA,GAAA,IAAA,EAAA,EAAA,EAAA,aAAA,MAAA,CAAA,EAAA,EAAA,EAAA,WAAA,OAAA,GAAA,EAAA,OAAA,CAAA,MAAA,GAAA,CAAA,MAAA,EAAA,MAAA,EAAA,OAAA,EAAA,SAAA,GAAA,MAAA,GAAA,EAAA,GAAA,MAAA,IAAA,UAAA,yIAAA,IAAA,EAAA,GAAA,EAAA,GAAA,EAAA,MAAA,CAAA,EAAA,WAAA,EAAA,EAAA,OAAA,aAAA,EAAA,WAAA,IAAA,EAAA,EAAA,OAAA,OAAA,EAAA,EAAA,KAAA,GAAA,EAAA,SAAA,GAAA,GAAA,EAAA,EAAA,GAAA,EAAA,WAAA,IAAA,GAAA,MAAA,EAAA,QAAA,EAAA,SAAA,QAAA,GAAA,EAAA,MAAA,KAAA,SAAA,EAAA,EAAA,EAAA,GAAA,OAAA,KAAA,EAAA,OAAA,eAAA,EAAA,EAAA,CAAA,MAAA,EAAA,YAAA,EAAA,cAAA,EAAA,UAAA,IAAA,EAAA,GAAA,EAAA,EAAA,SAAA,EAAA,GAAA,OAAA,EAAA,IAAA,EAAA,IAAA,EAAA,IAAA,IAAA,SAAA,IAAA,MAAA,IAAA,UAAA,wIAAA,SAAA,EAAA,EAAA,GAAA,GAAA,EAAA,CAAA,GAAA,iBAAA,EAAA,OAAA,EAAA,EAAA,GAAA,IAAA,EAAA,OAAA,UAAA,SAAA,KAAA,GAAA,MAAA,GAAA,GAAA,MAAA,WAAA,GAAA,EAAA,cAAA,EAAA,EAAA,YAAA,MAAA,QAAA,GAAA,QAAA,EAAA,MAAA,KAAA,GAAA,cAAA,GAAA,2CAAA,KAAA,GAAA,EAAA,EAAA,QAAA,GAAA,SAAA,EAAA,GAAA,GAAA,oBAAA,QAAA,OAAA,YAAA,OAAA,GAAA,OAAA,MAAA,KAAA,GAAA,SAAA,EAAA,GAAA,GAAA,MAAA,QAAA,GAAA,OAAA,EAAA,GAAA,SAAA,EAAA,EAAA,IAAA,MAAA,GAAA,EAAA,EAAA,UAAA,EAAA,EAAA,QAAA,IAAA,IAAA,EAAA,EAAA,EAAA,IAAA,MAAA,GAAA,EAAA,EAAA,IAAA,EAAA,GAAA,EAAA,GAAA,OAAA,EAAA,SAAA,EAAA,EAAA,GAAA,KAAA,aAAA,GAAA,MAAA,IAAA,UAAA,qCAAA,SAAA,EAAA,EAAA,GAAA,IAAA,IAAA,EAAA,EAAA,EAAA,EAAA,OAAA,IAAA,CAAA,IAAA,EAAA,EAAA,GAAA,EAAA,WAAA,EAAA,aAAA,EAAA,EAAA,cAAA,EAAA,UAAA,IAAA,EAAA,UAAA,GAAA,OAAA,eAAA,EAAA,EAAA,IAAA,IAAA,SAAA,EAAA,EAAA,EAAA,GAAA,OAAA,GAAA,EAAA,EAAA,UAAA,GAAA,GAAA,EAAA,EAAA,GAAA,EAAA,SAAA,EAAA,GAAA,OAAA,EAAA,mBAAA,QAAA,iBAAA,OAAA,SAAA,SAAA,GAAA,cAAA,GAAA,SAAA,GAAA,OAAA,GAAA,mBAAA,QAAA,EAAA,cAAA,QAAA,IAAA,OAAA,UAAA,gBAAA,IAAA,IAAC,SAAUA,EAAQC,GACI,YAAZC,oBAAAA,QAAAA,YAAAA,EAAAA,WAA0C,oBAAXC,OAAyBA,OAAOD,QAAUD,IAC1D,mBAAXG,GAAyBA,EAAOC,IAAMD,EAAOH,IAC/CD,EAA+B,oBAAfM,WAA6BA,WAAaN,GAAUO,MAAaC,MAAQP,IAHrG,CAIC,KAAO,WACL,aAMMQ,IAAAA,EACoB,oBAAXC,OACA,SAAUC,GACNA,OAAAA,KAGRD,OAAOE,sBAGTC,SAAAA,EAAUC,EAAIC,EAASC,GACtBC,IAAAA,EAAaD,GAAa,SAACE,GAASC,OAAAA,MAAMC,UAAUC,MAAMC,KAAKJ,IACjEK,GAAU,EACVL,EAAO,GACJ,OAAA,WAAaM,IAAAA,IAAAA,EAAAA,UAAAA,OAAAA,EAAM,IAAA,MAAA,GAAA,EAAA,EAAA,EAAA,EAAA,IAANA,EAAM,GAAA,UAAA,GACtBN,EAAOD,EAAWO,GACbD,IACDA,GAAU,EACVd,EAAiBa,KAAKZ,OAAQ,WAC1Ba,GAAU,EACVT,EAAGW,MAAMV,EAASG,OAMzBQ,SAAAA,EAASZ,EAAIa,GACdC,IAAAA,EACG,OAAA,WAOID,OANHA,GACAE,aAAaD,GACbA,EAAUE,WAAWhB,EAAIa,IAEzBb,IAEGa,GAITI,IAAAA,EAAqB,SAACC,GAAUA,MAAU,UAAVA,EAAoB,OAAmB,QAAVA,EAAkB,QAAU,UACzFC,EAAiB,SAACD,EAAOE,EAAOC,GAAQH,MAAU,UAAVA,EAAoBE,EAAkB,QAAVF,EAAkBG,GAAOD,EAAQC,GAAO,GAC5GC,EAAS,SAACJ,EAAOK,EAAMC,GAAUN,MAAU,UAAVA,EAAoBM,EAAkB,WAAVN,GAAsBK,EAAOC,GAAS,EAAID,GAoJzGE,EAAW,IAnME,WAkDC,SAAA,IAAA,EAAA,KAAA,GACLC,KAAAA,SAAW,KACXC,KAAAA,QAAU,IAAIC,IACdC,KAAAA,UAAW,EACXC,KAAAA,eAAYC,EAtDR,OAAA,EAAA,EAAA,CAAA,CAAA,IAAA,UAyDb,MAAA,SAAQC,EAAOC,EAAOC,EAAMC,GAClBC,IAAAA,EAAYH,EAAMI,UAAUF,GAC5BG,EAAWL,EAAMM,SACvBH,EAAUI,QAAQ,SAAAxC,GAAMA,OAAAA,EAAG,CACvBgC,MAAAA,EACAM,SAAAA,EACAG,YAAaC,KAAKC,IAAIT,EAAOD,EAAMb,MAAOkB,SA/DrC,CAAA,IAAA,WAmEb,MAAA,WACUM,IAAAA,EAAK,KACPA,EAAGlB,WAGPkB,EAAGf,UAAW,EACde,EAAGlB,SAAW/B,EAAiBa,KAAKZ,OAAQ,WACxCgD,EAAGC,UACHD,EAAGlB,SAAW,KACVkB,EAAGf,UACHe,EAAGE,gBA7EF,CAAA,IAAA,UAkFb,MAAA,WAAQZ,IAAAA,EAAOa,UAAAA,OAAAA,QAAAA,IAAAA,UAAAA,GAAAA,UAAAA,GAAAA,KAAKC,MACVJ,EAAK,KACPK,EAAY,EAChBL,EAAGjB,QAAQa,QAAQ,SAACP,EAAOD,GACnB,GAACC,EAAMiB,SAAYjB,EAAMkB,MAAMC,OAA/B,CAOGC,IAJDF,IAGFG,EAHEH,EAAQlB,EAAMkB,MAChBE,EAAIF,EAAMC,OAAS,EACnBG,GAAO,EAEJF,GAAK,IAAKA,GACbC,EAAOH,EAAME,IACJG,SACDF,EAAKG,OAASxB,EAAMM,WACpBN,EAAMM,SAAWe,EAAKG,QAE1BH,EAAKI,KAAKxB,GACVqB,GAAO,IAEPJ,EAAME,GAAKF,EAAMA,EAAMC,OAAS,GAChCD,EAAMQ,OAGVJ,IACAvB,EAAMuB,OACNX,EAAGgB,QAAQ5B,EAAOC,EAAOC,EAAM,aAE9BiB,EAAMC,SACPnB,EAAMiB,SAAU,EAChBN,EAAGgB,QAAQ5B,EAAOC,EAAOC,EAAM,aAEnCe,GAAaE,EAAMC,UAEvBR,EAAGd,UAAYI,EACG,IAAde,IACAL,EAAGf,UAAW,KAtHT,CAAA,IAAA,YA0Hb,MAAA,SAAUG,GACA6B,IAAAA,EAAS,KAAKlC,QAChBM,EAAQ4B,EAAOC,IAAI9B,GAYhBC,OAXFA,IACDA,EAAQ,CACJiB,SAAS,EACTC,MAAO,GACPd,UAAW,CACP0B,SAAU,GACVC,SAAU,KAGlBH,EAAOI,IAAIjC,EAAOC,IAEfA,IAxIE,CAAA,IAAA,SA2Ib,MAAA,SAAOD,EAAOkC,EAAOC,GACZC,KAAAA,UAAUpC,GAAOK,UAAU6B,GAAOG,KAAKF,KA5InC,CAAA,IAAA,MA+Ib,MAAA,SAAInC,EAAOmB,GAAO,IAAA,EACTA,GAAUA,EAAMC,SAGhBgB,EAAAA,KAAAA,UAAUpC,GAAOmB,OAAMkB,KAAQlB,MAAAA,EAAAA,EAAAA,MAnJ3B,CAAA,IAAA,MAsJb,MAAA,SAAInB,GACO,OAAA,KAAKoC,UAAUpC,GAAOmB,MAAMC,OAAS,IAvJnC,CAAA,IAAA,QA0Jb,MAAA,SAAMpB,GACIC,IAAAA,EAAQ,KAAKN,QAAQmC,IAAI9B,GAC1BC,IAGLA,EAAMiB,SAAU,EAChBjB,EAAMb,MAAQ2B,KAAKC,MACnBf,EAAMM,SAAWN,EAAMkB,MAAMmB,OAAO,SAACC,EAAKC,GAAQ9B,OAAAA,KAAK+B,IAAIF,EAAKC,EAAIE,YAAY,GAC3E5B,KAAAA,cAlKI,CAAA,IAAA,UAqKb,MAAA,SAAQd,GACA,IAAC,KAAKH,SACC,OAAA,EAELI,IAAAA,EAAQ,KAAKN,QAAQmC,IAAI9B,GAC3B,SAACC,GAAUA,EAAMiB,SAAYjB,EAAMkB,MAAMC,UA1KpC,CAAA,IAAA,OAgLb,MAAA,SAAKpB,GACKC,IAAAA,EAAQ,KAAKN,QAAQmC,IAAI9B,GAC3B,GAACC,GAAUA,EAAMkB,MAAMC,OAAvB,CAKGC,IAFDF,IAAAA,EAAQlB,EAAMkB,MAChBE,EAAIF,EAAMC,OAAS,EAChBC,GAAK,IAAKA,EACbF,EAAME,GAAGsB,SAEb1C,EAAMkB,MAAQ,GACTS,KAAAA,QAAQ5B,EAAOC,EAAOc,KAAKC,MAAO,eA3L9B,CAAA,IAAA,SA8Lb,MAAA,SAAOhB,GACI,OAAA,KAAKL,QAAQiD,OAAO5C,OA/LlB,EAAA,IA2MX6C,EAAM,CACL,EAAA,EACA,EAAA,EACA,EAAA,EACA,EAAA,EACA,EAAA,EACA,EAAA,EACA,EAAA,EACA,EAAA,EACA,EAAA,EACA,EAAA,EACHC,EAAG,GACHC,EAAG,GACHC,EAAG,GACHC,EAAG,GACHC,EAAG,GACHC,EAAG,GACHC,EAAG,GACHC,EAAG,GACHC,EAAG,GACHC,EAAG,GACHC,EAAG,GACHC,EAAG,IAEDC,EAAM,mBACNC,EAAK,SAACN,GAAMK,OAAAA,EAAQ,GAAJL,IAChBO,EAAK,SAACP,GAAMK,OAAAA,GAAS,IAAJL,IAAa,GAAKK,EAAQ,GAAJL,IACvCQ,EAAK,SAACR,GAAQ,OAAK,IAAJA,IAAa,IAAY,GAAJA,IA6BjCS,SAAAA,EAAUC,GACXN,IAAAA,EA5BCO,SAAQD,GACNF,OAAAA,EAAGE,EAAEE,IAAMJ,EAAGE,EAAEG,IAAML,EAAGE,EAAEV,IAAMQ,EAAGE,EAAEX,GA2BrCY,CAAQD,GAAKJ,EAAKC,EACnBG,OAAAA,EACD,IAAMN,EAAEM,EAAEE,GAAKR,EAAEM,EAAEG,GAAKT,EAAEM,EAAEV,IAAMU,EAAEX,EAAI,IAAMK,EAAEM,EAAEX,GAAK,IACvDW,EAGDI,SAAAA,EAAMJ,GACJA,OAAAA,EAAI,GAAM,EAGfK,IAAAA,EAAM,SAACL,EAAGM,EAAGC,GAAM5D,OAAAA,KAAK+B,IAAI/B,KAAKC,IAAIoD,EAAGO,GAAID,IAEzCE,SAAAA,EAAIR,GACFK,OAAAA,EAAID,EAAU,KAAJJ,GAAW,EAAG,KAG1BS,SAAAA,EAAIT,GACFK,OAAAA,EAAID,EAAU,IAAJJ,GAAU,EAAG,KAGzBU,SAAAA,EAAIV,GACFK,OAAAA,EAAID,EAAMJ,EAAI,MAAQ,IAAK,EAAG,GAGhCW,SAAAA,EAAIX,GACFK,OAAAA,EAAID,EAAU,IAAJJ,GAAU,EAAG,KAG5BY,IAAAA,EAAS,uGAmCTC,IAAAA,EAAS,+GAENC,SAAAA,EAASP,EAAGQ,EAAGT,GACdjB,IAAAA,EAAI0B,EAAIpE,KAAKC,IAAI0D,EAAG,EAAIA,GACxBZ,EAAI,SAACsB,GAAGC,IAAAA,EAAI,UAAA,OAAA,QAAA,IAAA,UAAA,GAAA,UAAA,IAACD,EAAIT,EAAI,IAAM,GAAOD,OAAAA,EAAIjB,EAAI1C,KAAK+B,IAAI/B,KAAKC,IAAIqE,EAAI,EAAG,EAAIA,EAAG,IAAK,IAC9E,MAAA,CAACvB,EAAE,GAAIA,EAAE,GAAIA,EAAE,IAGjBwB,SAAAA,EAASX,EAAGQ,EAAGf,GACdN,IAAAA,EAAI,SAACsB,GAAGC,IAAAA,EAAI,UAAA,OAAA,QAAA,IAAA,UAAA,GAAA,UAAA,IAACD,EAAIT,EAAI,IAAM,EAAMP,OAAAA,EAAIA,EAAIe,EAAIpE,KAAK+B,IAAI/B,KAAKC,IAAIqE,EAAG,EAAIA,EAAG,GAAI,IAC5E,MAAA,CAACvB,EAAE,GAAIA,EAAE,GAAIA,EAAE,IAGjByB,SAAAA,EAASZ,EAAGa,EAAG9B,GACd+B,IACF/D,EADE+D,EAAMP,EAASP,EAAG,EAAG,IAOtBjD,IALD8D,EAAI9B,EAAI,IAER8B,GADA9D,EAAI,GAAK8D,EAAI9B,GAEbA,GAAKhC,GAEJA,EAAI,EAAGA,EAAI,EAAGA,IACf+D,EAAI/D,IAAM,EAAI8D,EAAI9B,EAClB+B,EAAI/D,IAAM8D,EAEPC,OAAAA,EAGFC,SAAAA,EAAQtB,GACPuB,IAOFhB,EAAGQ,EAAGvB,EANJU,EAAIF,EAAEE,EADE,IAERC,EAAIH,EAAEG,EAFE,IAGRb,EAAIU,EAAEV,EAHE,IAIRZ,EAAM/B,KAAK+B,IAAIwB,EAAGC,EAAGb,GACrB1C,EAAMD,KAAKC,IAAIsD,EAAGC,EAAGb,GACrBgB,GAAK5B,EAAM9B,GAAO,EAYjB,OAVH8B,IAAQ9B,IACR4C,EAAId,EAAM9B,EACVmE,EAAIT,EAAI,GAAMd,GAAK,EAAId,EAAM9B,GAAO4C,GAAKd,EAAM9B,GAM/C2D,EAAQ,IALRA,EAAI7B,IAAQwB,GACJC,EAAIb,GAAKE,GAAMW,EAAIb,EAAI,EAAI,GAC7BZ,IAAQyB,GACHb,EAAIY,GAAKV,EAAI,GACbU,EAAIC,GAAKX,EAAI,GACX,IAEV,CAAK,EAAJe,EAAOQ,GAAK,EAAGT,GAGlBkB,SAAAA,EAAM9B,EAAGL,EAAGC,EAAGC,GACb,OACHjF,MAAMmH,QAAQpC,GACRK,EAAEL,EAAE,GAAIA,EAAE,GAAIA,EAAE,IAChBK,EAAEL,EAAGC,EAAGC,IAChBT,IAAI2B,GAGDiB,SAAAA,EAAQnB,EAAGQ,EAAGT,GACZkB,OAAAA,EAAMV,EAAUP,EAAGQ,EAAGT,GAWxBqB,SAAAA,EAAIpB,GACF,OAACA,EAAI,IAAM,KAAO,IAGpBqB,SAAAA,EAASC,GACRC,IAEF9B,EAFE8B,EAAIjB,EAAOkB,KAAKF,GAClBxC,EAAI,IAEJ,GAACyC,EAAD,CAGAA,EAAE,KAAO9B,IACTX,EAAIyC,EAAE,GAAKtB,GAAKsB,EAAE,IAAMrB,GAAKqB,EAAE,KAE7BvB,IAAAA,EAAIoB,GAAKG,EAAE,IACXE,GAAMF,EAAE,GAAK,IACbG,GAAMH,EAAE,GAAK,IAQZ,MAAA,CACH5B,GAPAF,EADS,QAAT8B,EAAE,GAzBDI,SAAQ3B,EAAGa,EAAG9B,GACZkC,OAAAA,EAAML,EAAUZ,EAAGa,EAAG9B,GAyBrB4C,CAAQ3B,EAAGyB,EAAIC,GACH,QAATH,EAAE,GAvBRK,SAAQ5B,EAAGQ,EAAGf,GACZwB,OAAAA,EAAMN,EAAUX,EAAGQ,EAAGf,GAuBrBmC,CAAQ5B,EAAGyB,EAAIC,GAEfP,EAAQnB,EAAGyB,EAAIC,IAGd,GACL9B,EAAGH,EAAE,GACLV,EAAGU,EAAE,GACLX,EAAGA,IA0BL+C,IAqMFC,EArMED,EAAQ,CACVE,EAAG,OACHC,EAAG,QACHC,EAAG,KACHC,EAAG,MACHC,EAAG,KACHC,EAAG,SACHC,EAAG,QACH7D,EAAG,KACH8D,EAAG,KACHC,EAAG,KACH9D,EAAG,KACHC,EAAG,QACHC,EAAG,QACH6D,EAAG,KACHC,EAAG,WACH7D,EAAG,KACH8D,EAAG,KACHC,EAAG,KACHC,EAAG,KACHC,EAAG,KACHC,EAAG,QACHjE,EAAG,KACHkE,EAAG,KACHC,EAAG,OACHC,EAAG,KACHC,EAAG,QACHC,EAAG,MAEDC,EAAQ,CACVC,OAAQ,SACRC,YAAa,SACbC,KAAM,OACNC,UAAW,SACXC,KAAM,SACNC,MAAO,SACPC,OAAQ,SACRC,MAAO,IACPC,aAAc,SACdC,GAAI,KACJC,QAAS,SACTC,KAAM,SACNC,UAAW,SACXC,OAAQ,SACRC,SAAU,SACVC,QAAS,SACTC,IAAK,SACLC,YAAa,SACbC,QAAS,SACTC,QAAS,SACTC,KAAM,OACNC,IAAK,KACLC,MAAO,OACPC,QAAS,SACTC,KAAM,SACNC,KAAM,OACNC,KAAM,SACNC,OAAQ,SACRC,QAAS,SACTC,SAAU,SACVC,OAAQ,SACRC,MAAO,SACPC,IAAK,SACLC,OAAQ,SACRC,OAAQ,SACRC,KAAM,SACNC,MAAO,SACPC,MAAO,SACPC,IAAK,OACLC,OAAQ,SACRC,OAAQ,SACRC,SAAU,OACVC,OAAQ,SACRC,OAAQ,SACRC,SAAU,SACVC,SAAU,SACVC,SAAU,SACVC,SAAU,SACVC,OAAQ,SACRC,QAAS,SACTC,UAAW,SACXC,IAAK,SACLC,OAAQ,SACRC,IAAK,SACLC,IAAK,OACLC,MAAO,SACPC,IAAK,SACLC,QAAS,SACTC,OAAQ,SACRC,QAAS,SACTC,MAAO,SACPC,KAAM,SACNC,MAAO,SACPC,OAAQ,SACRC,UAAW,SACXC,QAAS,SACTC,WAAY,SACZC,IAAK,SACLC,KAAM,SACNC,MAAO,SACPC,UAAW,SACXC,KAAM,SACNC,KAAM,SACNC,KAAM,SACNC,KAAM,SACNC,OAAQ,SACRC,OAAQ,SACRC,OAAQ,SACRC,MAAO,SACPC,MAAO,SACPC,QAAS,SACTC,IAAK,SACLC,KAAM,OACNC,QAAS,SACTC,IAAK,SACLC,OAAQ,SACRC,MAAO,SACPC,WAAY,SACZC,IAAK,KACLC,MAAO,SACPC,OAAQ,SACRC,OAAQ,SACRC,KAAM,SACNC,UAAW,OACXC,IAAK,SACLC,SAAU,SACVC,WAAY,SACZC,QAAS,SACTC,SAAU,SACVC,QAAS,SACTC,WAAY,SACZC,KAAM,KACNC,OAAQ,SACRC,KAAM,SACNC,QAAS,SACTC,MAAO,SACPC,QAAS,SACTC,KAAM,SACNC,UAAW,SACXC,OAAQ,SACRC,MAAO,SACPC,WAAY,SACZC,UAAW,SACXC,QAAS,SACTC,KAAM,SACNC,IAAK,SACLC,KAAM,SACNC,QAAS,SACTC,MAAO,SACPC,YAAa,SACbC,GAAI,SACJC,SAAU,SACVC,MAAO,SACPC,UAAW,SACXC,MAAO,SACPC,UAAW,SACXC,MAAO,SACPC,QAAS,SACTC,MAAO,SACPC,OAAQ,SACRC,MAAO,SACPC,IAAK,SACLC,KAAM,SACNC,KAAM,SACNC,KAAM,SACNC,SAAU,OACVC,OAAQ,SACRC,IAAK,SACLC,IAAK,OACLC,MAAO,SACPC,OAAQ,SACRC,GAAI,SACJC,MAAO,SACPC,IAAK,SACLC,KAAM,SACNC,UAAW,SACXC,GAAI,SACJC,MAAO,UAsBFC,SAAAA,EAAUnL,GACVQ,KACDA,EArBC4K,WACCC,IAGF5P,EAAG6P,EAAGlM,EAAGmM,EAAIC,EAHXH,EAAW,GACXI,EAAOC,OAAOD,KAAK3J,GACnB6J,EAAQD,OAAOD,KAAKlL,GAErB9E,IAAAA,EAAI,EAAGA,EAAIgQ,EAAKjQ,OAAQC,IAAK,CAEzB6P,IADLC,EAAKC,EAAKC,EAAKhQ,GACV6P,EAAI,EAAGA,EAAIK,EAAMnQ,OAAQ8P,IAC1BlM,EAAIuM,EAAML,GACVE,EAAKA,EAAGI,QAAQxM,EAAGmB,EAAMnB,IAE7BA,EAAIyM,SAAS/J,EAAMyJ,GAAK,IACxBF,EAASG,GAAM,CAACpM,GAAK,GAAK,IAAMA,GAAK,EAAI,IAAU,IAAJA,GAE5CiM,OAAAA,EAOOD,IACFU,YAAc,CAAC,EAAG,EAAG,EAAG,IAE9BtO,IAAAA,EAAIgD,EAAQR,EAAI+L,eACfvO,OAAAA,GAAK,CACRa,EAAGb,EAAE,GACLc,EAAGd,EAAE,GACLC,EAAGD,EAAE,GACLA,EAAgB,IAAbA,EAAEhC,OAAegC,EAAE,GAAK,KAI1BwO,SAAAA,EAAO7N,EAAG1C,EAAGwQ,GACd9N,GAAAA,EAAG,CACC+N,IAAAA,EAAMzM,EAAQtB,GAClB+N,EAAIzQ,GAAKX,KAAK+B,IAAI,EAAG/B,KAAKC,IAAImR,EAAIzQ,GAAKyQ,EAAIzQ,GAAKwQ,EAAa,IAANxQ,EAAU,IAAM,IACvEyQ,EAAMrM,EAAQqM,GACd/N,EAAEE,EAAI6N,EAAI,GACV/N,EAAEG,EAAI4N,EAAI,GACV/N,EAAEV,EAAIyO,EAAI,IAITC,SAAAA,EAAQhO,EAAGiO,GACTjO,OAAAA,EAAIuN,OAAOW,OAAOD,GAAS,GAAIjO,GAAKA,EAGtCmO,SAAAA,EAAWC,GACZpO,IAAAA,EAAI,CAACE,EAAG,EAAGC,EAAG,EAAGb,EAAG,EAAGD,EAAG,KAYvBW,OAXH1F,MAAMmH,QAAQ2M,GACVA,EAAM/Q,QAAU,IAChB2C,EAAI,CAACE,EAAGkO,EAAM,GAAIjO,EAAGiO,EAAM,GAAI9O,EAAG8O,EAAM,GAAI/O,EAAG,KAC3C+O,EAAM/Q,OAAS,IACf2C,EAAEX,EAAIoB,EAAI2N,EAAM,OAIxBpO,EAAIgO,EAAQI,EAAO,CAAClO,EAAG,EAAGC,EAAG,EAAGb,EAAG,EAAGD,EAAG,KACvCA,EAAIoB,EAAIT,EAAEX,GAETW,EAGFqO,SAAAA,EAAcxM,GACfA,MAAkB,MAAlBA,EAAIyM,OAAO,GAlZVC,SAAS1M,GACRC,IAEF5B,EAAGC,EAAGb,EAFJwC,EAAIlB,EAAOmB,KAAKF,GAClBxC,EAAI,IAEJ,GAACyC,EAAD,CAGAA,GAAAA,EAAE,KAAO5B,EAAG,CACNF,IAAAA,GAAK8B,EAAE,GACbzC,EAAI,KAAOyC,EAAE,GAAKtB,EAAIR,GAAS,IAAJA,GAQxB,OANPE,GAAK4B,EAAE,GACP3B,GAAK2B,EAAE,GACPxC,GAAKwC,EAAE,GAIA,CACH5B,EAJJA,EAAI,KAAO4B,EAAE,GAAKtB,EAAIN,GAAKA,GAKvBC,EAJJA,EAAI,KAAO2B,EAAE,GAAKtB,EAAIL,GAAKA,GAKvBb,EAJJA,EAAI,KAAOwC,EAAE,GAAKtB,EAAIlB,GAAKA,GAKvBD,EAAGA,IA8XIkP,CAAS1M,GAEbD,EAASC,GAGd2M,IAAAA,EA1rBW,WA2rBDJ,SAAAA,EAAAA,GACJA,GADW,EAAA,KAAA,GACXA,aAAiBI,EACVJ,OAAAA,EAELhS,IACF4D,EApdM6B,EAEV4M,EADAC,EAkdMtS,EAAcgS,EAAAA,GAEP,WAAThS,EACA4D,EAAImO,EAAWC,GACC,WAAThS,IAtdXsS,GADU7M,EAwdOuM,GAvdP/Q,OAEC,MAAXwE,EAAI,KACQ,IAAR6M,GAAqB,IAARA,EACbD,EAAM,CACFvO,EAAG,IAAoB,GAAdpB,EAAI+C,EAAI,IACjB1B,EAAG,IAAoB,GAAdrB,EAAI+C,EAAI,IACjBvC,EAAG,IAAoB,GAAdR,EAAI+C,EAAI,IACjBxC,EAAW,IAARqP,EAA0B,GAAd5P,EAAI+C,EAAI,IAAW,KAEvB,IAAR6M,GAAqB,IAARA,IACpBD,EAAM,CACFvO,EAAGpB,EAAI+C,EAAI,KAAO,EAAI/C,EAAI+C,EAAI,IAC9B1B,EAAGrB,EAAI+C,EAAI,KAAO,EAAI/C,EAAI+C,EAAI,IAC9BvC,EAAGR,EAAI+C,EAAI,KAAO,EAAI/C,EAAI+C,EAAI,IAC9BxC,EAAW,IAARqP,EAAa5P,EAAI+C,EAAI,KAAO,EAAI/C,EAAI+C,EAAI,IAAO,OAwctD7B,EApcDyO,GAocwBzB,EAAUoB,IAAUC,EAAcD,IAExDO,KAAAA,KAAO3O,EACP4O,KAAAA,SAAW5O,EAvsBP,OAAA,EAAA,EAAA,CAAA,CAAA,IAAA,QA0sBb,IAAA,WACW,OAAA,KAAK4O,SA3sBH,CAAA,IAAA,MA8sBb,IAAA,WACQ5O,IAAAA,EAAIgO,EAAQ,KAAKW,MAId3O,OAHHA,IACAA,EAAEX,EAAIqB,EAAIV,EAAEX,IAETW,GAGX,IAAA,SAAQ6O,GACCF,KAAAA,KAAOR,EAAWU,KAvtBd,CAAA,IAAA,YA0tBb,MAAA,WACW,OAAA,KAAKD,QAhaD5O,EAgaoB,KAAK2O,QA9ZpC3O,EAAEX,EAAI,IACQW,QAAAA,OAAAA,EAAEE,EAAMF,MAAAA,OAAAA,EAAEG,EAAMH,MAAAA,OAAAA,EAAEV,EAAMoB,MAAAA,OAAAA,EAAIV,EAAEX,GAC/BW,KAAAA,OAAAA,OAAAA,EAAEE,EAAMF,MAAAA,OAAAA,EAAEG,EAAMH,MAAAA,OAAAA,EAAEV,EAH3B,MA+ZwC,KAAKqP,KAhahDG,IAAU9O,IA3TF,CAAA,IAAA,YA8tBb,MAAA,WACW,OAAA,KAAK4O,OAAS7O,EAAU,KAAK4O,MAAQ,KAAKA,OA/tBxC,CAAA,IAAA,YAkuBb,MAAA,WACW,OAAA,KAAKC,OAjTXG,SAAU/O,GACX,GAACA,EAAD,CAGEX,IAAAA,EAAIiC,EAAQtB,GACZO,EAAIlB,EAAE,GACN0B,EAAIJ,EAAItB,EAAE,IACViB,EAAIK,EAAItB,EAAE,IACTW,OAAAA,EAAEX,EAAI,IACCkB,QAAAA,OAAAA,EAAMQ,MAAAA,OAAAA,EAAOT,OAAAA,OAAAA,EAAOI,OAAAA,OAAAA,EAAIV,EAAEX,GAC3BkB,KAAAA,OAAAA,OAAAA,EAAMQ,MAAAA,OAAAA,EAAOT,OAAAA,OAAAA,EAF1B,OAySyByO,CAAU,KAAKJ,MAAQ,KAAKA,OAnuBxC,CAAA,IAAA,MAsuBb,MAAA,SAAIK,EAAOC,GAEHD,GAAAA,EAAO,CACDE,IAEFC,EAFED,EAFC,KAEO7N,IACR+N,EAAKJ,EAAM3N,IAEXgO,EAAIJ,IAAWE,EAAK,GAAMF,EAC1B7N,EAAI,EAAIiO,EAAI,EACZhQ,EAAI6P,EAAG7P,EAAI+P,EAAG/P,EACdiQ,IAAOlO,EAAI/B,IAAO,EAAI+B,GAAKA,EAAI/B,IAAM,EAAI+B,EAAI/B,IAAM,GAAK,EAC9D8P,EAAK,EAAIG,EACTJ,EAAGhP,EAAI,IAAOoP,EAAKJ,EAAGhP,EAAIiP,EAAKC,EAAGlP,EAAI,GACtCgP,EAAG/O,EAAI,IAAOmP,EAAKJ,EAAG/O,EAAIgP,EAAKC,EAAGjP,EAAI,GACtC+O,EAAG5P,EAAI,IAAOgQ,EAAKJ,EAAG5P,EAAI6P,EAAKC,EAAG9P,EAAI,GACtC4P,EAAG7P,EAAIgQ,EAAIH,EAAG7P,GAAK,EAAIgQ,GAAKD,EAAG/P,EAbxB,KAcJgC,IAAM6N,EAENrS,OAhBI,OAvuBF,CAAA,IAAA,QA0vBb,MAAA,WACW,OAAA,IAAI2R,EAAM,KAAKnN,OA3vBb,CAAA,IAAA,QA8vBb,MAAA,SAAMhC,GAEK,OADFsP,KAAAA,KAAKtP,EAAIoB,EAAIpB,GACX,OAhwBE,CAAA,IAAA,UAmwBb,MAAA,SAAQyO,GAGG,OAFK,KAAKa,KACbtP,GAAK,EAAIyO,EACN,OAtwBE,CAAA,IAAA,YAywBb,MAAA,WACUzM,IAAAA,EAAM,KAAKsN,KACXY,EAAMnP,EAAc,GAARiB,EAAInB,EAAkB,IAARmB,EAAIlB,EAAmB,IAARkB,EAAI/B,GAE5C,OADP+B,EAAInB,EAAImB,EAAIlB,EAAIkB,EAAI/B,EAAIiQ,EACjB,OA7wBE,CAAA,IAAA,UAgxBb,MAAA,SAAQzB,GAGG,OAFK,KAAKa,KACbtP,GAAK,EAAIyO,EACN,OAnxBE,CAAA,IAAA,SAsxBb,MAAA,WACU9N,IAAAA,EAAI,KAAK2O,KAIR,OAHP3O,EAAEE,EAAI,IAAMF,EAAEE,EACdF,EAAEG,EAAI,IAAMH,EAAEG,EACdH,EAAEV,EAAI,IAAMU,EAAEV,EACP,OA3xBE,CAAA,IAAA,UA8xBb,MAAA,SAAQwO,GAEG,OADPD,EAAO,KAAKc,KAAM,EAAGb,GACd,OAhyBE,CAAA,IAAA,SAmyBb,MAAA,SAAOA,GAEI,OADPD,EAAO,KAAKc,KAAM,GAAIb,GACf,OAryBE,CAAA,IAAA,WAwyBb,MAAA,SAASA,GAEE,OADPD,EAAO,KAAKc,KAAM,EAAGb,GACd,OA1yBE,CAAA,IAAA,aA6yBb,MAAA,SAAWA,GAEA,OADPD,EAAO,KAAKc,KAAM,GAAIb,GACf,OA/yBE,CAAA,IAAA,SAkzBb,MAAA,SAAO0B,GAEI,OA3YNC,SAAOzP,EAAGwP,GACXjP,IAAAA,EAAIe,EAAQtB,GAChBO,EAAE,GAAKoB,EAAIpB,EAAE,GAAKiP,GAClBjP,EAAImB,EAAQnB,GACZP,EAAEE,EAAIK,EAAE,GACRP,EAAEG,EAAII,EAAE,GACRP,EAAEV,EAAIiB,EAAE,GAoYJkP,CAAO,KAAKd,KAAMa,GACX,SApzBE,EAAA,GAwzBRE,SAAAA,EAAUtB,GACR,OAAA,IAAII,EAAMJ,GAGfuB,IAAAA,EAAsB,SAACC,GAAUA,OAAAA,aAAiBC,gBAAkBD,aAAiBE,eAElFd,SAAAA,EAAMY,GACJD,OAAAA,EAAoBC,GAASA,EAAQF,EAAUE,GAGjDG,SAAAA,EAAcH,GACZD,OAAAA,EAAoBC,GACrBA,EACAF,EAAUE,GAAOI,SAAS,IAAKC,OAAO,IAAKlQ,YAG5CmQ,SAAAA,MAGHC,IACEC,GADFD,IACEC,GAAK,EACF,WACIA,OAAAA,OAINC,SAAAA,GAAcT,GACZA,OAAAA,MAAAA,EAGFnO,SAAAA,GAAQmO,GACTtV,GAAAA,MAAMmH,SAAWnH,MAAMmH,QAAQmO,GACxB,OAAA,EAELxT,IAAAA,EAAOmR,OAAOhT,UAAU+V,SAAS7V,KAAKmV,GACxCxT,MAAsB,YAAtBA,EAAKmU,OAAO,EAAG,IAAwC,WAApBnU,EAAKmU,QAAQ,GAM/CC,SAAAA,GAASZ,GACPA,OAAU,OAAVA,GAA4D,oBAA1CrC,OAAOhT,UAAU+V,SAAS7V,KAAKmV,GAGtDa,IAAAA,GAAiB,SAACb,GAAU,OAAkB,iBAAVA,GAAsBA,aAAiBc,SAAWC,UAAUf,IAE7FgB,SAAAA,GAAgBhB,EAAOiB,GACrBJ,OAAAA,GAAeb,GAASA,EAAQiB,EAGlCC,SAAAA,GAAelB,EAAOiB,GACpB,YAAiB,IAAVjB,EAAwBiB,EAAejB,EAGnDmB,IAAAA,GAAe,SAACnB,EAAOoB,GACzB,MAAiB,iBAAVpB,GAAsBA,EAAMqB,SAAS,KACxCC,WAAWtB,GAAS,IAClBA,EAAQoB,GACZG,GAAc,SAACvB,EAAOoB,GACxB,MAAiB,iBAAVpB,GAAsBA,EAAMqB,SAAS,KACxCC,WAAWtB,GAAS,IAAMoB,GACvBpB,GAEF9V,SAAAA,GAASG,EAAII,EAAMH,GACpBD,GAAAA,GAAyB,mBAAZA,EAAGQ,KACTR,OAAAA,EAAGW,MAAMV,EAASG,GAIxB+W,SAAAA,GAAKC,EAAUpX,EAAIC,EAASoX,GAC7BhU,IAAAA,EAAGoR,EAAKpB,EACR7L,GAAAA,GAAQ4P,GAEJC,GADJ5C,EAAM2C,EAAShU,OACXiU,EACKhU,IAAAA,EAAIoR,EAAM,EAAGpR,GAAK,EAAGA,IACtBrD,EAAGQ,KAAKP,EAASmX,EAAS/T,GAAIA,QAG7BA,IAAAA,EAAI,EAAGA,EAAIoR,EAAKpR,IACjBrD,EAAGQ,KAAKP,EAASmX,EAAS/T,GAAIA,QAGnC,GAAIkT,GAASa,GAGX/T,IADLoR,GADApB,EAAOC,OAAOD,KAAK+D,IACRhU,OACNC,EAAI,EAAGA,EAAIoR,EAAKpR,IACjBrD,EAAGQ,KAAKP,EAASmX,EAAS/D,EAAKhQ,IAAKgQ,EAAKhQ,IAK5CiU,SAAAA,GAAeC,EAAIC,GACpBnU,IAAAA,EAAGoU,EAAMC,EAAIC,EACb,IAACJ,IAAOC,GAAMD,EAAGnU,SAAWoU,EAAGpU,OACxB,OAAA,EAENC,IAAAA,EAAI,EAAGoU,EAAOF,EAAGnU,OAAQC,EAAIoU,IAAQpU,EAGlCqU,GAFJA,EAAKH,EAAGlU,GACRsU,EAAKH,EAAGnU,GACJqU,EAAGE,eAAiBD,EAAGC,cAAgBF,EAAGG,QAAUF,EAAGE,MAChD,OAAA,EAGR,OAAA,EAGFC,SAAAA,GAAMC,GACPvQ,GAAAA,GAAQuQ,GACDA,OAAAA,EAAOlT,IAAIiT,IAElBvB,GAAAA,GAASwB,GAAS,CAKX/Q,IAJDgR,IAAAA,EAAS1E,OAAO2E,OAAO,MACvB5E,EAAOC,OAAOD,KAAK0E,GACnBG,EAAO7E,EAAKjQ,OACd4D,EAAI,EACDA,EAAIkR,IAAQlR,EACfgR,EAAO3E,EAAKrM,IAAM8Q,GAAMC,EAAO1E,EAAKrM,KAEjCgR,OAAAA,EAEJD,OAAAA,EAGFI,SAAAA,GAAWC,GACT,OAA4D,IAA5D,CAAC,YAAa,YAAa,eAAeC,QAAQD,GAGpDE,SAAAA,GAAQF,EAAKJ,EAAQD,EAAQQ,GAC9B,GAACJ,GAAWC,GAAZ,CAGEI,IAAAA,EAAOR,EAAOI,GACdK,EAAOV,EAAOK,GAChB7B,GAASiC,IAASjC,GAASkC,GAC3BC,GAAMF,EAAMC,EAAMF,GAElBP,EAAOI,GAAON,GAAMW,IAInBC,SAAAA,GAAMV,EAAQD,EAAQQ,GACrBI,IAAAA,EAAUnR,GAAQuQ,GAAUA,EAAS,CAACA,GACtCN,EAAOkB,EAAQvV,OACjB,IAACmT,GAASyB,GACHA,OAAAA,EAIN,IADCY,IAAAA,GADNL,EAAUA,GAAW,IACEK,QAAUN,GACxBjV,EAAI,EAAGA,EAAIoU,IAAQpU,EAEpB,GAACkT,GADLwB,EAASY,EAAQtV,IAKZ,IADCgQ,IAAAA,EAAOC,OAAOD,KAAK0E,GAChB/Q,EAAI,EAAGkR,EAAO7E,EAAKjQ,OAAQ4D,EAAIkR,IAAQlR,EAC5C4R,EAAOvF,EAAKrM,GAAIgR,EAAQD,EAAQQ,GAGjCP,OAAAA,EAGFa,SAAAA,GAAQb,EAAQD,GACdW,OAAAA,GAAMV,EAAQD,EAAQ,CAACa,OAAQE,KAGjCA,SAAAA,GAAUV,EAAKJ,EAAQD,GACxB,GAACI,GAAWC,GAAZ,CAGEI,IAAAA,EAAOR,EAAOI,GACdK,EAAOV,EAAOK,GAChB7B,GAASiC,IAASjC,GAASkC,GAC3BI,GAAQL,EAAMC,GACNnF,OAAOhT,UAAUyY,eAAevY,KAAKwX,EAAQI,KACrDJ,EAAOI,GAAON,GAAMW,KAWtBO,IAAAA,GAAc,GACdC,GAAM,IAEHC,SAAAA,GAAmBd,EAAKhX,GACvB+X,IAAAA,EAAMf,EAAIC,QAAQY,GAAK7X,GACtB+X,OAAS,IAATA,EAAaf,EAAIhV,OAAS+V,EAG5BC,SAAAA,GAAiBxE,EAAKwD,GACvBA,GAAAA,IAAQY,GACDpE,OAAAA,EAIJA,IAFHyE,IAAAA,EAAM,EACNF,EAAMD,GAAmBd,EAAKiB,GAC3BzE,GAAOuE,EAAME,GAChBzE,EAAMA,EAAIwD,EAAI9B,OAAO+C,EAAKF,EAAME,IAEhCF,EAAMD,GAAmBd,EADzBiB,EAAMF,EAAM,GAGTvE,OAAAA,EAGF0E,SAAAA,GAAY1R,GACVA,OAAAA,EAAIyM,OAAO,GAAGkF,cAAgB3R,EAAIrH,MAAM,GAG7CiZ,IAAAA,GAAU,SAAC7D,GAAU,YAAiB,IAAVA,GAC5B8D,GAAa,SAAC9D,GAAU,MAAiB,mBAAVA,GAE/B+D,GAAYpG,OAAO2E,OAAO,MAC1B0B,GAAcrG,OAAO2E,OAAO,MAEzB2B,SAAAA,GAAWC,EAAMzB,GAClB,IAACA,EACMyB,OAAAA,EAGN,IADCxG,IAAAA,EAAO+E,EAAI0B,MAAM,KACdzW,EAAI,EAAG0D,EAAIsM,EAAKjQ,OAAQC,EAAI0D,IAAK1D,EAAG,CACnC2D,IAAAA,EAAIqM,EAAKhQ,GACfwW,EAAOA,EAAK7S,KAAO6S,EAAK7S,GAAKsM,OAAO2E,OAAO,OAExC4B,OAAAA,EAGF5V,SAAAA,GAAI8V,EAAMC,EAAOC,GAClB,MAAiB,iBAAVD,EACAtB,GAAMkB,GAAWG,EAAMC,GAAQC,GAEnCvB,GAAMkB,GAAWG,EAAM,IAAKC,GAGjCE,IAuFFC,GAAW,IA5nCE,WAsiCDC,SAAAA,EAAAA,GAAc,EAAA,KAAA,GACjBC,KAAAA,eAAYtY,EACZuY,KAAAA,gBAAkB,kBAClBC,KAAAA,YAAc,kBACdxF,KAAAA,MAAQ,OACRyF,KAAAA,SAAW,GACXC,KAAAA,iBAAmB,SAACC,GAAYA,OAAAA,EAAQ1Y,MAAM2Y,SAASC,uBACvDC,KAAAA,SAAW,GACXC,KAAAA,OAAS,CACV,YACA,WACA,QACA,aACA,aAECC,KAAAA,KAAO,CACRC,OAAQ,qDACRC,KAAM,GACNC,MAAO,SACPC,WAAY,IACZnG,OAAQ,MAEPoG,KAAAA,MAAQ,GACRC,KAAAA,qBAAuB,SAACC,EAAK/C,GAAYzC,OAAAA,EAAcyC,EAAQ+B,kBAC/DiB,KAAAA,iBAAmB,SAACD,EAAK/C,GAAYzC,OAAAA,EAAcyC,EAAQgC,cAC3DiB,KAAAA,WAAa,SAACF,EAAK/C,GAAYzC,OAAAA,EAAcyC,EAAQxD,QACrD0G,KAAAA,UAAY,IACZC,KAAAA,YAAc,CACfC,KAAM,UACNC,WAAW,GAEVC,KAAAA,qBAAsB,EACtBC,KAAAA,QAAU,KACVC,KAAAA,QAAU,KACVC,KAAAA,SAAU,EACVC,KAAAA,QAAU,GACVC,KAAAA,YAAa,EACbC,KAAAA,WAAQpa,EACRqa,KAAAA,OAAS,GACTC,KAAAA,UAAW,EACXC,KAAAA,SAASlC,GA9kCL,OAAA,EAAA,EAAA,CAAA,CAAA,IAAA,MAilCb,MAAA,SAAIJ,EAAOC,GACAhW,OAAAA,GAAI,KAAM+V,EAAOC,KAllCf,CAAA,IAAA,MAqlCb,MAAA,SAAID,GACOJ,OAAAA,GAAW,KAAMI,KAtlCf,CAAA,IAAA,WAylCb,MAAA,SAASA,EAAOC,GACLhW,OAAAA,GAAI0V,GAAaK,EAAOC,KA1lCtB,CAAA,IAAA,WA6lCb,MAAA,SAASD,EAAOC,GACLhW,OAAAA,GAAIyV,GAAWM,EAAOC,KA9lCpB,CAAA,IAAA,QAimCb,MAAA,SAAMD,EAAOuC,EAAMC,EAAaC,GAAY,IAAA,EAClCC,EAAc9C,GAAW,KAAMI,GAC/B2C,EAAoB/C,GAAW,KAAM4C,GACrCI,EAAc,IAAML,EAC1BjJ,OAAOuJ,iBAAiBH,GACnBE,EAAAA,EAAAA,GAAAA,EAAc,CACXjH,MAAO+G,EAAYH,GACnBO,UAAU,IAEbP,EAAAA,EAAAA,EAAO,CACJQ,YAAY,EACZjZ,IAAM,WACIkZ,IAAAA,EAAQ,KAAKJ,GACb5E,EAAS2E,EAAkBF,GAC7BlG,OAAAA,GAASyG,GACF1J,OAAOW,OAAO,GAAI+D,EAAQgF,GAE9BnG,GAAemG,EAAOhF,IAEjC/T,IAAI0R,SAAAA,GACKiH,KAAAA,GAAejH,KAhBhC,QArmCS,EAAA,GA4nCF,CAAa,CACxBsH,YAAa,SAACV,GAAS,OAACA,EAAKW,WAAW,OACxCC,WAAY,SAACZ,GAASA,MAAS,WAATA,GACtBnB,MAAO,CACHgC,UAAW,eAEf1B,YAAa,CACTuB,aAAa,EACbE,YAAY,KAIdE,GAAK3a,KAAK2a,GACVC,GAAM,EAAID,GACVE,GAAQD,GAAMD,GACdG,GAAW/G,OAAOgH,kBAClBC,GAAcL,GAAK,IACnBM,GAAUN,GAAK,EACfO,GAAaP,GAAK,EAClBQ,GAAqB,EAALR,GAAS,EACzBS,GAAQpb,KAAKob,MACbC,GAAOrb,KAAKqb,KAETC,SAAAA,GAAQ1W,GACP2W,IAAAA,EAAYvb,KAAKwb,IAAI,GAAIxb,KAAKyb,MAAML,GAAMxW,KAC1C8W,EAAW9W,EAAQ2W,EAElBI,OADcD,GAAY,EAAI,EAAIA,GAAY,EAAI,EAAIA,GAAY,EAAI,EAAI,IAC3DH,EAGjBK,SAAAA,GAAW3I,GACV4I,IAEFlb,EAFEkb,EAAS,GACTC,EAAO9b,KAAK8b,KAAK7I,GAElBtS,IAAAA,EAAI,EAAGA,EAAImb,EAAMnb,IACdsS,EAAQtS,GAAM,IACdkb,EAAOla,KAAKhB,GACZkb,EAAOla,KAAKsR,EAAQtS,IAOrBkb,OAJHC,KAAiB,EAAPA,IACVD,EAAOla,KAAKma,GAEhBD,EAAOE,KAAK,SAACrZ,EAAGC,GAAMD,OAAAA,EAAIC,IAAG1B,MACtB4a,EAGFG,SAAAA,GAAS3X,GACP,OAAC4X,MAAM1H,WAAWlQ,KAAO2P,SAAS3P,GAGpC6X,SAAAA,GAAavW,EAAGwW,EAAGC,GACjBpc,OAAAA,KAAKqc,IAAI1W,EAAIwW,GAAKC,EAGpBE,SAAAA,GAAY3W,EAAGyW,GACdG,IAAAA,EAAUvc,KAAKyD,MAAMkC,GAClB4W,OAAAA,EAAUH,GAAYzW,GAAQ4W,EAAUH,GAAYzW,EAGxD6W,SAAAA,GAAmBC,EAAOnH,EAAQoH,GACnC/b,IAAAA,EAAGoU,EAAM9B,EACRtS,IAAAA,EAAI,EAAGoU,EAAO0H,EAAM/b,OAAQC,EAAIoU,EAAMpU,IACvCsS,EAAQwJ,EAAM9b,GAAG+b,GACZT,MAAMhJ,KACPqC,EAAOrV,IAAMD,KAAKC,IAAIqV,EAAOrV,IAAKgT,GAClCqC,EAAOvT,IAAM/B,KAAK+B,IAAIuT,EAAOvT,IAAKkR,IAKrC0J,SAAAA,GAAUC,GACRA,OAAAA,GAAWjC,GAAK,KAGlBkC,SAAAA,GAAUC,GACRA,OAAAA,GAAW,IAAMnC,IAGnBoC,SAAAA,GAAepX,GAChB,GAACmO,GAAenO,GAAhB,CAKG3F,IAFH8C,IAAAA,EAAI,EACJ4P,EAAI,EACD1S,KAAKyD,MAAMkC,EAAI7C,GAAKA,IAAM6C,GAC7B7C,GAAK,GACL4P,IAEGA,OAAAA,GAGFsK,SAAAA,GAAkBC,EAAaC,GAC9BC,IAAAA,EAAsBD,EAAWvX,EAAIsX,EAAYtX,EACjDyX,EAAsBF,EAAWf,EAAIc,EAAYd,EACjDkB,EAA2Brd,KAAK8b,KAAKqB,EAAsBA,EAAsBC,EAAsBA,GACzGE,EAAQtd,KAAKud,MAAMH,EAAqBD,GAIrC,OAHHG,GAAU,GAAM3C,KAChB2C,GAAS1C,IAEN,CACH0C,MAAAA,EACAE,SAAUH,GAITI,SAAAA,GAAsBC,EAAKC,GACzB3d,OAAAA,KAAK8b,KAAK9b,KAAKwb,IAAImC,EAAIhY,EAAI+X,EAAI/X,EAAG,GAAK3F,KAAKwb,IAAImC,EAAIxB,EAAIuB,EAAIvB,EAAG,IAGjEyB,SAAAA,GAAWlb,EAAGC,GACZ,OAACD,EAAIC,EAAIkY,IAASD,GAAMD,GAG1BkD,SAAAA,GAAgBnb,GACd,OAACA,EAAIkY,GAAMA,IAAOA,GAGpBkD,SAAAA,GAAcR,EAAO5e,EAAOC,GAC3B+D,IAAAA,EAAImb,GAAgBP,GACpBlZ,EAAIyZ,GAAgBnf,GACpBoE,EAAI+a,GAAgBlf,GACpBof,EAAeF,GAAgBzZ,EAAI1B,GACnCsb,EAAaH,GAAgB/a,EAAIJ,GACjCub,EAAeJ,GAAgBnb,EAAI0B,GACnC8Z,EAAaL,GAAgBnb,EAAII,GAChCJ,OAAAA,IAAM0B,GAAK1B,IAAMI,GAAMib,EAAeC,GAAcC,EAAeC,EAGrEC,SAAAA,GAAYlL,EAAOhT,EAAK8B,GACtB/B,OAAAA,KAAK+B,IAAI9B,EAAKD,KAAKC,IAAI8B,EAAKkR,IAG9BmL,SAAAA,GAAYnL,GACVkL,OAAAA,GAAYlL,GAAQ,MAAO,OAG7BoL,SAAAA,GAAahG,GACd,OAACA,GAAQ3E,GAAc2E,EAAKE,OAAS7E,GAAc2E,EAAKC,QACjD,MAEHD,EAAKG,MAAQH,EAAKG,MAAQ,IAAM,KACjCH,EAAK/F,OAAS+F,EAAK/F,OAAS,IAAM,IACnC+F,EAAKE,KAAO,MACZF,EAAKC,OAGNgG,SAAAA,GAAa1F,EAAK2F,EAAMC,EAAIC,EAASC,GACtCC,IAAAA,EAAYJ,EAAKG,GAQdD,OAPFE,IACDA,EAAYJ,EAAKG,GAAU9F,EAAIgG,YAAYF,GAAQG,MACnDL,EAAG7c,KAAK+c,IAERC,EAAYF,IACZA,EAAUE,GAEPF,EAGFK,SAAAA,GAAalG,EAAKP,EAAM0G,EAAeC,GAExCT,IAAAA,GADJS,EAAQA,GAAS,IACAT,KAAOS,EAAMT,MAAQ,GAClCC,EAAKQ,EAAMC,eAAiBD,EAAMC,gBAAkB,GACpDD,EAAM3G,OAASA,IACfkG,EAAOS,EAAMT,KAAO,GACpBC,EAAKQ,EAAMC,eAAiB,GAC5BD,EAAM3G,KAAOA,GAEjBO,EAAIsG,OACJtG,EAAIP,KAAOA,EACPoG,IAEA9d,EAAG6P,EAAG2O,EAAMC,EAAOC,EAFnBZ,EAAU,EACR1J,EAAOgK,EAAcre,OAEtBC,IAAAA,EAAI,EAAGA,EAAIoU,EAAMpU,IAEdye,GAAAA,OADJA,EAAQL,EAAcpe,MAC0C,IAAnBmE,GAAQsa,GACjDX,EAAUH,GAAa1F,EAAK2F,EAAMC,EAAIC,EAASW,QAC5C,GAAIta,GAAQsa,GACV5O,IAAAA,EAAI,EAAG2O,EAAOC,EAAM1e,OAAQ8P,EAAI2O,EAAM3O,IAEnC6O,OADJA,EAAcD,EAAM5O,KACsC1L,GAAQua,KAC9DZ,EAAUH,GAAa1F,EAAK2F,EAAMC,EAAIC,EAASY,IAK/DzG,EAAI0G,UACEC,IAAAA,EAAQf,EAAG9d,OAAS,EACtB6e,GAAAA,EAAQR,EAAcre,OAAQ,CACzBC,IAAAA,EAAI,EAAGA,EAAI4e,EAAO5e,WACZ4d,EAAKC,EAAG7d,IAEnB6d,EAAGgB,OAAO,EAAGD,GAEVd,OAAAA,EAGFgB,SAAAA,GAAYngB,EAAOogB,EAAOb,GACzB9G,IAAAA,EAAmBzY,EAAMqgB,wBACzBC,EAAsB,IAAVf,EAAc7e,KAAK+B,IAAI8c,EAAQ,EAAG,IAAO,EACpD7e,OAAAA,KAAKyD,OAAOic,EAAQE,GAAa7H,GAAoBA,EAAmB6H,EAG1EC,SAAAA,GAAYC,EAAQlH,IACzBA,EAAMA,GAAOkH,EAAOC,WAAW,OAC3Bb,OACJtG,EAAIoH,iBACJpH,EAAIqH,UAAU,EAAG,EAAGH,EAAOjB,MAAOiB,EAAOI,QACzCtH,EAAI0G,UAGCa,SAAAA,GAAUvH,EAAK/C,EAASlQ,EAAGwW,GAC5B1c,IAAAA,EAAM2gB,EAASC,EAAS9H,EAAM+H,EAC5B9H,EAAQ3C,EAAQ0K,WAChBC,EAAW3K,EAAQ2K,SACnBC,EAAS5K,EAAQ4K,OACnBC,GAAOF,GAAY,GAAKxF,GACxBxC,GAAAA,GAA0B,WAAjB,EAAOA,KAEH,+BADb/Y,EAAO+Y,EAAM7E,aACwC,+BAATlU,GAMxC,OALAmZ,EAAIsG,OACJtG,EAAI+H,UAAUhb,EAAGwW,GACjBvD,EAAI9F,OAAO4N,GACX9H,EAAIgI,UAAUpI,GAAQA,EAAMqG,MAAQ,GAAIrG,EAAM0H,OAAS,EAAG1H,EAAMqG,MAAOrG,EAAM0H,aAC7EtH,EAAI0G,UAIRrD,KAAAA,MAAMwE,IAAWA,GAAU,GAA3BxE,CAIIzD,OADRI,EAAIiI,YACIrI,GACJ,QACII,EAAIkI,IAAInb,EAAGwW,EAAGsE,EAAQ,EAAG7F,IACzBhC,EAAImI,YACJ,MACC,IAAA,WACDnI,EAAIoI,OAAOrb,EAAI3F,KAAKihB,IAAIP,GAAOD,EAAQtE,EAAInc,KAAKkhB,IAAIR,GAAOD,GAC3DC,GAAOvF,GACPvC,EAAIuI,OAAOxb,EAAI3F,KAAKihB,IAAIP,GAAOD,EAAQtE,EAAInc,KAAKkhB,IAAIR,GAAOD,GAC3DC,GAAOvF,GACPvC,EAAIuI,OAAOxb,EAAI3F,KAAKihB,IAAIP,GAAOD,EAAQtE,EAAInc,KAAKkhB,IAAIR,GAAOD,GAC3D7H,EAAImI,YACJ,MACC,IAAA,cAEDxI,EAAOkI,GADPH,EAAwB,KAATG,GAEfL,EAAUpgB,KAAKkhB,IAAIR,EAAMxF,IAAc3C,EACvC8H,EAAUrgB,KAAKihB,IAAIP,EAAMxF,IAAc3C,EACvCK,EAAIkI,IAAInb,EAAIya,EAASjE,EAAIkE,EAASC,EAAcI,EAAM/F,GAAI+F,EAAMzF,IAChErC,EAAIkI,IAAInb,EAAI0a,EAASlE,EAAIiE,EAASE,EAAcI,EAAMzF,GAASyF,GAC/D9H,EAAIkI,IAAInb,EAAIya,EAASjE,EAAIkE,EAASC,EAAcI,EAAKA,EAAMzF,IAC3DrC,EAAIkI,IAAInb,EAAI0a,EAASlE,EAAIiE,EAASE,EAAcI,EAAMzF,GAASyF,EAAM/F,IACrE/B,EAAImI,YACJ,MACC,IAAA,OACG,IAACP,EAAU,CACXjI,EAAOvY,KAAKohB,QAAUX,EACtB7H,EAAIyI,KAAK1b,EAAI4S,EAAM4D,EAAI5D,EAAM,EAAIA,EAAM,EAAIA,GAC3C,MAEJmI,GAAOxF,GACN,IAAA,UACDkF,EAAUpgB,KAAKkhB,IAAIR,GAAOD,EAC1BJ,EAAUrgB,KAAKihB,IAAIP,GAAOD,EAC1B7H,EAAIoI,OAAOrb,EAAIya,EAASjE,EAAIkE,GAC5BzH,EAAIuI,OAAOxb,EAAI0a,EAASlE,EAAIiE,GAC5BxH,EAAIuI,OAAOxb,EAAIya,EAASjE,EAAIkE,GAC5BzH,EAAIuI,OAAOxb,EAAI0a,EAASlE,EAAIiE,GAC5BxH,EAAImI,YACJ,MACC,IAAA,WACDL,GAAOxF,GACN,IAAA,QACDkF,EAAUpgB,KAAKkhB,IAAIR,GAAOD,EAC1BJ,EAAUrgB,KAAKihB,IAAIP,GAAOD,EAC1B7H,EAAIoI,OAAOrb,EAAIya,EAASjE,EAAIkE,GAC5BzH,EAAIuI,OAAOxb,EAAIya,EAASjE,EAAIkE,GAC5BzH,EAAIoI,OAAOrb,EAAI0a,EAASlE,EAAIiE,GAC5BxH,EAAIuI,OAAOxb,EAAI0a,EAASlE,EAAIiE,GAC5B,MACC,IAAA,OACDA,EAAUpgB,KAAKkhB,IAAIR,GAAOD,EAC1BJ,EAAUrgB,KAAKihB,IAAIP,GAAOD,EAC1B7H,EAAIoI,OAAOrb,EAAIya,EAASjE,EAAIkE,GAC5BzH,EAAIuI,OAAOxb,EAAIya,EAASjE,EAAIkE,GAC5BzH,EAAIoI,OAAOrb,EAAI0a,EAASlE,EAAIiE,GAC5BxH,EAAIuI,OAAOxb,EAAI0a,EAASlE,EAAIiE,GAC5BM,GAAOxF,GACPkF,EAAUpgB,KAAKkhB,IAAIR,GAAOD,EAC1BJ,EAAUrgB,KAAKihB,IAAIP,GAAOD,EAC1B7H,EAAIoI,OAAOrb,EAAIya,EAASjE,EAAIkE,GAC5BzH,EAAIuI,OAAOxb,EAAIya,EAASjE,EAAIkE,GAC5BzH,EAAIoI,OAAOrb,EAAI0a,EAASlE,EAAIiE,GAC5BxH,EAAIuI,OAAOxb,EAAI0a,EAASlE,EAAIiE,GAC5B,MACC,IAAA,OACDA,EAAUpgB,KAAKkhB,IAAIR,GAAOD,EAC1BJ,EAAUrgB,KAAKihB,IAAIP,GAAOD,EAC1B7H,EAAIoI,OAAOrb,EAAIya,EAASjE,EAAIkE,GAC5BzH,EAAIuI,OAAOxb,EAAIya,EAASjE,EAAIkE,GAC5B,MACC,IAAA,OACDzH,EAAIoI,OAAOrb,EAAGwW,GACdvD,EAAIuI,OAAOxb,EAAI3F,KAAKkhB,IAAIR,GAAOD,EAAQtE,EAAInc,KAAKihB,IAAIP,GAAOD,GAGnE7H,EAAI0I,OACAzL,EAAQ0L,YAAc,GACtB3I,EAAI4I,UAIHC,SAAAA,GAAeC,EAAOC,EAAMC,GAE1BF,OADPE,EAASA,GAAU,GACZF,GAASA,EAAM/b,EAAIgc,EAAK9iB,KAAO+iB,GAAUF,EAAM/b,EAAIgc,EAAK7iB,MAAQ8iB,GACnEF,EAAMvF,EAAIwF,EAAKE,IAAMD,GAAUF,EAAMvF,EAAIwF,EAAKG,OAASF,EAGtDG,SAAAA,GAASnJ,EAAK+I,GACnB/I,EAAIsG,OACJtG,EAAIiI,YACJjI,EAAIyI,KAAKM,EAAK9iB,KAAM8iB,EAAKE,IAAKF,EAAK7iB,MAAQ6iB,EAAK9iB,KAAM8iB,EAAKG,OAASH,EAAKE,KACzEjJ,EAAIoJ,OAGCC,SAAAA,GAAWrJ,GAChBA,EAAI0G,UAGC4C,SAAAA,GAAetJ,EAAKuJ,EAAU7M,EAAQ8M,EAAMnJ,GAC7C,IAACkJ,EACMvJ,OAAAA,EAAIuI,OAAO7L,EAAO3P,EAAG2P,EAAO6G,GAEnClD,GAAS,WAATA,EAAmB,CACboJ,IAAAA,GAAYF,EAASxc,EAAI2P,EAAO3P,GAAK,EAC3CiT,EAAIuI,OAAOkB,EAAUF,EAAShG,GAC9BvD,EAAIuI,OAAOkB,EAAU/M,EAAO6G,OACZ,UAATlD,KAAuBmJ,EAC9BxJ,EAAIuI,OAAOgB,EAASxc,EAAG2P,EAAO6G,GAE9BvD,EAAIuI,OAAO7L,EAAO3P,EAAGwc,EAAShG,GAElCvD,EAAIuI,OAAO7L,EAAO3P,EAAG2P,EAAO6G,GAGvBmG,SAAAA,GAAe1J,EAAKuJ,EAAU7M,EAAQ8M,GACvC,IAACD,EACMvJ,OAAAA,EAAIuI,OAAO7L,EAAO3P,EAAG2P,EAAO6G,GAEvCvD,EAAI2J,cACAH,EAAOD,EAASK,KAAOL,EAASM,KAChCL,EAAOD,EAASO,KAAOP,EAASQ,KAChCP,EAAO9M,EAAOmN,KAAOnN,EAAOkN,KAC5BJ,EAAO9M,EAAOqN,KAAOrN,EAAOoN,KAC5BpN,EAAO3P,EACP2P,EAAO6G,GAGNyG,SAAAA,GAAWhK,EAAKiK,EAAMld,EAAGwW,EAAG9D,GAAMyK,IAGnCniB,EAAGoiB,EAHgCD,EAAO,UAAA,OAAA,QAAA,IAAA,UAAA,GAAA,UAAA,GAAA,GACxCE,EAAQle,GAAQ+d,GAAQA,EAAO,CAACA,GAChCrB,EAASsB,EAAKG,YAAc,GAA0B,KAArBH,EAAKI,YAmBvCviB,IAjBLiY,EAAIsG,OACA4D,EAAKK,aACLvK,EAAI+H,UAAUmC,EAAKK,YAAY,GAAIL,EAAKK,YAAY,IAEnDzP,GAAcoP,EAAKtC,WACpB5H,EAAI9F,OAAOgQ,EAAKtC,UAEpB5H,EAAIP,KAAOA,EAAKqG,OACZoE,EAAKzQ,QACLuG,EAAIwK,UAAYN,EAAKzQ,OAErByQ,EAAKO,YACLzK,EAAIyK,UAAYP,EAAKO,WAErBP,EAAKQ,eACL1K,EAAI0K,aAAeR,EAAKQ,cAEvB3iB,EAAI,EAAGA,EAAIqiB,EAAMtiB,SAAUC,EAAG,CAY3BmiB,GAXJC,EAAOC,EAAMriB,GACT6gB,IACIsB,EAAKI,cACLtK,EAAI2K,YAAcT,EAAKI,aAEtBxP,GAAcoP,EAAKG,eACpBrK,EAAI4K,UAAYV,EAAKG,aAEzBrK,EAAI6K,WAAWV,EAAMpd,EAAGwW,EAAG2G,EAAKY,WAEpC9K,EAAI+K,SAASZ,EAAMpd,EAAGwW,EAAG2G,EAAKY,UAC1BZ,EAAKc,eAAiBd,EAAKe,UAAW,CAChCC,IAAAA,EAAUlL,EAAIgG,YAAYmE,GAC1BlkB,EAAO8G,EAAIme,EAAQC,sBACnBjlB,EAAQ6G,EAAIme,EAAQE,uBACpBnC,EAAM1F,EAAI2H,EAAQG,wBAClBnC,EAAS3F,EAAI2H,EAAQI,yBACrBC,EAAcrB,EAAKc,eAAiB/B,EAAMC,GAAU,EAAIA,EAC9DlJ,EAAI2K,YAAc3K,EAAIwK,UACtBxK,EAAIiI,YACJjI,EAAI4K,UAAYV,EAAKsB,iBAAmB,EACxCxL,EAAIoI,OAAOniB,EAAMslB,GACjBvL,EAAIuI,OAAOriB,EAAOqlB,GAClBvL,EAAI4I,SAERrF,GAAK9D,EAAKI,WAEdG,EAAI0G,UAGC+E,SAAAA,GAAQC,EAAOrR,EAAOsR,GAC3BA,EAAMA,GAAQ,SAACpP,GAAUmP,OAAAA,EAAMnP,GAASlC,GAIjCuR,IAHHA,IAEAC,EAFAD,EAAKF,EAAM5jB,OAAS,EACpBgkB,EAAK,EAEFF,EAAKE,EAAK,GAETH,EADJE,EAAOC,EAAKF,GAAO,GAEfE,EAAKD,EAELD,EAAKC,EAGN,MAAA,CAACC,GAAAA,EAAIF,GAAAA,GAGVG,IAAAA,GAAe,SAACL,EAAO5O,EAAKzC,GAC9BoR,OAAAA,GAAQC,EAAOrR,EAAO,SAAAkC,GAASmP,OAAAA,EAAMnP,GAAOO,GAAOzC,KACjD2R,GAAgB,SAACN,EAAO5O,EAAKzC,GAC/BoR,OAAAA,GAAQC,EAAOrR,EAAO,SAAAkC,GAASmP,OAAAA,EAAMnP,GAAOO,IAAQzC,KAE/C4R,SAAAA,GAAetN,EAAQtX,EAAK8B,GAG1BrD,IAFHA,IAAAA,EAAQ,EACRC,EAAM4Y,EAAO7W,OACVhC,EAAQC,GAAO4Y,EAAO7Y,GAASuB,GAClCvB,IAEGC,KAAAA,EAAMD,GAAS6Y,EAAO5Y,EAAM,GAAKoD,GACpCpD,IAEGD,OAAAA,EAAQ,GAAKC,EAAM4Y,EAAO7W,OAC3B6W,EAAO1Z,MAAMa,EAAOC,GACpB4Y,EAGJuN,IAAAA,GAAc,CAAC,OAAQ,MAAO,QAAS,SAAU,WAE9CC,SAAAA,GAAkBtI,EAAOuI,GAC1BvI,EAAMwI,SACNxI,EAAMwI,SAAStlB,UAAUgC,KAAKqjB,IAGlCpU,OAAOsU,eAAezI,EAAO,WAAY,CACrC0I,cAAc,EACd9K,YAAY,EACZpH,MAAO,CACHtT,UAAW,CAACqlB,MAGpBF,GAAYhlB,QAAQ,SAAC4V,GACX0P,IAAAA,EAAS,UAAYxO,GAAYlB,GACjC2P,EAAO5I,EAAM/G,GACnB9E,OAAOsU,eAAezI,EAAO/G,EAAK,CAC9ByP,cAAc,EACd9K,YAAY,EACZpH,MAAe,WAANvV,IAAAA,IAAAA,EAAAA,UAAAA,OAAAA,EAAM,IAAA,MAAA,GAAA,EAAA,EAAA,EAAA,EAAA,IAANA,EAAM,GAAA,UAAA,GACL4nB,IAAAA,EAAMD,EAAKpnB,MAAM,KAAMP,GAMtB4nB,OALP7I,EAAMwI,SAAStlB,UAAUG,QAAQ,SAACylB,GACA,mBAAnBA,EAAOH,IACdG,EAAOH,GAAPG,MAAAA,EAAkB7nB,KAGnB4nB,QAMdE,SAAAA,GAAoB/I,EAAOuI,GAC1BS,IAAAA,EAAOhJ,EAAMwI,SACf,GAACQ,EAAD,CAGE9lB,IAAAA,EAAY8lB,EAAK9lB,UACjBwV,EAAQxV,EAAUgW,QAAQqP,IACjB,IAAX7P,GACAxV,EAAU6f,OAAOrK,EAAO,GAExBxV,EAAUe,OAAS,IAGvBokB,GAAYhlB,QAAQ,SAAC4V,UACV+G,EAAM/G,YAEV+G,EAAMwI,WAGRS,SAAAA,GAAajlB,GACZc,IACFZ,EAAGoU,EADDxT,EAAM,IAAIokB,IAEXhlB,IAAAA,EAAI,EAAGoU,EAAOtU,EAAMC,OAAQC,EAAIoU,IAAQpU,EACzCY,EAAIqkB,IAAInlB,EAAME,IAEdY,GAAAA,EAAIgX,OAASxD,EACNtU,OAAAA,EAELob,IAAAA,EAAS,GAIRA,OAHPta,EAAIzB,QAAQ,SAAAc,GACRib,EAAOla,KAAKf,KAETib,EAGFgK,SAAAA,GAAeC,GAChBC,IAAAA,EAASD,EAAQE,WAIdD,OAHHA,GAAgC,wBAAtBA,EAAOpS,aACjBoS,EAASA,EAAOE,MAEbF,EAGFG,SAAAA,GAAcC,EAAYhP,EAAMiP,GACjCC,IAAAA,EASGA,MARmB,iBAAfF,GACPE,EAAgBtV,SAASoV,EAAY,KACJ,IAA7BA,EAAWxQ,QAAQ,OACnB0Q,EAAgBA,EAAgB,IAAMlP,EAAK6O,WAAWI,KAG1DC,EAAgBF,EAEbE,EAGLC,IAAAA,GAAmB,SAACC,GAAYrpB,OAAAA,OAAOopB,iBAAiBC,EAAS,OAE9DC,SAAAA,GAASC,EAAI/J,GACX4J,OAAAA,GAAiBG,GAAIC,iBAAiBhK,GAG3CiK,IAAAA,GAAY,CAAC,MAAO,QAAS,SAAU,QAEpCC,SAAAA,GAAmBC,EAAQrO,EAAOsO,GACjCjL,IAAAA,EAAS,GACfiL,EAASA,EAAS,IAAMA,EAAS,GAC5B,IAAA,IAAInmB,EAAI,EAAGA,EAAI,EAAGA,IAAK,CAClBgW,IAAAA,EAAMgQ,GAAUhmB,GACtBkb,EAAOlF,GAAOpC,WAAWsS,EAAOrO,EAAQ,IAAM7B,EAAMmQ,KAAY,EAI7DjL,OAFPA,EAAOgD,MAAQhD,EAAOhd,KAAOgd,EAAO/c,MACpC+c,EAAOqE,OAASrE,EAAOgG,IAAMhG,EAAOiG,OAC7BjG,EAGLkL,IAAAA,GAAe,SAACphB,EAAGwW,EAAG7G,GAAW,OAAC3P,EAAI,GAAKwW,EAAI,MAAQ7G,IAAWA,EAAO0R,aAqBtEC,SAAAA,GAAsBC,EAAK5nB,GACzBwgB,IAAAA,EAAmCxgB,EAAnCwgB,OAAQH,EAA2BrgB,EAA3BqgB,wBACTnH,EAAQ8N,GAAiBxG,GACzBqH,EAAgC,eAApB3O,EAAM4O,UAClBC,EAAWT,GAAmBpO,EAAO,WACrC8O,EAAUV,GAAmBpO,EAAO,SAAU,SAChC+O,EAzBfA,SAAkBL,EAAKpH,GACtBhd,IAKF6C,EAAGwW,EALDrZ,EAAIokB,EAAIM,QAAUN,EAClBO,EAAU3kB,EAAE2kB,QACZpS,EAASoS,GAAWA,EAAQ/mB,OAAS+mB,EAAQ,GAAK3kB,EACjD4kB,EAAoBrS,EAApBqS,QAASC,EAAWtS,EAAXsS,QACZC,GAAM,EAENb,GAAAA,GAAaW,EAASC,EAAS7kB,EAAEwS,QACjC3P,EAAI+hB,EACJvL,EAAIwL,MACD,CACGtG,IAAAA,EAAOvB,EAAO+H,wBACpBliB,EAAI0P,EAAOyS,QAAUzG,EAAKxiB,KAC1Bsd,EAAI9G,EAAO0S,QAAU1G,EAAKQ,IAC1B+F,GAAM,EAEH,MAAA,CAACjiB,EAAAA,EAAGwW,EAAAA,EAAGyL,IAAAA,GASML,CAAkBL,EAAKpH,GAApCna,EAAAA,EAAAA,EAAGwW,EAAAA,EAAAA,EAAGyL,EAAAA,EAAAA,IACPxH,EAAUiH,EAASxoB,MAAQ+oB,GAAON,EAAQzoB,MAC1CwhB,EAAUgH,EAASxF,KAAO+F,GAAON,EAAQzF,KAC1ChD,EAAiBvf,EAAjBuf,MAAOqB,EAAU5gB,EAAV4gB,OAKL,OAJHiH,IACAtI,GAASwI,EAASxI,MAAQyI,EAAQzI,MAClCqB,GAAUmH,EAASnH,OAASoH,EAAQpH,QAEjC,CACHva,EAAG3F,KAAKyD,OAAOkC,EAAIya,GAAWvB,EAAQiB,EAAOjB,MAAQc,GACrDxD,EAAGnc,KAAKyD,OAAO0Y,EAAIkE,GAAWH,EAASJ,EAAOI,OAASP,IA8BzDqI,IAAAA,GAAS,SAAA3kB,GAAKrD,OAAAA,KAAKyD,MAAU,GAAJJ,GAAU,IAEhC4kB,SAAAA,GAAenI,EAAQoI,EAASC,EAAUC,GACzC5P,IAAAA,EAAQ8N,GAAiBxG,GACzBuI,EAAUzB,GAAmBpO,EAAO,UACpCkL,EAAWwC,GAAc1N,EAAMkL,SAAU5D,EAAQ,gBAAkBhF,GACnEwN,EAAYpC,GAAc1N,EAAM8P,UAAWxI,EAAQ,iBAAmBhF,GACtEyN,EAjCDC,SAAiB1I,EAAQjB,EAAOqB,GACjCwD,IAAAA,EAAU4E,EACVzJ,QAAUxf,IAAVwf,QAAkCxf,IAAX6gB,EAAsB,CACvCuI,IAAAA,EAAY5C,GAAe/F,GAC7B,GAAC2I,EAGE,CACGpH,IAAAA,EAAOoH,EAAUZ,wBACjBa,EAAiBpC,GAAiBmC,GAClCE,EAAkB/B,GAAmB8B,EAAgB,SAAU,SAC/DE,EAAmBhC,GAAmB8B,EAAgB,WAC5D7J,EAAQwC,EAAKxC,MAAQ+J,EAAiB/J,MAAQ8J,EAAgB9J,MAC9DqB,EAASmB,EAAKnB,OAAS0I,EAAiB1I,OAASyI,EAAgBzI,OACjEwD,EAAWwC,GAAcwC,EAAehF,SAAU+E,EAAW,eAC7DH,EAAYpC,GAAcwC,EAAeJ,UAAWG,EAAW,qBAV/D5J,EAAQiB,EAAO+I,YACf3I,EAASJ,EAAOgJ,aAYjB,MAAA,CACHjK,MAAAA,EACAqB,OAAAA,EACAwD,SAAUA,GAAY5I,GACtBwN,UAAWA,GAAaxN,IAWN0N,CAAiB1I,EAAQoI,EAASC,GACnDtJ,EAAiB0J,EAAjB1J,MAAOqB,EAAUqI,EAAVrI,OACR1H,GAAoB,gBAApBA,EAAM4O,UAA6B,CAC7BE,IAAAA,EAAUV,GAAmBpO,EAAO,SAAU,SAC9C6O,EAAWT,GAAmBpO,EAAO,WAC3CqG,GAASwI,EAASxI,MAAQyI,EAAQzI,MAClCqB,GAAUmH,EAASnH,OAASoH,EAAQpH,OASjC,OAPPrB,EAAQ7e,KAAK+B,IAAI,EAAG8c,EAAQwJ,EAAQxJ,OACpCqB,EAASlgB,KAAK+B,IAAI,EAAGqmB,EAAcpoB,KAAKyb,MAAMoD,EAAQuJ,GAAelI,EAASmI,EAAQnI,QACtFrB,EAAQmJ,GAAOhoB,KAAKC,IAAI4e,EAAO6E,EAAU6E,EAAc7E,WACvDxD,EAAS8H,GAAOhoB,KAAKC,IAAIigB,EAAQoI,EAAWC,EAAcD,YACtDzJ,IAAUqB,IACVA,EAAS8H,GAAOnJ,EAAQ,IAErB,CACHA,MAAAA,EACAqB,OAAAA,GAIC6I,SAAAA,GAAYzpB,EAAO0pB,EAAYC,GAC9BC,IAAAA,EAAa5pB,EAAMqgB,wBAA0BqJ,GAAc,EAC1DlJ,EAAyBxgB,EAAzBwgB,OAAQjB,EAAiBvf,EAAjBuf,MAAOqB,EAAU5gB,EAAV4gB,OACtBJ,EAAOI,OAASA,EAASgJ,EACzBpJ,EAAOjB,MAAQA,EAAQqK,EACvB5pB,EAAMsZ,IAAIuQ,aAAaD,EAAY,EAAG,EAAGA,EAAY,EAAG,GACpDpJ,EAAOtH,QAAUyQ,IAAgBnJ,EAAOtH,MAAM0H,SAAWJ,EAAOtH,MAAMqG,SACtEiB,EAAOtH,MAAM0H,OAASA,EAAS,KAC/BJ,EAAOtH,MAAMqG,MAAQA,EAAQ,MAI/BuK,IAAAA,GAAgC,WAC9BC,IAAAA,GAAmB,EACnB,IACMxT,IAAAA,EAAU,CACRyT,cAEO,OADPD,GAAmB,GACZ,IAGfnsB,OAAOqsB,iBAAiB,OAAQ,KAAM1T,GACtC3Y,OAAOssB,oBAAoB,OAAQ,KAAM3T,GAC3C,MAAO/S,IAEFumB,OAAAA,EAb2B,GAgB7BI,SAAAA,GAAalD,EAAS7J,GACrBzJ,IAAAA,EAAQuT,GAASD,EAAS7J,GAC1BgN,EAAUzW,GAASA,EAAM0W,MAAM,qBAC9BD,OAAAA,GAAWA,EAAQ,QAAKrqB,EAG1BuqB,SAAAA,GAAoB9mB,EAAGxD,GACxB,MAAA,WAAYwD,EACL,CACH6C,EAAG7C,EAAE6C,EACLwW,EAAGrZ,EAAEqZ,GAGN8K,GAAsBnkB,EAAGxD,GAiB3BuqB,SAAAA,GAAaC,EAASC,EAAM9W,EAAOiG,GACjC8Q,IAAAA,EAA6BF,EAA7BE,WAAYzL,EAAiBuL,EAAjBvL,KAAM0L,EAAWH,EAAXG,QACnBC,EAASF,EAAWG,YAAYD,OAClCA,GAAAA,GAAUH,IAASG,EAAOH,MAAQE,GAAW1L,EAAK7d,OAAQ,CACpD0pB,IAAAA,EAAeF,EAAOG,eAAiBzF,GAAgBD,GACzD,IAACzL,EACMkR,OAAAA,EAAa7L,EAAMwL,EAAM9W,GAC7B,GAAI+W,EAAWM,eAAgB,CAC5B7D,IAAAA,EAAKlI,EAAK,GACV3Z,EAA+B,mBAAhB6hB,EAAG8D,UAA2B9D,EAAG8D,SAASR,GAC3DnlB,GAAAA,EAAO,CACDlG,IAAAA,EAAQ0rB,EAAa7L,EAAMwL,EAAM9W,EAAQrO,GACzCjG,EAAMyrB,EAAa7L,EAAMwL,EAAM9W,EAAQrO,GACtC,MAAA,CAAC8f,GAAIhmB,EAAMgmB,GAAIF,GAAI7lB,EAAI6lB,MAInC,MAAA,CAACE,GAAI,EAAGF,GAAIjG,EAAK7d,OAAS,GAG5B8pB,SAAAA,GAAuBlrB,EAAOyqB,EAAMU,EAAUC,EAASxR,GAGvD,IAFCyR,IAAAA,EAAWrrB,EAAMsrB,+BACjB3X,EAAQwX,EAASV,GACdppB,EAAI,EAAGoU,EAAO4V,EAASjqB,OAAQC,EAAIoU,IAAQpU,EAG3C,IAFiBgqB,IAAAA,EAAAA,EAAShqB,GAAxBwU,EAAAA,EAAAA,MAAOoJ,EAAAA,EAAAA,KACGsL,EAAAA,GAAac,EAAShqB,GAAIopB,EAAM9W,EAAOiG,GAAjDwL,EAAAA,EAAAA,GAAIF,EAAAA,EAAAA,GACFhU,EAAIkU,EAAIlU,GAAKgU,IAAMhU,EAAG,CACrB+V,IAAAA,EAAUhI,EAAK/N,GAChB+V,EAAQsE,MACTH,EAAQnE,EAASpR,EAAO3E,IAgB/Bsa,SAAAA,GAAkBxrB,EAAOmrB,EAAUV,EAAMgB,GACxCtqB,IAAAA,EAAQ,GACV,IAACghB,GAAegJ,EAAUnrB,EAAM0rB,UAAW1rB,EAAM2rB,aAC1CxqB,OAAAA,EAQJA,OADP+pB,GAAuBlrB,EAAOyqB,EAAMU,EALb,SAAUlE,EAASrR,EAAcC,GAChDoR,EAAQ2E,QAAQT,EAAS9kB,EAAG8kB,EAAStO,EAAG4O,IACxCtqB,EAAMkB,KAAK,CAAC4kB,QAAAA,EAASrR,aAAAA,EAAcC,MAAAA,MAGmB,GACvD1U,EAGF0qB,SAAAA,GAAgB7rB,EAAOmrB,EAAUV,EAAM7Q,EAAW6R,GACjDK,IAAAA,EAzBDC,SAAyBtB,GACxBuB,IAAAA,GAA8B,IAAvBvB,EAAKpU,QAAQ,KACpB4V,GAA8B,IAAvBxB,EAAKpU,QAAQ,KACnB,OAAA,SAAU+H,EAAKC,GACZ6N,IAAAA,EAASF,EAAOtrB,KAAKqc,IAAIqB,EAAI/X,EAAIgY,EAAIhY,GAAK,EAC1C8lB,EAASF,EAAOvrB,KAAKqc,IAAIqB,EAAIvB,EAAIwB,EAAIxB,GAAK,EACzCnc,OAAAA,KAAK8b,KAAK9b,KAAKwb,IAAIgQ,EAAQ,GAAKxrB,KAAKwb,IAAIiQ,EAAQ,KAmBrCJ,CAAyBtB,GAC5C2B,EAAc3X,OAAOgH,kBACrBta,EAAQ,GACR,IAACghB,GAAegJ,EAAUnrB,EAAM0rB,UAAW1rB,EAAM2rB,aAC1CxqB,OAAAA,EAgBJA,OADP+pB,GAAuBlrB,EAAOyqB,EAAMU,EAbb,SAAUlE,EAASrR,EAAcC,GAChD+D,IAAAA,GAAcqN,EAAQ2E,QAAQT,EAAS9kB,EAAG8kB,EAAStO,EAAG4O,GAAtD7R,CAGEyS,IAAAA,EAASpF,EAAQqF,eAAeb,GAChCvN,EAAW4N,EAAeX,EAAUkB,GACtCnO,EAAWkO,GACXjrB,EAAQ,CAAC,CAAC8lB,QAAAA,EAASrR,aAAAA,EAAcC,MAAAA,IACjCuW,EAAclO,GACPA,IAAakO,GACpBjrB,EAAMkB,KAAK,CAAC4kB,QAAAA,EAASrR,aAAAA,EAAcC,MAAAA,OAIpC1U,EAGForB,SAAAA,GAAavsB,EAAOwD,EAAG+S,EAASkV,GAC/BN,IAAAA,EAAWb,GAAoB9mB,EAAGxD,GAClCmB,EAAQ,GACRspB,EAAOlU,EAAQkU,KACf+B,EAAuB,MAAT/B,EAAe,WAAa,WAC5CgC,GAAiB,EASjBlW,OA/GCmW,SAAwB1sB,EAAOorB,GAG/B,IAFCC,IACFxV,EAAOoJ,EAAMgI,EADXoE,EAAWrrB,EAAMsrB,+BAEdjqB,EAAI,EAAGoU,EAAO4V,EAASjqB,OAAQC,EAAIoU,IAAQpU,EAAG,CAClCgqB,IAAAA,EAAAA,EAAShqB,GAAxBwU,EAAAA,EAAAA,MACG,IAAA,IAAI3E,EAAI,EAAG2O,GADPZ,EAAAA,EAAAA,MACmB7d,OAAQ8P,EAAI2O,IAAQ3O,GAC5C+V,EAAUhI,EAAK/N,IACFqa,MACTH,EAAQnE,EAASpR,EAAO3E,IA+FpCwb,CAAwB1sB,EAAO,SAACinB,EAASrR,EAAcC,GAC/CoR,EAAQuF,GAAarB,EAASV,GAAOgB,IACrCtqB,EAAMkB,KAAK,CAAC4kB,QAAAA,EAASrR,aAAAA,EAAcC,MAAAA,IAEnCoR,EAAQ2E,QAAQT,EAAS9kB,EAAG8kB,EAAStO,EAAG4O,KACxCgB,GAAiB,KAGrBlW,EAAQqD,YAAc6S,EACf,GAEJtrB,EAGPwrB,IAAAA,GAAc,CACdC,MAAO,CACH/W,MAAM7V,SAAAA,EAAOwD,EAAG+S,EAASkV,GACfN,IAAAA,EAAWb,GAAoB9mB,EAAGxD,GAClCyqB,EAAOlU,EAAQkU,MAAQ,IACvBtpB,EAAQoV,EAAQqD,UAChB4R,GAAkBxrB,EAAOmrB,EAAUV,EAAMgB,GACzCI,GAAgB7rB,EAAOmrB,EAAUV,GAAM,EAAOgB,GAC9C5S,EAAW,GACb,OAAC1X,EAAMC,QAGXpB,EAAMsrB,+BAA+B9qB,QAAQ,SAACqsB,GACpChX,IAAAA,EAAQ1U,EAAM,GAAG0U,MACjBoR,EAAU4F,EAAK5N,KAAKpJ,GACtBoR,IAAYA,EAAQsE,MACpB1S,EAASxW,KAAK,CAAC4kB,QAAAA,EAASrR,aAAciX,EAAKhX,MAAOA,MAAAA,MAGnDgD,GATI,IAWfiU,QAAQ9sB,SAAAA,EAAOwD,EAAG+S,EAASkV,GACjBN,IAAAA,EAAWb,GAAoB9mB,EAAGxD,GAClCyqB,EAAOlU,EAAQkU,MAAQ,KACzBtpB,EAAQoV,EAAQqD,UACd4R,GAAkBxrB,EAAOmrB,EAAUV,EAAMgB,GAC3CI,GAAgB7rB,EAAOmrB,EAAUV,GAAM,EAAOgB,GAC9CtqB,GAAAA,EAAMC,OAAS,EAAG,CACZwU,IAAAA,EAAezU,EAAM,GAAGyU,aACxBqJ,EAAOjf,EAAM+sB,eAAenX,GAAcqJ,KAChD9d,EAAQ,GACH,IAAA,IAAIE,EAAI,EAAGA,EAAI4d,EAAK7d,SAAUC,EAC/BF,EAAMkB,KAAK,CAAC4kB,QAAShI,EAAK5d,GAAIuU,aAAAA,EAAcC,MAAOxU,IAGpDF,OAAAA,GAEXihB,MAAMpiB,SAAAA,EAAOwD,EAAG+S,EAASkV,GAGdD,OAAAA,GAAkBxrB,EAFRsqB,GAAoB9mB,EAAGxD,GAC3BuW,EAAQkU,MAAQ,KACmBgB,IAEpDuB,QAAQhtB,SAAAA,EAAOwD,EAAG+S,EAASkV,GAGhBI,OAAAA,GAAgB7rB,EAFNsqB,GAAoB9mB,EAAGxD,GAC3BuW,EAAQkU,MAAQ,KACiBlU,EAAQqD,UAAW6R,IAErEplB,EAAErG,SAAAA,EAAOwD,EAAG+S,EAASkV,GAEVc,OADPhW,EAAQkU,KAAO,IACR8B,GAAavsB,EAAOwD,EAAG+S,EAASkV,IAE3C5O,EAAE7c,SAAAA,EAAOwD,EAAG+S,EAASkV,GAEVc,OADPhW,EAAQkU,KAAO,IACR8B,GAAavsB,EAAOwD,EAAG+S,EAASkV,MAK7CwB,GAAc,IAAIC,OAAO,wCAEtBC,SAAAA,GAAaxZ,EAAOsF,GACnBmR,IAAAA,GAAW,GAAKzW,GAAO0W,MAAM4C,IAC/B,IAAC7C,GAA0B,WAAfA,EAAQ,GACbnR,OAAO,IAAPA,EAGHmR,OADRzW,GAASyW,EAAQ,GACTA,EAAQ,IACP,IAAA,KACMzW,OAAAA,EACN,IAAA,IACDA,GAAS,IAGVsF,OAAAA,EAAOtF,EAGZyZ,IAAAA,GAAiB,SAAArpB,GAAK,OAACA,GAAK,GAEzBspB,SAAAA,GAAiB1Z,EAAO2Z,GACvB9a,IAD8B,EAC9BA,EAAM,GACN+a,EAAWhZ,GAAS+Y,GACpBjc,EAAOkc,EAAWjc,OAAOD,KAAKic,GAASA,EACvCE,EAAOjZ,GAASZ,GAChB4Z,EACI,SAAAE,GAAQ5Y,OAAAA,GAAelB,EAAM8Z,GAAO9Z,EAAM2Z,EAAMG,MAChD,SAAAA,GAAQ9Z,OAAAA,EAAM8Z,IAClB,WAAM9Z,OAAAA,GACOtC,EAAAA,EAAAA,GATiB,IASX,IAAA,EAAA,MAAA,EAAA,EAAA,KAAA,MAAA,CAAdoc,IAAAA,EAAc,EAAA,MACrBjb,EAAIib,GAAQL,GAAeI,EAAKC,KAVA,MAAA,GAAA,EAAA,EAAA,GAAA,QAAA,EAAA,IAY7Bjb,OAAAA,EAGFkb,SAAAA,GAAO/Z,GACL0Z,OAAAA,GAAiB1Z,EAAO,CAAC4O,IAAK,IAAK/iB,MAAO,IAAKgjB,OAAQ,IAAKjjB,KAAM,MAGpEouB,SAAAA,GAAcha,GACZ0Z,OAAAA,GAAiB1Z,EAAO,CAAC,UAAW,WAAY,aAAc,gBAGhEia,SAAAA,GAAUja,GACTf,IAAAA,EAAM8a,GAAO/Z,GAGZf,OAFPA,EAAI2M,MAAQ3M,EAAIrT,KAAOqT,EAAIpT,MAC3BoT,EAAIgO,OAAShO,EAAI2P,IAAM3P,EAAI4P,OACpB5P,EAGFib,SAAAA,GAAOtX,EAASuX,GACrBvX,EAAUA,GAAW,GACrBuX,EAAWA,GAAY3V,GAASY,KAC5BE,IAAAA,EAAOpE,GAAe0B,EAAQ0C,KAAM6U,EAAS7U,MAC7B,iBAATA,IACPA,EAAOxH,SAASwH,EAAM,KAEpBF,IAAAA,EAAO,CACTC,OAAQnE,GAAe0B,EAAQyC,OAAQ8U,EAAS9U,QAChDG,WAAYgU,GAAatY,GAAe0B,EAAQ4C,WAAY2U,EAAS3U,YAAaF,GAClFA,KAAAA,EACAC,MAAOrE,GAAe0B,EAAQ2C,MAAO4U,EAAS5U,OAC9ClG,OAAQ6B,GAAe0B,EAAQvD,OAAQ8a,EAAS9a,QAChDoM,OAAQ,IAGLrG,OADPA,EAAKqG,OAASL,GAAahG,GACpBA,EAGFgV,SAAAA,GAAQC,EAAQtV,EAAS7C,EAAOoY,GACjCC,IACA7sB,EAAGoU,EAAM9B,EADTua,GAAY,EAEX7sB,IAAAA,EAAI,EAAGoU,EAAOuY,EAAO5sB,OAAQC,EAAIoU,IAAQpU,EAEtCsS,QAAU5T,KADd4T,EAAQqa,EAAO3sB,WAICtB,IAAZ2Y,GAA0C,mBAAV/E,IAChCA,EAAQA,EAAM+E,GACdwV,GAAY,QAEFnuB,IAAV8V,GAAuBrQ,GAAQmO,KAC/BA,EAAQA,EAAMkC,EAAQlC,EAAMvS,QAC5B8sB,GAAY,QAEFnuB,IAAV4T,GAIOA,OAHHsa,IAASC,IACTD,EAAKC,WAAY,GAEdva,EAKVwa,SAAAA,GAAUC,EAAQC,GAChB1tB,IAAAA,EAAYytB,EAAZztB,IAAK8B,EAAO2rB,EAAP3rB,IACL,MAAA,CACH9B,IAAKA,EAAMD,KAAKqc,IAAI7H,GAAYmZ,EAAO1tB,IACvC8B,IAAKA,EAAMyS,GAAYmZ,EAAO5rB,IAIhC6rB,IAAAA,GAAmB,CAAC,OAAQ,MAAO,QAAS,UAEzCC,SAAAA,GAAiBpR,EAAOgO,GACtBhO,OAAAA,EAAMqR,OAAO,SAAAzqB,GAAKA,OAAAA,EAAEsT,MAAQ8T,IAG9BsD,SAAAA,GAA4BtR,EAAOsN,GACjCtN,OAAAA,EAAMqR,OAAO,SAAAzqB,GAAKuqB,OAAqC,IAArCA,GAAiBjY,QAAQtS,EAAEsT,MAAetT,EAAEukB,IAAImC,OAASA,IAG7EiE,SAAAA,GAAavR,EAAO9H,GAClB8H,OAAAA,EAAMV,KAAK,SAACrZ,EAAGC,GACZqS,IAAAA,EAAKL,EAAUhS,EAAID,EACnBuS,EAAKN,EAAUjS,EAAIC,EAClBqS,OAAAA,EAAG1C,SAAW2C,EAAG3C,OACpB0C,EAAGG,MAAQF,EAAGE,MACdH,EAAG1C,OAAS2C,EAAG3C,SAqDlB2b,SAAAA,GAAeC,EAAYlD,EAAWtoB,EAAGC,GACvC3C,OAAAA,KAAK+B,IAAImsB,EAAWxrB,GAAIsoB,EAAUtoB,IAAM1C,KAAK+B,IAAImsB,EAAWvrB,GAAIqoB,EAAUroB,IAG5EwrB,SAAAA,GAAiBD,EAAYE,GAClCF,EAAWrM,IAAM7hB,KAAK+B,IAAImsB,EAAWrM,IAAKuM,EAAWvM,KACrDqM,EAAWrvB,KAAOmB,KAAK+B,IAAImsB,EAAWrvB,KAAMuvB,EAAWvvB,MACvDqvB,EAAWpM,OAAS9hB,KAAK+B,IAAImsB,EAAWpM,OAAQsM,EAAWtM,QAC3DoM,EAAWpvB,MAAQkB,KAAK+B,IAAImsB,EAAWpvB,MAAOsvB,EAAWtvB,OAGpDuvB,SAAAA,GAAWrD,EAAWsD,EAAQC,GAC7B3G,IAAAA,EAAM2G,EAAO3G,IACbsG,EAAalD,EAAUkD,WACzBra,GAAAA,GAAS0a,EAAO5X,KACT,MAAA,CAAC6X,MAAM,EAAOC,OAAO,GAE5BF,EAAOhW,OACPyS,EAAUuD,EAAO5X,MAAQ4X,EAAOhW,MAEpCgW,EAAOhW,KAAOgW,EAAOG,WAAa9G,EAAI1H,OAAS0H,EAAI/I,MACnDmM,EAAUuD,EAAO5X,MAAQ4X,EAAOhW,KAC5BqP,EAAI+G,YACJR,GAAiBD,EAAYtG,EAAI+G,cAE/BC,IAAAA,EAAW5uB,KAAK+B,IAAI,EAAGusB,EAAOO,WAAaZ,GAAeC,EAAYlD,EAAW,OAAQ,UACzF8D,EAAY9uB,KAAK+B,IAAI,EAAGusB,EAAOS,YAAcd,GAAeC,EAAYlD,EAAW,MAAO,WAC1FgE,EAAeJ,IAAa5D,EAAUvmB,EACtCwqB,EAAgBH,IAAc9D,EAAUpnB,EAGvC2qB,OAFPvD,EAAUvmB,EAAImqB,EACd5D,EAAUpnB,EAAIkrB,EACPP,EAAOG,WACR,CAACF,KAAMQ,EAAcP,MAAOQ,GAC5B,CAACT,KAAMS,EAAeR,MAAOO,GAkB9BE,SAAAA,GAAWR,EAAY1D,GACtBkD,IAAAA,EAAalD,EAAUkD,WAEpBiB,SAAAA,EAAmBxI,GAClB/E,IAAAA,EAAS,CAAC/iB,KAAM,EAAGgjB,IAAK,EAAG/iB,MAAO,EAAGgjB,OAAQ,GAI5CF,OAHP+E,EAAU7mB,QAAQ,SAAC6W,GACfiL,EAAOjL,GAAO3W,KAAK+B,IAAIipB,EAAUrU,GAAMuX,EAAWvX,MAE/CiL,EAGJ8M,OACDS,EADCT,EACkB,CAAC,OAAQ,SACT,CAAC,MAAO,WAG5BU,SAAAA,GAASC,EAAOrE,EAAWsD,GAC1BgB,IACF3uB,EAAGoU,EAAMwZ,EAAQ3G,EAAK2H,EAAOC,EAD3BF,EAAa,GAEd3uB,IAAAA,EAAI,EAAGoU,EAAOsa,EAAM3uB,OAAQ6uB,EAAQ,EAAG5uB,EAAIoU,IAAQpU,EAAG,EAEvDinB,GADA2G,EAASc,EAAM1uB,IACFinB,KACT6H,OACAlB,EAAO1P,OAASmM,EAAUvmB,EAC1B8pB,EAAOrO,QAAU8K,EAAUpnB,EAC3BsrB,GAAWX,EAAOG,WAAY1D,IAEZqD,IAAAA,EAAAA,GAAWrD,EAAWsD,EAAQC,GAA7CC,EAAAA,EAAAA,KAAMC,EAAAA,EAAAA,MACbc,GAASf,GAAQc,EAAW5uB,OAC5B8uB,EAAUA,GAAWf,EAChB7G,EAAI8H,UACLJ,EAAW3tB,KAAK4sB,GAGjBgB,OAAAA,GAASH,GAASE,EAAYtE,EAAWsD,IAAWkB,EAGtDG,SAAAA,GAAWN,EAAOrE,EAAWsD,GAC5BsB,IAGFjvB,EAAGoU,EAAMwZ,EAAQ3G,EAHfgI,EAActB,EAAOuB,QACvBlqB,EAAIqlB,EAAUrlB,EACdwW,EAAI6O,EAAU7O,EAEbxb,IAAAA,EAAI,EAAGoU,EAAOsa,EAAM3uB,OAAQC,EAAIoU,IAAQpU,EAEzCinB,GADA2G,EAASc,EAAM1uB,IACFinB,IACT2G,EAAOG,YACP9G,EAAI/oB,KAAO+oB,EAAI8H,SAAWE,EAAY/wB,KAAOmsB,EAAUnsB,KACvD+oB,EAAI9oB,MAAQ8oB,EAAI8H,SAAWpB,EAAOO,WAAae,EAAY9wB,MAAQksB,EAAUnsB,KAAOmsB,EAAUvmB,EAC9FmjB,EAAI/F,IAAM1F,EACVyL,EAAI9F,OAAS3F,EAAIyL,EAAI1H,OACrB0H,EAAI/I,MAAQ+I,EAAI9oB,MAAQ8oB,EAAI/oB,KAC5Bsd,EAAIyL,EAAI9F,SAER8F,EAAI/oB,KAAO8G,EACXiiB,EAAI9oB,MAAQ6G,EAAIiiB,EAAI/I,MACpB+I,EAAI/F,IAAM+F,EAAI8H,SAAWE,EAAY/N,IAAMmJ,EAAUnJ,IACrD+F,EAAI9F,OAAS8F,EAAI8H,SAAWpB,EAAOS,YAAca,EAAY9wB,MAAQksB,EAAUnJ,IAAMmJ,EAAUpnB,EAC/FgkB,EAAI1H,OAAS0H,EAAI9F,OAAS8F,EAAI/F,IAC9Blc,EAAIiiB,EAAI9oB,OAGhBksB,EAAUrlB,EAAIA,EACdqlB,EAAU7O,EAAIA,EAGlB1E,GAASlW,IAAI,SAAU,CACnBsuB,QAAS,CACLhO,IAAK,EACL/iB,MAAO,EACPgjB,OAAQ,EACRjjB,KAAM,KAGVixB,IAAAA,GAAU,CACVC,OAAOzwB,SAAAA,EAAOsB,GACLtB,EAAM+vB,QACP/vB,EAAM+vB,MAAQ,IAElBzuB,EAAK8uB,SAAW9uB,EAAK8uB,WAAY,EACjC9uB,EAAK6pB,SAAW7pB,EAAK6pB,UAAY,MACjC7pB,EAAK0R,OAAS1R,EAAK0R,QAAU,EAC7B1R,EAAKovB,QAAUpvB,EAAKovB,SAAW,WACpB,MAAA,CAAC,CACJC,EAAG,EACHpvB,KAAKmqB,SAAAA,GACDpqB,EAAKC,KAAKmqB,OAItB1rB,EAAM+vB,MAAM1tB,KAAKf,IAErBsvB,UAAU5wB,SAAAA,EAAO6wB,GACPhb,IAAAA,EAAQ7V,EAAM+vB,MAAQ/vB,EAAM+vB,MAAM1Z,QAAQwa,IAAe,GAChD,IAAXhb,GACA7V,EAAM+vB,MAAM7P,OAAOrK,EAAO,IAGlCib,UAAU9wB,SAAAA,EAAOsB,EAAMiV,GACnBjV,EAAK8uB,SAAW7Z,EAAQ6Z,SACxB9uB,EAAK6pB,SAAW5U,EAAQ4U,SACxB7pB,EAAK0R,OAASuD,EAAQvD,QAE1Bmd,OAAOnwB,SAAAA,EAAOuf,EAAOqB,EAAQmQ,GACrB,GAAC/wB,EAAD,CAGEuwB,IAAAA,EAAU3C,GAAU5tB,EAAMuW,QAAQ0Y,OAAOsB,SACzCS,EAAiBzR,EAAQgR,EAAQhR,MACjC0R,EAAkBrQ,EAAS2P,EAAQ3P,OACnCmP,EAnLLmB,SAAiBnB,GAChBoB,IAAAA,EA/BDC,SAAUrB,GACToB,IACF9vB,EAAGoU,EAAM6S,EADP6I,EAAc,GAEf9vB,IAAAA,EAAI,EAAGoU,GAAQsa,GAAS,IAAI3uB,OAAQC,EAAIoU,IAAQpU,EACjDinB,EAAMyH,EAAM1uB,GACZ8vB,EAAY9uB,KAAK,CACbwT,MAAOxU,EACPinB,IAAAA,EACAjR,IAAKiR,EAAI6C,SACTiE,WAAY9G,EAAI+I,eAChBre,OAAQsV,EAAItV,SAGbme,OAAAA,EAkBaC,CAAUrB,GACxBK,EAAW1B,GAAayC,EAAY3C,OAAO,SAAA8C,GAAQA,OAAAA,EAAKhJ,IAAI8H,YAAW,GACvE7wB,EAAOmvB,GAAaH,GAAiB4C,EAAa,SAAS,GAC3D3xB,EAAQkvB,GAAaH,GAAiB4C,EAAa,UACnD5O,EAAMmM,GAAaH,GAAiB4C,EAAa,QAAQ,GACzD3O,EAASkM,GAAaH,GAAiB4C,EAAa,WACpDI,EAAmB9C,GAA4B0C,EAAa,KAC5DK,EAAiB/C,GAA4B0C,EAAa,KACzD,MAAA,CACHf,SAAAA,EACAqB,WAAYlyB,EAAKmyB,OAAOnP,GACxBoP,eAAgBnyB,EAAMkyB,OAAOF,GAAgBE,OAAOlP,GAAQkP,OAAOH,GACnE7F,UAAW6C,GAAiB4C,EAAa,aACzCS,SAAUryB,EAAKmyB,OAAOlyB,GAAOkyB,OAAOF,GACpCpC,WAAY7M,EAAImP,OAAOlP,GAAQkP,OAAOH,IAoKxBL,CAAiBlxB,EAAM+vB,OAC/B8B,EAAgB9B,EAAM6B,SACtBE,EAAkB/B,EAAMX,WAC9Bja,GAAKnV,EAAM+vB,MAAO,SAAAzH,GACkB,mBAArBA,EAAIyJ,cACXzJ,EAAIyJ,iBAGNC,IAAAA,EAA0BH,EAAcvvB,OAAO,SAAC2vB,EAAOX,GACzDA,OAAAA,EAAKhJ,IAAI/R,UAAwC,IAA7B+a,EAAKhJ,IAAI/R,QAAQ2b,QAAoBD,EAAQA,EAAQ,GAAG,IAAM,EAChFjD,EAAS1d,OAAO6gB,OAAO,CACzB5C,WAAYhQ,EACZkQ,YAAa7O,EACb2P,QAAAA,EACAS,eAAAA,EACAC,gBAAAA,EACAmB,aAAcpB,EAAiB,EAAIgB,EACnCK,cAAepB,EAAkB,IAE/BrC,EAAatd,OAAOW,OAAO,GAAIse,GACrC1B,GAAiBD,EAAYhB,GAAUmD,IACjCrF,IAAAA,EAAYpa,OAAOW,OAAO,CAC5B2c,WAAAA,EACAzpB,EAAG6rB,EACH1sB,EAAG2sB,EACH5qB,EAAGkqB,EAAQhxB,KACXsd,EAAG0T,EAAQhO,KACZgO,IA5NF+B,SAAc9B,EAASxB,GACxB3tB,IAAAA,EAAGoU,EAAMwZ,EACR5tB,IAAAA,EAAI,EAAGoU,EAAO+a,EAAQpvB,OAAQC,EAAIoU,IAAQpU,GAC3C4tB,EAASuB,EAAQnvB,IACN+tB,YACPH,EAAO1P,MAAQ0P,EAAO3G,IAAI8H,UAAYpB,EAAOgC,eAC7C/B,EAAOrO,OAASoO,EAAOqD,gBAEvBpD,EAAO1P,MAAQyP,EAAOoD,aACtBnD,EAAOrO,OAASqO,EAAO3G,IAAI8H,UAAYpB,EAAOiC,iBAoNlDqB,CAAcT,EAAcH,OAAOI,GAAkB9C,GACrDc,GAASC,EAAMK,SAAU1E,EAAWsD,GACpCc,GAAS+B,EAAenG,EAAWsD,GAC/Bc,GAASgC,EAAiBpG,EAAWsD,IACrCc,GAAS+B,EAAenG,EAAWsD,GA5JtCuD,SAAiB7G,GAChBkD,IAAAA,EAAalD,EAAUkD,WAEpB4D,SAAAA,EAAUnb,GACTob,IAAAA,EAAS/xB,KAAK+B,IAAImsB,EAAWvX,GAAOqU,EAAUrU,GAAM,GAEnDob,OADP/G,EAAUrU,IAAQob,EACXA,EAGX/G,EAAU7O,GAAK2V,EAAU,OACzB9G,EAAUrlB,GAAKmsB,EAAU,QACzBA,EAAU,SACVA,EAAU,UAkJND,CAAiB7G,GACjB2E,GAAWN,EAAM0B,WAAY/F,EAAWsD,GACxCtD,EAAUrlB,GAAKqlB,EAAUvmB,EACzBumB,EAAU7O,GAAK6O,EAAUpnB,EACzB+rB,GAAWN,EAAM4B,eAAgBjG,EAAWsD,GAC5ChvB,EAAM0rB,UAAY,CACdnsB,KAAMmsB,EAAUnsB,KAChBgjB,IAAKmJ,EAAUnJ,IACf/iB,MAAOksB,EAAUnsB,KAAOmsB,EAAUvmB,EAClCqd,OAAQkJ,EAAUnJ,IAAMmJ,EAAUpnB,EAClCsc,OAAQ8K,EAAUpnB,EAClBib,MAAOmM,EAAUvmB,GAErBgQ,GAAK4a,EAAMrE,UAAW,SAACuD,GACb3G,IAAAA,EAAM2G,EAAO3G,IACnBhX,OAAOW,OAAOqW,EAAKtoB,EAAM0rB,WACzBpD,EAAI6H,OAAOzE,EAAUvmB,EAAGumB,EAAUpnB,QAKxCouB,GAp2EW,WAAA,SAAA,IAAA,EAAA,KAAA,GAAA,OAAA,EAAA,EAAA,CAAA,CAAA,IAAA,iBAq2Eb,MAAA,SAAelS,EAAQsI,MAr2EV,CAAA,IAAA,iBAw2Eb,MAAA,SAAepQ,GACJ,OAAA,IAz2EE,CAAA,IAAA,mBA42Eb,MAAA,SAAiB1Y,EAAOG,EAAMulB,MA52EjB,CAAA,IAAA,sBA+2Eb,MAAA,SAAoB1lB,EAAOG,EAAMulB,MA/2EpB,CAAA,IAAA,sBAk3Eb,MAAA,WACW,OAAA,IAn3EE,CAAA,IAAA,iBAs3Eb,MAAA,SAAeuB,EAAS1H,EAAOqB,EAAQkI,GAG5B,OAFPvJ,EAAQ7e,KAAK+B,IAAI,EAAG8c,GAAS0H,EAAQ1H,OACrCqB,EAASA,GAAUqG,EAAQrG,OACpB,CACHrB,MAAAA,EACAqB,OAAQlgB,KAAK+B,IAAI,EAAGqmB,EAAcpoB,KAAKyb,MAAMoD,EAAQuJ,GAAelI,MA33E/D,CAAA,IAAA,aA+3Eb,MAAA,SAAWJ,GACA,OAAA,MAh4EE,EAAA,GAo4EXmS,GAp4EW,SAAA,GAAA,EAAA,EAo4EWD,IAp4EX,IAAA,EAAA,EAAA,GAAA,SAAA,IAAA,OAAA,EAAA,KAAA,GAAA,EAAA,MAAA,KAAA,WAAA,OAAA,EAAA,EAAA,CAAA,CAAA,IAAA,iBAq4Eb,MAAA,SAAepxB,GACJA,OAAAA,GAAQA,EAAKmf,YAAcnf,EAAKmf,WAAW,OAAS,SAt4ElD,EAAA,GA04EXmS,GAAc,WACdC,GAAc,CAChBC,WAAY,YACZC,UAAW,YACXC,SAAU,UACVC,aAAc,aACdC,YAAa,YACbC,YAAa,YACbC,UAAW,UACXC,aAAc,WACdC,WAAY,YAEVC,GAAgB,SAAA5f,GAASA,OAAU,OAAVA,GAA4B,KAAVA,GAsC3C6f,IAAAA,KAAuB1J,IAA+B,CAACE,SAAS,GAM7DyJ,SAAAA,GAAezzB,EAAOG,EAAMulB,GACjC1lB,EAAMwgB,OAAO0J,oBAAoB/pB,EAAMulB,EAAU8N,IAe5CE,SAAAA,GAAqB1zB,EAAOG,EAAMulB,GACjClF,IAAAA,EAASxgB,EAAMwgB,OAEfyG,EADYzG,GAAU+F,GAAe/F,IACdA,EACvBmT,EAAW,IAAIC,iBAAiB,SAAAC,GAC5BpN,IAAAA,EAASF,GAAeU,GAC9B4M,EAAQrzB,QAAQ,SAAAszB,GACP,IAAA,IAAIzyB,EAAI,EAAGA,EAAIyyB,EAAMC,WAAW3yB,OAAQC,IAAK,CACxC2yB,IAAAA,EAAQF,EAAMC,WAAW1yB,GAC3B2yB,IAAU/M,GAAW+M,IAAUvN,GAC/Bf,EAASoO,EAAM9d,aAMxB2d,OADPA,EAASM,QAAQC,SAAU,CAACC,WAAW,EAAMC,SAAS,IAC/CT,EAGFU,SAAAA,GAAqBr0B,EAAOG,EAAMulB,GACjClF,IAAAA,EAASxgB,EAAMwgB,OACf2I,EAAY3I,GAAU+F,GAAe/F,GACvC,GAAC2I,EAAD,CAGEwK,IAAAA,EAAW,IAAIC,iBAAiB,SAAAC,GAClCA,EAAQrzB,QAAQ,SAAAszB,GACP,IAAA,IAAIzyB,EAAI,EAAGA,EAAIyyB,EAAMQ,aAAalzB,OAAQC,IACvCyyB,GAAAA,EAAMQ,aAAajzB,KAAOmf,EAAQ,CAClCkF,IACA,WAMTiO,OADPA,EAASM,QAAQ9K,EAAW,CAACgL,WAAW,IACjCR,GAGLY,IAAAA,GAAqB,IAAI30B,IAC3B40B,GAAsB,EAEjBC,SAAAA,KACCC,IAAAA,EAAM92B,OAAO6a,iBACfic,IAAQF,KAGZA,GAAsBE,EACtBH,GAAmB/zB,QAAQ,SAACm0B,EAAQ30B,GAC5BA,EAAMqgB,0BAA4BqU,GAClCC,OAmBHC,SAAAA,GAAqB50B,EAAOG,EAAMulB,GACjClF,IAAAA,EAASxgB,EAAMwgB,OACf2I,EAAY3I,GAAU+F,GAAe/F,GACvC,GAAC2I,EAAD,CAGEwL,IAAAA,EAAS52B,EAAU,SAACwhB,EAAOqB,GACvBzb,IAAAA,EAAIgkB,EAAUI,YACpB7D,EAASnG,EAAOqB,GACZzb,EAAIgkB,EAAUI,aACd7D,KAEL9nB,QACG+1B,EAAW,IAAIkB,eAAe,SAAAhB,GAC1BC,IAAAA,EAAQD,EAAQ,GAChBtU,EAAQuU,EAAMgB,YAAYvV,MAC1BqB,EAASkT,EAAMgB,YAAYlU,OACnB,IAAVrB,GAA0B,IAAXqB,GAGnB+T,EAAOpV,EAAOqB,KAIX+S,OAFPA,EAASM,QAAQ9K,GApCZ4L,SAA8B/0B,EAAO20B,GACrCJ,GAAmBtb,MACpBrb,OAAOqsB,iBAAiB,SAAUwK,IAEtCF,GAAmBtyB,IAAIjC,EAAO20B,GAiC9BI,CAA8B/0B,EAAO20B,GAC9BhB,GAGFqB,SAAAA,GAAgBh1B,EAAOG,EAAMwzB,GAC9BA,GACAA,EAASsB,aAEA,WAAT90B,GAtCC+0B,SAAgCl1B,GACrCu0B,GAAmB3xB,OAAO5C,GACrBu0B,GAAmBtb,MACpBrb,OAAOssB,oBAAoB,SAAUuK,IAoCrCS,CAAgCl1B,GAI/Bm1B,SAAAA,GAAqBn1B,EAAOG,EAAMulB,GACjClF,IAAAA,EAASxgB,EAAMwgB,OACf4U,EAAQr3B,EAAU,SAACmE,GACH,OAAdlC,EAAMsZ,KACNoM,EAzHH2P,SAAgBnzB,EAAOlC,GACtBG,IAAAA,EAAO0yB,GAAY3wB,EAAM/B,OAAS+B,EAAM/B,KAC/BwnB,EAAAA,GAAsBzlB,EAAOlC,GAArCqG,EAAAA,EAAAA,EAAGwW,EAAAA,EAAAA,EACH,MAAA,CACH1c,KAAAA,EACAH,MAAAA,EACAkoB,OAAQhmB,EACRmE,OAAStG,IAANsG,EAAkBA,EAAI,KACzBwW,OAAS9c,IAAN8c,EAAkBA,EAAI,MAiHZwY,CAAgBnzB,EAAOlC,KAErCA,EAAO,SAAC5B,GACD8D,IAAAA,EAAQ9D,EAAK,GACZ,MAAA,CAAC8D,EAAOA,EAAMkmB,QAASlmB,EAAMmmB,WAGjC+M,OAxIFE,SAAYzd,EAAM1X,EAAMulB,GAC7B7N,EAAKoS,iBAAiB9pB,EAAMulB,EAAU8N,IAsItC8B,CAAY9U,EAAQrgB,EAAMi1B,GACnBA,EAGLG,IAAAA,GAzkFW,SAAA,GAAA,EAAA,EAykFS7C,IAzkFT,IAAA,EAAA,EAAA,GAAA,SAAA,IAAA,OAAA,EAAA,KAAA,GAAA,EAAA,MAAA,KAAA,WAAA,OAAA,EAAA,EAAA,CAAA,CAAA,IAAA,iBA0kFb,MAAA,SAAelS,EAAQsI,GACbpQ,IAAAA,EAAU8H,GAAUA,EAAOC,YAAcD,EAAOC,WAAW,MAC7D/H,OAAAA,GAAWA,EAAQ8H,SAAWA,GApLjCgV,SAAWhV,EAAQsI,GAClB5P,IAAAA,EAAQsH,EAAOtH,MACfuc,EAAejV,EAAOkV,aAAa,UACnCC,EAAcnV,EAAOkV,aAAa,SAcpCnC,GAbJ/S,EAAOoS,IAAe,CAClBgD,QAAS,CACLhV,OAAQ6U,EACRlW,MAAOoW,EACPzc,MAAO,CACHgZ,QAAShZ,EAAMgZ,QACftR,OAAQ1H,EAAM0H,OACdrB,MAAOrG,EAAMqG,SAIzBrG,EAAMgZ,QAAUhZ,EAAMgZ,SAAW,QACjChZ,EAAM4O,UAAY5O,EAAM4O,WAAa,aACjCyL,GAAcoC,GAAc,CACtBE,IAAAA,EAAe1L,GAAa3J,EAAQ,cACrBzgB,IAAjB81B,IACArV,EAAOjB,MAAQsW,GAGnBtC,GAAAA,GAAckC,GACVjV,GAAwB,KAAxBA,EAAOtH,MAAM0H,OACbJ,EAAOI,OAASJ,EAAOjB,OAASuJ,GAAe,OAC5C,CACGgN,IAAAA,EAAgB3L,GAAa3J,EAAQ,eACrBzgB,IAAlB+1B,IACAtV,EAAOI,OAASkV,IAwJpBN,CAAWhV,EAAQsI,GACZpQ,GAEJ,OAhlFE,CAAA,IAAA,iBAmlFb,MAAA,SAAeA,GACL8H,IAAAA,EAAS9H,EAAQ8H,OACnB,IAACA,EAAOoS,IACD,OAAA,EAELgD,IAAAA,EAAUpV,EAAOoS,IAAagD,QACnC,CAAA,SAAU,SAASp1B,QAAQ,SAACitB,GACnB9Z,IAAAA,EAAQiiB,EAAQnI,GAClBrZ,GAAcT,GACd6M,EAAOuV,gBAAgBtI,GAEvBjN,EAAOwV,aAAavI,EAAM9Z,KAG5BuF,IAAAA,EAAQ0c,EAAQ1c,OAAS,GAMxB,OALP5H,OAAOD,KAAK6H,GAAO1Y,QAAQ,SAAC4V,GACxBoK,EAAOtH,MAAM9C,GAAO8C,EAAM9C,KAE9BoK,EAAOjB,MAAQiB,EAAOjB,aACfiB,EAAOoS,KACP,IAvmFE,CAAA,IAAA,mBA0mFb,MAAA,SAAiB5yB,EAAOG,EAAMulB,GACrBwE,KAAAA,oBAAoBlqB,EAAOG,GAC1B81B,IAAAA,EAAUj2B,EAAMk2B,WAAal2B,EAAMk2B,SAAW,IAM9C9K,EALW,CACb+K,OAAQzC,GACR0C,OAAQ/B,GACRM,OAAQC,IAEaz0B,IAASg1B,GAClCc,EAAQ91B,GAAQirB,EAAQprB,EAAOG,EAAMulB,KAnnF5B,CAAA,IAAA,sBAsnFb,MAAA,SAAoB1lB,EAAOG,GACjB81B,IAAAA,EAAUj2B,EAAMk2B,WAAal2B,EAAMk2B,SAAW,IAC9Cd,EAAQa,EAAQ91B,GACjBi1B,KAGY,CACbe,OAAQnB,GACRoB,OAAQpB,GACRL,OAAQK,IAEa70B,IAASszB,IAC1BzzB,EAAOG,EAAMi1B,GACrBa,EAAQ91B,QAAQJ,KAnoFP,CAAA,IAAA,sBAsoFb,MAAA,WACWnC,OAAAA,OAAO6a,mBAvoFL,CAAA,IAAA,iBA0oFb,MAAA,SAAe+H,EAAQjB,EAAOqB,EAAQkI,GAC3BH,OAAAA,GAAenI,EAAQjB,EAAOqB,EAAQkI,KA3oFpC,CAAA,IAAA,aA8oFb,MAAA,SAAWtI,GACD2I,IAAAA,EAAY5C,GAAe/F,GAC1B,SAAG2I,IAAa5C,GAAe4C,QAhpF7B,EAAA,GAopFbkN,GAAyB/kB,OAAO6gB,OAAO,CACvCmE,UAAW,KACX5D,aAAcA,GACdC,cAAeA,GACf4C,YAAaA,KAGXgB,GAAS,SAACC,GAAMA,OAAM,IAANA,GAAiB,IAANA,GAC3BC,GAAY,SAACD,EAAG1xB,EAAGsO,GAAM,OAAE1S,KAAKwb,IAAI,EAAG,IAAMsa,GAAK,IAAM91B,KAAKihB,KAAK6U,EAAI1xB,GAAKwW,GAAMlI,IACjFsjB,GAAa,SAACF,EAAG1xB,EAAGsO,GAAM1S,OAAAA,KAAKwb,IAAI,GAAI,GAAKsa,GAAK91B,KAAKihB,KAAK6U,EAAI1xB,GAAKwW,GAAMlI,GAAK,GAC/EujB,GAAU,CACZC,OAAQ,SAAAJ,GAAKA,OAAAA,GACbK,WAAY,SAAAL,GAAKA,OAAAA,EAAIA,GACrBM,YAAa,SAAAN,GAAK,OAACA,GAAKA,EAAI,IAC5BO,cAAe,SAAAP,GAAM,OAACA,GAAK,IAAO,EAC5B,GAAMA,EAAIA,GACT,MAAUA,GAAMA,EAAI,GAAK,IAChCQ,YAAa,SAAAR,GAAKA,OAAAA,EAAIA,EAAIA,GAC1BS,aAAc,SAAAT,GAAK,OAACA,GAAK,GAAKA,EAAIA,EAAI,GACtCU,eAAgB,SAAAV,GAAM,OAACA,GAAK,IAAO,EAC7B,GAAMA,EAAIA,EAAIA,EACd,KAAQA,GAAK,GAAKA,EAAIA,EAAI,IAChCW,YAAa,SAAAX,GAAKA,OAAAA,EAAIA,EAAIA,EAAIA,GAC9BY,aAAc,SAAAZ,GAAK,SAAGA,GAAK,GAAKA,EAAIA,EAAIA,EAAI,IAC5Ca,eAAgB,SAAAb,GAAM,OAACA,GAAK,IAAO,EAC7B,GAAMA,EAAIA,EAAIA,EAAIA,GACjB,KAAQA,GAAK,GAAKA,EAAIA,EAAIA,EAAI,IACrCc,YAAa,SAAAd,GAAKA,OAAAA,EAAIA,EAAIA,EAAIA,EAAIA,GAClCe,aAAc,SAAAf,GAAK,OAACA,GAAK,GAAKA,EAAIA,EAAIA,EAAIA,EAAI,GAC9CgB,eAAgB,SAAAhB,GAAM,OAACA,GAAK,IAAO,EAC7B,GAAMA,EAAIA,EAAIA,EAAIA,EAAIA,EACtB,KAAQA,GAAK,GAAKA,EAAIA,EAAIA,EAAIA,EAAI,IACxCiB,WAAY,SAAAjB,GAAK,OAAyB,EAAxB91B,KAAKkhB,IAAI4U,EAAI7a,KAC/B+b,YAAa,SAAAlB,GAAK91B,OAAAA,KAAKihB,IAAI6U,EAAI7a,KAC/Bgc,cAAe,SAAAnB,GAAK,OAAC,IAAO91B,KAAKkhB,IAAIvG,GAAKmb,GAAK,IAC/CoB,WAAY,SAAApB,GAAMA,OAAM,IAANA,EAAW,EAAI91B,KAAKwb,IAAI,EAAG,IAAMsa,EAAI,KACvDqB,YAAa,SAAArB,GAAMA,OAAM,IAANA,EAAW,EAA4B,EAAvB91B,KAAKwb,IAAI,GAAI,GAAKsa,IACrDsB,cAAe,SAAAtB,GAAKD,OAAAA,GAAOC,GAAKA,EAAIA,EAAI,GAClC,GAAM91B,KAAKwb,IAAI,EAAG,IAAU,EAAJsa,EAAQ,IAChC,IAAyC,EAAjC91B,KAAKwb,IAAI,GAAI,IAAU,EAAJsa,EAAQ,MACzCuB,WAAY,SAAAvB,GAAMA,OAAAA,GAAK,EAAKA,IAAM91B,KAAK8b,KAAK,EAAIga,EAAIA,GAAK,IACzDwB,YAAa,SAAAxB,GAAK91B,OAAAA,KAAK8b,KAAK,GAAKga,GAAK,GAAKA,IAC3CyB,cAAe,SAAAzB,GAAM,OAACA,GAAK,IAAO,GAC3B,IAAO91B,KAAK8b,KAAK,EAAIga,EAAIA,GAAK,GAC/B,IAAO91B,KAAK8b,KAAK,GAAKga,GAAK,GAAKA,GAAK,IAC3C0B,cAAe,SAAA1B,GAAKD,OAAAA,GAAOC,GAAKA,EAAIC,GAAUD,EAAG,KAAO,KACxD2B,eAAgB,SAAA3B,GAAKD,OAAAA,GAAOC,GAAKA,EAAIE,GAAWF,EAAG,KAAO,KAC1D4B,iBAAiB5B,SAAAA,GAGND,OAAAA,GAAOC,GAAKA,EACfA,EAAI,GACE,GAAMC,GAAc,EAAJD,EAJhB,MACA,KAIA,GAAM,GAAME,GAAe,EAAJF,EAAQ,EAL/B,MACA,MAMd6B,WAAW7B,SAAAA,GACD1xB,IAAAA,EAAI,QACH0xB,OAAAA,EAAIA,IAAM1xB,EAAI,GAAK0xB,EAAI1xB,IAElCwzB,YAAY9B,SAAAA,GACF1xB,IAAAA,EAAI,QACH,OAAC0xB,GAAK,GAAKA,IAAM1xB,EAAI,GAAK0xB,EAAI1xB,GAAK,GAE9CyzB,cAAc/B,SAAAA,GACN1xB,IAAAA,EAAI,QACJ,OAAC0xB,GAAK,IAAO,EACCA,EAAIA,IAAuB,GAAhB1xB,GAAM,QAAe0xB,EAAI1xB,GAA3C,GAEJ,KAAQ0xB,GAAK,GAAKA,IAAuB,GAAhB1xB,GAAM,QAAe0xB,EAAI1xB,GAAK,IAElE0zB,aAAc,SAAAhC,GAAK,OAAA,EAAIG,GAAQ8B,cAAc,EAAIjC,IACjDiC,cAAcjC,SAAAA,GACJ3wB,IAAAA,EAAI,OACJtC,EAAI,KACNizB,OAAAA,EAAK,EAAIjzB,EACFsC,EAAI2wB,EAAIA,EAEfA,EAAK,EAAIjzB,EACFsC,GAAK2wB,GAAM,IAAMjzB,GAAMizB,EAAI,IAElCA,EAAK,IAAMjzB,EACJsC,GAAK2wB,GAAM,KAAOjzB,GAAMizB,EAAI,MAEhC3wB,GAAK2wB,GAAM,MAAQjzB,GAAMizB,EAAI,SAExCkC,gBAAiB,SAAAlC,GAAMA,OAAAA,EAAI,GACS,GAA9BG,GAAQ6B,aAAiB,EAAJhC,GACc,GAAnCG,GAAQ8B,cAAkB,EAAJjC,EAAQ,GAAW,KAI7CmC,GAAgB,CAClBC,QAAQC,SAAAA,EAAMC,EAAIC,GACPA,OAAAA,EAAS,GAAMD,EAAKD,GAE/B9lB,MAAM8lB,SAAAA,EAAMC,EAAIC,GACNC,IAAAA,EAAKjmB,EAAM8lB,GANL,eAON5lB,EAAK+lB,EAAGC,OAASlmB,EAAM+lB,GAPjB,eAQL7lB,OAAAA,GAAMA,EAAGgmB,MACVhmB,EAAGimB,IAAIF,EAAID,GAAQj1B,YACnBg1B,GAEVK,OAAON,SAAAA,EAAMC,EAAIC,GACNF,OAAAA,GAAQC,EAAKD,GAAQE,IAI9BK,GA/vFW,WAgwFDC,SAAAA,EAAAA,EAAKrjB,EAAQyX,EAAMqL,GAAI,EAAA,KAAA,GACzBQ,IAAAA,EAAetjB,EAAOyX,GAC5BqL,EAAK/K,GAAQ,CAACsL,EAAIP,GAAIA,EAAIQ,EAAcD,EAAIR,OACtCA,IAAAA,EAAO9K,GAAQ,CAACsL,EAAIR,KAAMS,EAAcR,IACzCt3B,KAAAA,SAAU,EACV+3B,KAAAA,IAAMF,EAAIr7B,IAAM26B,GAAcU,EAAIl5B,MAAe04B,EAAAA,IACjDW,KAAAA,QAAU7C,GAAQ0C,EAAII,SAAW9C,GAAQC,OACzC8C,KAAAA,OAASh5B,KAAKyb,MAAMpb,KAAKC,OAASq4B,EAAIx6B,OAAS,IAC/C6D,KAAAA,UAAY,KAAKjB,OAASf,KAAKyb,MAAMkd,EAAI94B,UACzCo5B,KAAAA,QAAUN,EAAIO,KACdC,KAAAA,QAAU7jB,EACV8jB,KAAAA,MAAQrM,EACRsM,KAAAA,MAAQlB,EACRmB,KAAAA,IAAMlB,EACNmB,KAAAA,eAAYl6B,EA9wFR,OAAA,EAAA,EAAA,CAAA,CAAA,IAAA,SAixFb,MAAA,WACW,OAAA,KAAKyB,UAlxFH,CAAA,IAAA,SAqxFb,MAAA,SAAO63B,EAAKP,EAAI54B,GACNU,IAAAA,EAAK,KACPA,GAAAA,EAAGY,QAAS,CACZZ,EAAGgB,SAAQ,GACL03B,IAAAA,EAAe14B,EAAGi5B,QAAQj5B,EAAGk5B,OAC7BI,EAAUh6B,EAAOU,EAAG84B,OACpBS,EAASv5B,EAAG8B,UAAYw3B,EAC9Bt5B,EAAG84B,OAASx5B,EACZU,EAAG8B,UAAYhC,KAAKyb,MAAMzb,KAAK+B,IAAI03B,EAAQd,EAAI94B,WAC/CK,EAAGa,QAAUy4B,EACbt5B,EAAG+4B,QAAUN,EAAIO,KACjBh5B,EAAGo5B,IAAMjM,GAAQ,CAACsL,EAAIP,GAAIA,EAAIQ,EAAcD,EAAIR,OAChDj4B,EAAGm5B,MAAQhM,GAAQ,CAACsL,EAAIR,KAAMS,EAAcR,OAjyFvC,CAAA,IAAA,SAqyFb,MAAA,WACe,KACJt3B,UADI,KAEJE,KAAKX,KAAKC,OAFN,KAGJQ,SAAU,EAHN,KAIJI,SAAQ,MA1yFN,CAAA,IAAA,OA8yFb,MAAA,SAAK1B,GACKU,IAOFm4B,EAPEn4B,EAAK,KACLs5B,EAAUh6B,EAAOU,EAAG84B,OACpBn5B,EAAWK,EAAG8B,UACd+qB,EAAO7sB,EAAGk5B,MACVjB,EAAOj4B,EAAGm5B,MACVH,EAAOh5B,EAAG+4B,MACVb,EAAKl4B,EAAGo5B,IAGV,GADJp5B,EAAGY,QAAUq3B,IAASC,IAAOc,GAASM,EAAU35B,IAC3CK,EAAGY,QAGJ,OAFAZ,EAAGi5B,QAAQpM,GAAQqL,OACnBl4B,EAAGgB,SAAQ,GAGXs4B,EAAU,EACVt5B,EAAGi5B,QAAQpM,GAAQoL,GAGvBE,EAAUmB,EAAU35B,EAAY,EAChCw4B,EAASa,GAAQb,EAAS,EAAI,EAAIA,EAASA,EAC3CA,EAASn4B,EAAG44B,QAAQ94B,KAAKC,IAAI,EAAGD,KAAK+B,IAAI,EAAGs2B,KAC5Cn4B,EAAGi5B,QAAQpM,GAAQ7sB,EAAG24B,IAAIV,EAAMC,EAAIC,MAp0F3B,CAAA,IAAA,OAu0Fb,MAAA,WACUqB,IAAAA,EAAW,KAAKH,YAAc,KAAKA,UAAY,IAC9C,OAAA,IAAII,QAAQ,SAACrU,EAAKsU,GACrBF,EAAS/3B,KAAK,CAAC2jB,IAAAA,EAAKsU,IAAAA,QA10Ff,CAAA,IAAA,UA80Fb,MAAA,SAAQC,GAGC,IAFCzU,IAAAA,EAASyU,EAAW,MAAQ,MAC5BH,EAAW,KAAKH,WAAa,GAC1B54B,EAAI,EAAGA,EAAI+4B,EAASh5B,OAAQC,IACjC+4B,EAAS/4B,GAAGykB,SAl1FP,EAAA,GAy1FjB3N,GAASlW,IAAI,YAAa,CACtBpD,WAAOkB,EACPQ,SAAU,IACVk5B,OAAQ,eACRz7B,QAAI+B,EACJ84B,UAAM94B,EACN65B,UAAM75B,EACN+4B,QAAI/4B,EACJI,UAAMJ,IAEJy6B,IAAAA,GAAmBlpB,OAAOD,KAAK8G,GAASE,WAC9CF,GAASmC,SAAS,YAAa,CAC3Bc,WAAW,EACXD,YAAY,EACZF,YAAa,SAACV,GAASA,MAAS,eAATA,GAAkC,eAATA,GAAkC,OAATA,KAE7EpC,GAASlW,IAAI,aAAc,CACvBw4B,OAAQ,CACJt6B,KAAM,QACNu6B,WApBO,CAAC,QAAS,cAAe,oBAsBpCC,QAAS,CACLx6B,KAAM,SACNu6B,WAzBQ,CAAC,IAAK,IAAK,cAAe,SAAU,cA4BpDviB,GAASmC,SAAS,aAAc,CAC5Bc,UAAW,cAEfjD,GAASlW,IAAI,cAAe,CACxB24B,OAAQ,CACJviB,UAAW,CACP9X,SAAU,MAGlBo0B,OAAQ,CACJtc,UAAW,CACP9X,SAAU,IAGlBs6B,KAAM,CACFC,WAAY,CACRL,OAAQ,CACJ5B,KAAM,eAEVkC,QAAS,CACL56B,KAAM,UACNI,SAAU,KAItBy6B,KAAM,CACFF,WAAY,CACRL,OAAQ,CACJ3B,GAAI,eAERiC,QAAS,CACL56B,KAAM,UACNs5B,OAAQ,SACRz7B,GAAI,SAAA+F,GAAKA,OAAI,EAAJA,QAMnBk3B,IAAAA,GA15FW,WA25FDj7B,SAAAA,EAAAA,EAAOk7B,GAAQ,EAAA,KAAA,GAClBC,KAAAA,OAASn7B,EACTo7B,KAAAA,YAAc,IAAIx7B,IAClBkxB,KAAAA,UAAUoK,GA95FN,OAAA,EAAA,EAAA,CAAA,CAAA,IAAA,YAi6Fb,MAAA,SAAUA,GACF,GAAC3mB,GAAS2mB,GAAV,CAGEG,IAAAA,EAAgB,KAAKD,YAC3B9pB,OAAOgqB,oBAAoBJ,GAAQ16B,QAAQ,SAAA4V,GACjCijB,IAAAA,EAAM6B,EAAO9kB,GACf,GAAC7B,GAAS8kB,GAAV,CAGEkB,IALwC,EAKxCA,EAAW,GACIC,EAAAA,EAAAA,IANyB,IAMP,IAAA,EAAA,MAAA,EAAA,EAAA,KAAA,MAAA,CAA5Be,IAAAA,EAA4B,EAAA,MACnChB,EAASgB,GAAUlC,EAAIkC,IAPmB,MAAA,GAAA,EAAA,EAAA,GAAA,QAAA,EAAA,KAS7C/1B,GAAQ6zB,EAAIqB,aAAerB,EAAIqB,YAAc,CAACtkB,IAAM5V,QAAQ,SAACitB,GACtDA,IAASrX,GAAQilB,EAAcG,IAAI/N,IACnC4N,EAAcp5B,IAAIwrB,EAAM8M,WAj7F3B,CAAA,IAAA,kBAu7Fb,MAAA,SAAgBvkB,EAAQiC,GACdwjB,IAAAA,EAAaxjB,EAAO1B,QACpBA,EA4ELmlB,SAAqB1lB,EAAQylB,GAC9B,IAACA,EACD,OAEAllB,IAAAA,EAAUP,EAAOO,QACjB,IAACA,EAED,YADAP,EAAOO,QAAUklB,GAGjBllB,EAAQolB,UACR3lB,EAAOO,QAAUA,EAAUjF,OAAOW,OAAO,GAAIsE,EAAS,CAAColB,SAAS,EAAOC,YAAa,MAEjFrlB,OAAAA,EAxFamlB,CAAqB1lB,EAAQylB,GACzC,IAACllB,EACM,MAAA,GAELukB,IAAAA,EAAa,KAAKe,kBAAkBtlB,EAASklB,GAO5CX,OANHW,EAAWE,SA2DdG,SAAShB,EAAYJ,GAGrB,IAFCx5B,IAAAA,EAAU,GACVmQ,EAAOC,OAAOD,KAAKqpB,GAChBr5B,EAAI,EAAGA,EAAIgQ,EAAKjQ,OAAQC,IAAK,CAC5B06B,IAAAA,EAAOjB,EAAWzpB,EAAKhQ,IACzB06B,GAAQA,EAAKnB,UACb15B,EAAQmB,KAAK05B,EAAKC,QAGnB3B,OAAAA,QAAQ4B,IAAI/6B,GAnEX46B,CAAS9lB,EAAOO,QAAQqlB,YAAaH,GAAYS,KAAK,WAClDlmB,EAAOO,QAAUklB,GAClB,cAGAX,IAp8FE,CAAA,IAAA,oBAu8Fb,MAAA,SAAkB9kB,EAAQiC,GAChBojB,IAKFh6B,EALEg6B,EAAgB,KAAKD,YACrBN,EAAa,GACb55B,EAAU8U,EAAO4lB,cAAgB5lB,EAAO4lB,YAAc,IACtDtO,EAAQhc,OAAOD,KAAK4G,GACpB/X,EAAOa,KAAKC,MAEbK,IAAAA,EAAIisB,EAAMlsB,OAAS,EAAGC,GAAK,IAAKA,EAAG,CAC9BosB,IAAAA,EAAOH,EAAMjsB,GACfosB,GAAmB,MAAnBA,EAAKpb,OAAO,GAGZob,GAAS,YAATA,EAAAA,CAIE9Z,IAAAA,EAAQsE,EAAOwV,GACjBpV,EAAYnX,EAAQusB,GAClB4L,EAAMgC,EAAcv5B,IAAI2rB,GAC1BpV,GAAAA,EAAW,CACPghB,GAAAA,GAAOhhB,EAAUuiB,SAAU,CAC3BviB,EAAU8X,OAAOkJ,EAAK1lB,EAAOzT,GAC7B,SAEAmY,EAAU1V,SAGb02B,GAAQA,EAAI94B,UAIjBW,EAAQusB,GAAQpV,EAAY,IAAI+gB,GAAUC,EAAKrjB,EAAQyX,EAAM9Z,GAC7DmnB,EAAWz4B,KAAKgW,IAJZrC,EAAOyX,GAAQ9Z,OAffmnB,EAAWz4B,KAAXy4B,MAAAA,EAAmB,EAAA,KAAKqB,gBAAgBnmB,EAAQiC,KAqBjD6iB,OAAAA,IAz+FE,CAAA,IAAA,SA4+Fb,MAAA,SAAO9kB,EAAQiC,GACP,GAA0B,IAA1B,KAAKmjB,YAAYniB,KAAjB,CAIE6hB,IAAAA,EAAa,KAAKe,kBAAkB7lB,EAAQiC,GAC9C6iB,OAAAA,EAAW15B,QACX3B,EAAS6mB,IAAI,KAAK6U,OAAQL,IACnB,QAFPA,EAJAxpB,OAAOW,OAAO+D,EAAQiC,OA9+FjB,EAAA,GAohGRmkB,SAAAA,GAAUjiB,EAAOkiB,GAChB7Y,IAAAA,EAAOrJ,GAASA,EAAM5D,SAAW,GACjClB,EAAUmO,EAAKnO,QACf1U,OAAmBZ,IAAbyjB,EAAK7iB,IAAoB07B,EAAkB,EACjD55B,OAAmB1C,IAAbyjB,EAAK/gB,IAAoB45B,EAAkB,EAChD,MAAA,CACHj9B,MAAOiW,EAAU5S,EAAM9B,EACvBtB,IAAKgW,EAAU1U,EAAM8B,GAoCpB65B,SAAAA,GAAwBt8B,EAAOu8B,GAC9BlrB,IAEFhQ,EAAGoU,EAFDpE,EAAO,GACPga,EAAWrrB,EAAMw8B,uBAAuBD,GAEzCl7B,IAAAA,EAAI,EAAGoU,EAAO4V,EAASjqB,OAAQC,EAAIoU,IAAQpU,EAC5CgQ,EAAKhP,KAAKgpB,EAAShqB,GAAGwU,OAEnBxE,OAAAA,EAGForB,SAAAA,GAAWC,EAAO/oB,EAAOgpB,EAASpmB,GACjClF,IAEFhQ,EAAGoU,EAAMG,EAAcgnB,EAFrBvrB,EAAOqrB,EAAMrrB,KACbwrB,EAA8B,WAAjBtmB,EAAQoD,KAEvBhG,GAAU,OAAVA,EAAAA,CAGCtS,IAAAA,EAAI,EAAGoU,EAAOpE,EAAKjQ,OAAQC,EAAIoU,IAAQpU,EAAG,CAEvCuU,IADJA,GAAgBvE,EAAKhQ,MACAs7B,EAAS,CACtBpmB,GAAAA,EAAQ0lB,IACR,SAEJ,MAEJW,EAAaF,EAAMzkB,OAAOrC,GACtBpB,GAAeooB,KAAgBC,GAAyB,IAAVlpB,GAAeoI,GAAKpI,KAAWoI,GAAK6gB,MAClFjpB,GAASipB,GAGVjpB,OAAAA,GAiBFmpB,SAAAA,GAAU3iB,EAAO0S,GAChBkQ,IAAAA,EAAU5iB,GAASA,EAAM5D,QAAQwmB,QAChCA,OAAAA,QAAwBh9B,IAAZg9B,QAAwCh9B,IAAf8sB,EAAK6P,MAe5CM,SAAAA,GAAiBC,EAAQC,EAAUC,GAClCC,IAAAA,EAAWH,EAAOC,KAAcD,EAAOC,GAAY,IAClDE,OAAAA,EAASD,KAAgBC,EAASD,GAAc,IAGlDE,SAAAA,GAAa3S,EAAY4S,GASzB,IAREt9B,IAAAA,EAA4B0qB,EAA5B1qB,MAAoB6sB,EAAQnC,EAArBG,YACRoS,EAASj9B,EAAMu9B,UAAYv9B,EAAMu9B,QAAU,IAC1C3S,EAAuCiC,EAAvCjC,OAAQ4S,EAA+B3Q,EAA/B2Q,OAAe5nB,EAAgBiX,EAAvBhX,MACjB4nB,EAAQ7S,EAAOH,KACfiT,EAAQF,EAAO/S,KACfrU,EAvBDunB,SAAYC,EAAYC,EAAYhR,GAClC+Q,OAAAA,EAAWzpB,GAAK,IAAM0pB,EAAW1pB,GAAK,IAAM0Y,EAAK6P,MAAQ,IAAM7P,EAAK1sB,KAsB/Dw9B,CAAY/S,EAAQ4S,EAAQ3Q,GAClCpX,EAAO6nB,EAAOl8B,OAEXC,EAAI,EAAGA,EAAIoU,IAAQpU,EAAG,CACrBC,IAAAA,EAAOg8B,EAAOj8B,GACJwU,EAAyBvU,EAAjCm8B,GAAwB9pB,EAASrS,EAAjBo8B,KACLp8B,EAAKi8B,UAAYj8B,EAAKi8B,QAAU,KAChCG,GAASV,GAAiBC,EAAQ7mB,EAAKP,IACpDD,GAAgBjC,GAIrBmqB,SAAAA,GAAgB99B,EAAOyqB,GACtBrQ,IAAAA,EAASpa,EAAMoa,OACd9I,OAAAA,OAAOD,KAAK+I,GAAQoU,OAAO,SAAApY,GAAOgE,OAAAA,EAAOhE,GAAKqU,OAASA,IAAMsT,QA6B/DC,SAAAA,GAAYnR,EAAM1rB,GAEFA,IAFS,EAETA,EAAAA,EADrBA,EAAQA,GAAS0rB,EAAKoR,SADQ,IAEF,IAAA,EAAA,MAAA,EAAA,EAAA,KAAA,MAAA,CAAjBX,IACDL,EADkB,EAAA,MACFM,QAClB,IAACN,QAAqCl9B,IAA3Bk9B,EAAOpQ,EAAK2Q,OAAOrpB,UAA4DpU,IAAvCk9B,EAAOpQ,EAAK2Q,OAAOrpB,IAAI0Y,EAAKhX,OAC/E,cAEGonB,EAAOpQ,EAAK2Q,OAAOrpB,IAAI0Y,EAAKhX,QAPT,MAAA,GAAA,EAAA,EAAA,GAAA,QAAA,EAAA,KAW5BqoB,IAAAA,GAAqB,SAACvkB,GAASA,MAAS,UAATA,GAA6B,SAATA,GACnDwkB,GAAmB,SAACC,EAAQC,GAAWA,OAAAA,EAASD,EAAS9sB,OAAOW,OAAO,GAAImsB,IAE3EE,GAnsGW,WAosGDt+B,SAAAA,EAAAA,EAAO4V,GAAc,EAAA,KAAA,GACxB5V,KAAAA,MAAQA,EACRu+B,KAAAA,KAAOv+B,EAAMsZ,IACbzD,KAAAA,MAAQD,EACR4oB,KAAAA,gBAAkB,GAClB3T,KAAAA,YAAc,KAAK4T,UACnBC,KAAAA,MAAQ,KAAK7T,YAAY1qB,KACzBoW,KAAAA,aAAUxW,EACV4+B,KAAAA,UAAW,EACXC,KAAAA,WAAQ7+B,EACR8+B,KAAAA,iBAAc9+B,EACdirB,KAAAA,oBAAiBjrB,EACjB++B,KAAAA,gBAAa/+B,EACbg/B,KAAAA,gBAAah/B,EACbi/B,KAAAA,qBAAsB,EACtBC,KAAAA,cAAWl/B,EACXm/B,KAAAA,aAptGI,OAAA,EAAA,EAAA,CAAA,CAAA,IAAA,aAutGb,MAAA,WACUt+B,IACAisB,EADK,KACKhC,YADL,KAERiG,YAFQ,KAGRqO,aACHtS,EAAKuS,SAAWtC,GAAUjQ,EAAK2Q,OAAQ3Q,GAJ5B,KAKRwS,gBA7tGM,CAAA,IAAA,cAguGb,MAAA,SAAYzpB,GACHC,KAAAA,MAAQD,IAjuGJ,CAAA,IAAA,aAouGb,MAAA,WACUhV,IAAAA,EAAK,KACLZ,EAAQY,EAAGZ,MACX6sB,EAAOjsB,EAAGiqB,YACViC,EAAUlsB,EAAG0+B,aACbC,EAAW,SAAC9U,EAAMpkB,EAAGwW,EAAG5Y,GAAMwmB,MAAS,MAATA,EAAepkB,EAAa,MAATokB,EAAexmB,EAAI4Y,GACpE2iB,EAAM3S,EAAK4S,QAAU5qB,GAAeiY,EAAQ2S,QAAS3B,GAAgB99B,EAAO,MAC5E0/B,EAAM7S,EAAK8S,QAAU9qB,GAAeiY,EAAQ6S,QAAS7B,GAAgB99B,EAAO,MAC5E4/B,EAAM/S,EAAKgT,QAAUhrB,GAAeiY,EAAQ+S,QAAS/B,GAAgB99B,EAAO,MAC5EyZ,EAAYoT,EAAKpT,UACjBqmB,EAAMjT,EAAKkT,QAAUR,EAAS9lB,EAAW+lB,EAAKE,EAAKE,GACnDI,EAAMnT,EAAKoT,QAAUV,EAAS9lB,EAAWimB,EAAKF,EAAKI,GACzD/S,EAAKqT,OAASt/B,EAAGu/B,cAAcX,GAC/B3S,EAAKuT,OAASx/B,EAAGu/B,cAAcT,GAC/B7S,EAAKwT,OAASz/B,EAAGu/B,cAAcP,GAC/B/S,EAAKjC,OAAShqB,EAAGu/B,cAAcL,GAC/BjT,EAAK2Q,OAAS58B,EAAGu/B,cAAcH,KApvGtB,CAAA,IAAA,aAuvGb,MAAA,WACW,OAAA,KAAKhgC,MAAMif,KAAKzG,SAAS,KAAK3C,SAxvG5B,CAAA,IAAA,UA2vGb,MAAA,WACW,OAAA,KAAK7V,MAAM+sB,eAAe,KAAKlX,SA5vG7B,CAAA,IAAA,gBA+vGb,MAAA,SAAcyqB,GACH,OAAA,KAAKtgC,MAAMoa,OAAOkmB,KAhwGhB,CAAA,IAAA,iBAmwGb,MAAA,SAAenmB,GACL0S,IAAAA,EAAO,KAAKhC,YACX1Q,OAAAA,IAAU0S,EAAKjC,OAChBiC,EAAK2Q,OACL3Q,EAAKjC,SAvwGF,CAAA,IAAA,QA0wGb,MAAA,WACS/pB,KAAAA,QAAQ,WA3wGJ,CAAA,IAAA,WA8wGb,MAAA,WACUgsB,IAAAA,EAAO,KAAKhC,YACd,KAAK+T,OACL1Y,GAAoB,KAAK0Y,MAAO,MAEhC/R,EAAKuS,UACLpB,GAAYnR,KApxGP,CAAA,IAAA,aAwxGb,MAAA,WACUjsB,IAAAA,EAAK,KACLksB,EAAUlsB,EAAG0+B,aACbrgB,EAAO6N,EAAQ7N,OAAS6N,EAAQ7N,KAAO,IACzC1K,GAAS0K,GACTre,EAAGg+B,MA7LN2B,SAAyBthB,GACxB5N,IAEFhQ,EAAGoU,EAAMW,EAFP/E,EAAOC,OAAOD,KAAK4N,GACnBuhB,EAAQ,IAAIniC,MAAMgT,EAAKjQ,QAExBC,IAAAA,EAAI,EAAGoU,EAAOpE,EAAKjQ,OAAQC,EAAIoU,IAAQpU,EACxC+U,EAAM/E,EAAKhQ,GACXm/B,EAAMn/B,GAAK,CACPgF,EAAG+P,EACHyG,EAAGoC,EAAK7I,IAGToqB,OAAAA,EAkLYD,CAAyBthB,GAC7Bre,EAAGg+B,QAAU3f,IAChBre,EAAGg+B,QACH1Y,GAAoBtlB,EAAGg+B,MAAOh+B,GAC9Bo9B,GAAYp9B,EAAGiqB,cAEf5L,GAAQ3N,OAAOmvB,aAAaxhB,IAC5BwG,GAAkBxG,EAAMre,GAE5BA,EAAGg+B,MAAQ3f,KAtyGN,CAAA,IAAA,cA0yGb,MAAA,WACUre,IACAisB,EADK,KACKhC,YADL,KAER6V,aAFQ,KAGJC,qBACH9T,EAAKC,QAAU,IAJR,KAIe6T,sBA/yGjB,CAAA,IAAA,wBAmzGb,MAAA,SAAsBC,GACZhgC,IAAAA,EAAK,KACLisB,EAAOjsB,EAAGiqB,YACViC,EAAUlsB,EAAG0+B,aACfuB,GAAe,EACnBjgC,EAAG8/B,aACH7T,EAAKuS,SAAWtC,GAAUjQ,EAAK2Q,OAAQ3Q,GACnCA,EAAK6P,QAAU5P,EAAQ4P,QACvBmE,GAAe,EACf7C,GAAYnR,GACZA,EAAK6P,MAAQ5P,EAAQ4P,OAEzB97B,EAAGkgC,gBAAgBF,GACfC,GACAxD,GAAaz8B,EAAIisB,EAAKoR,WAj0GjB,CAAA,IAAA,YAq0Gb,MAAA,WACUr9B,IAAAA,EAAK,KACLs6B,EAASt6B,EAAGZ,MAAMk7B,OAClB6F,EAAY7F,EAAO8F,iBAAiBpgC,EAAG89B,OACvCuC,EAAS/F,EAAOgG,gBAAgBtgC,EAAG0+B,aAAcyB,GAAW,GAClEngC,EAAG2V,QAAU2kB,EAAOiG,eAAeF,EAAQrgC,EAAG6f,cAC9C7f,EAAG+9B,SAAW/9B,EAAG2V,QAAQyD,UA30GhB,CAAA,IAAA,QA80Gb,MAAA,SAAM5a,EAAOgiC,GACHxgC,IAMFS,EAAGmB,EAAK86B,EANN18B,EAAK,KACSisB,EAAqBjsB,EAAlCiqB,YAA0B5L,EAAQre,EAAfg+B,MACnBhU,EAAoBiC,EAApBjC,OAAQwU,EAAYvS,EAAZuS,SACT3B,EAAQ7S,EAAOH,KACjB4W,EAAmB,IAAVjiC,GAAegiC,IAAUniB,EAAK7d,QAAgByrB,EAAKlC,QAC5D2W,EAAOliC,EAAQ,GAAKytB,EAAKoR,QAAQ7+B,EAAQ,GAEzCwB,IAAgB,IAAhBA,EAAG+9B,SACH9R,EAAKoR,QAAUhf,EACf4N,EAAKlC,SAAU,MACZ,CAEC2S,EADA93B,GAAQyZ,EAAK7f,IACJwB,EAAG2gC,eAAe1U,EAAM5N,EAAM7f,EAAOgiC,GACvC7sB,GAAS0K,EAAK7f,IACZwB,EAAG4gC,gBAAgB3U,EAAM5N,EAAM7f,EAAOgiC,GAEtCxgC,EAAG6gC,mBAAmB5U,EAAM5N,EAAM7f,EAAOgiC,GAGjD//B,IAAAA,EAAI,EAAGA,EAAI+/B,IAAS//B,EACrBwrB,EAAKoR,QAAQ58B,EAAIjC,GAASoD,EAAM86B,EAAOj8B,GACnCggC,KAHgD,OAAf7+B,EAAIi7B,IAAoB6D,GAAQ9+B,EAAIi7B,GAAS6D,EAAK7D,MAK/E4D,GAAS,GAEbC,EAAO9+B,GAGfqqB,EAAKlC,QAAU0W,EAEfjC,GACA/B,GAAaz8B,EAAI08B,KA92GZ,CAAA,IAAA,qBAk3Gb,MAAA,SAAmBzQ,EAAM5N,EAAM7f,EAAOgiC,GAC3BxW,IAMHvpB,EAAGoU,EAAMI,EANN+U,EAAkBiC,EAAlBjC,OAAQ4S,EAAU3Q,EAAV2Q,OACTC,EAAQ7S,EAAOH,KACfiT,EAAQF,EAAO/S,KACfiX,EAAS9W,EAAO+W,YAChBC,EAAchX,IAAW4S,EACzBF,EAAS,IAAIj/B,MAAM+iC,GAEpB//B,IAAAA,EAAI,EAAGoU,EAAO2rB,EAAO//B,EAAIoU,IAAQpU,EAAG,CAAA,IAAA,EACrCwU,EAAQxU,EAAIjC,EACZk+B,EAAOj8B,IACFo8B,EAAAA,EAAAA,GAAAA,EAAQmE,GAAehX,EAAOiX,MAAMH,EAAO7rB,GAAQA,IACnD6nB,EAAAA,EAAAA,EAAQF,EAAOqE,MAAM5iB,EAAKpJ,GAAQA,IAFvC,GAKGynB,OAAAA,IAj4GE,CAAA,IAAA,iBAo4Gb,MAAA,SAAezQ,EAAM5N,EAAM7f,EAAOgiC,GACvBlB,IAEH7+B,EAAGoU,EAAMI,EAAOvU,EAFb4+B,EAAkBrT,EAAlBqT,OAAQE,EAAUvT,EAAVuT,OACT9C,EAAS,IAAIj/B,MAAM+iC,GAEpB//B,IAAAA,EAAI,EAAGoU,EAAO2rB,EAAO//B,EAAIoU,IAAQpU,EAElCC,EAAO2d,EADPpJ,EAAQxU,EAAIjC,GAEZk+B,EAAOj8B,GAAK,CACRgF,EAAG65B,EAAO2B,MAAMvgC,EAAK,GAAIuU,GACzBgH,EAAGujB,EAAOyB,MAAMvgC,EAAK,GAAIuU,IAG1BynB,OAAAA,IAh5GE,CAAA,IAAA,kBAm5Gb,MAAA,SAAgBzQ,EAAM5N,EAAM7f,EAAOgiC,GACxBlB,IAGH7+B,EAAGoU,EAAMI,EAAOvU,EAHb4+B,EAAkBrT,EAAlBqT,OAAQE,EAAUvT,EAAVuT,OAC0B,EAAA,KAAKzB,SAAvCmD,EAAAA,EAAAA,SAAAA,OAAW,IAAA,EAAA,IAFoB,EAEfC,EAAAA,EAAAA,SAAAA,OAAW,IAAA,EAAA,IAFI,EAGhCzE,EAAS,IAAIj/B,MAAM+iC,GAEpB//B,IAAAA,EAAI,EAAGoU,EAAO2rB,EAAO//B,EAAIoU,IAAQpU,EAElCC,EAAO2d,EADPpJ,EAAQxU,EAAIjC,GAEZk+B,EAAOj8B,GAAK,CACRgF,EAAG65B,EAAO2B,MAAMzqB,GAAiB9V,EAAMwgC,GAAWjsB,GAClDgH,EAAGujB,EAAOyB,MAAMzqB,GAAiB9V,EAAMygC,GAAWlsB,IAGnDynB,OAAAA,IAh6GE,CAAA,IAAA,YAm6Gb,MAAA,SAAUznB,GACC,OAAA,KAAKgV,YAAYoT,QAAQpoB,KAp6GvB,CAAA,IAAA,iBAu6Gb,MAAA,SAAeA,GACJ,OAAA,KAAKgV,YAAY5L,KAAKpJ,KAx6GpB,CAAA,IAAA,aA26Gb,MAAA,SAAWsE,EAAOmjB,EAAQ3jB,GAChB3Z,IAAAA,EAAQ,KAAKA,MACb6sB,EAAO,KAAKhC,YACZlX,EAAQ2pB,EAAOnjB,EAAMsQ,MAKpBgS,OAAAA,GAJO,CACVprB,KAAMirB,GAAwBt8B,GAAO,GACrCiY,OAAQqlB,EAAOC,QAAQpjB,EAAMsQ,OAER9W,EAAOkZ,EAAKhX,MAAO,CAAC8D,KAAAA,MAn7GpC,CAAA,IAAA,wBAs7Gb,MAAA,SAAsBrU,EAAO6U,EAAOmjB,EAAQZ,GAClCsF,IAAAA,EAAc1E,EAAOnjB,EAAMsQ,MAC7B9W,EAAwB,OAAhBquB,EAAuBC,IAAMD,EACnC/pB,EAASykB,GAASY,EAAOC,QAAQpjB,EAAMsQ,MACzCiS,GAASzkB,IACTykB,EAAMzkB,OAASA,EACf3S,EAAM3E,IAAMD,KAAKC,IAAI2E,EAAM3E,IAAKgT,GAChCrO,EAAM7C,IAAM/B,KAAK+B,IAAI6C,EAAM7C,IAAKkR,GAChCA,EAAQ8oB,GAAWC,EAAOsF,EAAa,KAAKnX,YAAYhV,MAAO,CAAComB,KAAK,KAEzE32B,EAAM3E,IAAMD,KAAKC,IAAI2E,EAAM3E,IAAKgT,GAChCrO,EAAM7C,IAAM/B,KAAK+B,IAAI6C,EAAM7C,IAAKkR,KAj8GvB,CAAA,IAAA,YAo8Gb,MAAA,SAAUwG,EAAO+nB,GACPthC,IASFS,EAAGsS,EAAO2pB,EAAQV,EAThBh8B,EAAK,KACLisB,EAAOjsB,EAAGiqB,YACVoT,EAAUpR,EAAKoR,QACfoD,EAASxU,EAAKlC,SAAWxQ,IAAU0S,EAAKjC,OACxCnV,EAAOwoB,EAAQ78B,OACf+gC,EAAavhC,EAAGwhC,eAAejoB,GAC/BuiB,EAAQwF,GAAYrV,EAAKuS,UAAY,CAAC/tB,KAAMirB,GAAwB17B,EAAGZ,OAAO,GAAOiY,OAAQ,MAC7F3S,EAAQ,CAAC3E,IAAK8T,OAAOgH,kBAAmBhZ,IAAKgS,OAAO4tB,mBACnBC,EAtVtCA,SAAcnoB,GACwBA,IAAAA,EAAAA,EAAMmoB,gBAA1C3hC,EAAAA,EAAAA,IAAK8B,EAAAA,EAAAA,IAAK8/B,EAAAA,EAAAA,WAAYC,EAAAA,EAAAA,WACtB,MAAA,CACH7hC,IAAK4hC,EAAa5hC,EAAM8T,OAAO4tB,kBAC/B5/B,IAAK+/B,EAAa//B,EAAMgS,OAAOgH,mBAkVQ6mB,CAAcH,GAAzCM,EAAL9hC,EAAAA,IAAoB+hC,EAALjgC,EAAAA,IAGbkgC,SAAAA,IAIE,OAHPrF,EAASW,EAAQ58B,GACjBsS,EAAQ2pB,EAAOnjB,EAAMsQ,MACrBmS,EAAaU,EAAO6E,EAAW1X,OACvBjW,GAAeb,IAAU8uB,EAAW7F,GAAc8F,EAAW9F,EAGpEv7B,IAAAA,EAAI,EAAGA,EAAIoU,IACRktB,MAGJ/hC,EAAGgiC,sBAAsBt9B,EAAO6U,EAAOmjB,EAAQZ,IAC3C2E,MALgBhgC,GASpBggC,GAAAA,EACKhgC,IAAAA,EAAIoU,EAAO,EAAGpU,GAAK,IAAKA,EACrBshC,IAAAA,IAAAA,CAGJ/hC,EAAGgiC,sBAAsBt9B,EAAO6U,EAAOmjB,EAAQZ,GAC/C,MAGDp3B,OAAAA,IAz+GE,CAAA,IAAA,qBA4+Gb,MAAA,SAAmB6U,GACTmjB,IAEFj8B,EAAGoU,EAAM9B,EAFP2pB,EAAS,KAAKzS,YAAYoT,QAC1BhmB,EAAS,GAEV5W,IAAAA,EAAI,EAAGoU,EAAO6nB,EAAOl8B,OAAQC,EAAIoU,IAAQpU,EAC1CsS,EAAQ2pB,EAAOj8B,GAAG8Y,EAAMsQ,MACpBjW,GAAeb,IACfsE,EAAO5V,KAAKsR,GAGbsE,OAAAA,IAt/GE,CAAA,IAAA,iBAy/Gb,MAAA,WACW,OAAA,IA1/GE,CAAA,IAAA,mBA6/Gb,MAAA,SAAiBpC,GACPjV,IACAisB,EADK,KACKhC,YACVD,EAASiC,EAAKjC,OACd4S,EAAS3Q,EAAK2Q,OACdF,EAJK,KAIOuF,UAAUhtB,GACrB,MAAA,CACHitB,MAAOlY,EAAS,GAAKA,EAAOmY,iBAAiBzF,EAAO1S,EAAOH,OAAS,GACpE9W,MAAO6pB,EAAS,GAAKA,EAAOuF,iBAAiBzF,EAAOE,EAAO/S,OAAS,MArgH/D,CAAA,IAAA,UAygHb,MAAA,SAAQ9Q,GACE/Y,IA7dE+S,EACR6iB,EAAGvyB,EAAGZ,EAAGgB,EA4dHzD,EAAK,KACLisB,EAAOjsB,EAAGiqB,YAChBjqB,EAAGkwB,YACHlwB,EAAG49B,gBAAkB,GACrB59B,EAAGuvB,OAAOxW,GAAQ,WAClBkT,EAAKmW,OAheLzuB,GAFQZ,EAkeYkB,GAAejU,EAAG2V,QAAQmM,KAhf7CugB,SAAY/C,EAAQE,EAAQ/D,GAC7BA,IAAoB,IAApBA,EACO,OAAA,EAELh2B,IAAAA,EAAI+1B,GAAU8D,EAAQ7D,GACtBxf,EAAIuf,GAAUgE,EAAQ/D,GACrB,MAAA,CACH9Z,IAAK1F,EAAExd,IACPG,MAAO6G,EAAEhH,IACTmjB,OAAQ3F,EAAEzd,MACVG,KAAM8G,EAAEjH,OAse4C6jC,CAAYpW,EAAKqT,OAAQrT,EAAKuT,OAAQx/B,EAAGsiC,qBA/d7F1M,EAAI7iB,EAAM4O,IACVte,EAAI0P,EAAMnU,MACV6D,EAAIsQ,EAAM6O,OACVne,EAAIsP,EAAMpU,MAEVi3B,EAAIvyB,EAAIZ,EAAIgB,EAAIsP,EAEb,CACH4O,IAAKiU,EACLh3B,MAAOyE,EACPue,OAAQnf,EACR9D,KAAM8E,MA3jGG,CAAA,IAAA,SAkhHb,MAAA,SAAOsV,MAlhHM,CAAA,IAAA,OAqhHb,MAAA,WACU/Y,IASFS,EATET,EAAK,KACL0Y,EAAM1Y,EAAG29B,KACTv+B,EAAQY,EAAGZ,MACX6sB,EAAOjsB,EAAGiqB,YACVhS,EAAWgU,EAAK5N,MAAQ,GACxBoD,EAAOriB,EAAM0rB,UACbkP,EAAS,GACTx7B,EAAQwB,EAAGk+B,YAAc,EACzBsC,EAAQxgC,EAAGm+B,YAAelmB,EAASzX,OAAShC,EAK7CiC,IAHDwrB,EAAKC,SACLD,EAAKC,QAAQvrB,KAAK+X,EAAK+I,EAAMjjB,EAAOgiC,GAEnC//B,EAAIjC,EAAOiC,EAAIjC,EAAQgiC,IAAS//B,EAAG,CAC9B4lB,IAAAA,EAAUpO,EAASxX,GACrB4lB,EAAQ2T,OACRA,EAAOv4B,KAAK4kB,GAEZA,EAAQ1lB,KAAK+X,EAAK+I,GAGrBhhB,IAAAA,EAAI,EAAGA,EAAIu5B,EAAOx5B,SAAUC,EAC7Bu5B,EAAOv5B,GAAGE,KAAK+X,EAAK+I,KA5iHf,CAAA,IAAA,WAgjHb,MAAA,SAASxM,EAAO+kB,GACNjhB,IAAAA,EAAOihB,EAAS,SAAW,UAC1B/kB,YAAU9V,IAAV8V,GAAuB,KAAKgV,YAAYiC,QACzC,KAAKqW,6BAA6BxpB,GAClC,KAAKypB,0BAA0BvtB,GAAS,EAAG8D,KApjHxC,CAAA,IAAA,aAujHb,MAAA,SAAW9D,EAAO+kB,EAAQjhB,GAChB/Y,IAEF8X,EAFE9X,EAAK,KACLksB,EAAUlsB,EAAG0+B,aAEfzpB,GAAAA,GAAS,GAAKA,EAAQjV,EAAGiqB,YAAY5L,KAAK7d,OAAQ,CAC5C6lB,IAAAA,EAAUrmB,EAAGiqB,YAAY5L,KAAKpJ,IACpC6C,EAAUuO,EAAQgY,WACbhY,EAAQgY,SAtZhBoE,SAAkB5c,EAAQ5Q,EAAOoR,GAC/B3V,OAAAA,OAAOW,OAAOX,OAAO2E,OAAOwQ,GAAS,CACxCmU,QAAQ,EACR0I,UAAWztB,EACXynB,YAAQv9B,EACRwjC,SAAKxjC,EACLknB,QAAAA,EACApR,MAAAA,EACA8D,KAAM,UACNxZ,KAAM,SA6YsBkjC,CAAkBziC,EAAG6f,aAAc5K,EAAOoR,KAC1DqW,OAAS18B,EAAGiiC,UAAUhtB,GAC9B6C,EAAQ6qB,IAAMzW,EAAQ7N,KAAKpJ,QAE3B6C,EAAU9X,EAAGq+B,WACRr+B,EAAGq+B,SAxaXuE,SAAqB/c,EAAQ5Q,GAC3BvE,OAAAA,OAAOW,OAAOX,OAAO2E,OAAOwQ,GAC/B,CACImU,QAAQ,EACR9N,aAAS/sB,EACT6V,aAAcC,EACdA,MAAAA,EACA8D,KAAM,UACNxZ,KAAM,YAgaaqjC,CAAqB5iC,EAAGZ,MAAMygB,aAAc7f,EAAGiV,SAC1DiX,QAAUA,EAIfpU,OAFPA,EAAQkiB,SAAWA,EACnBliB,EAAQiB,KAAOA,EACRjB,IAxkHE,CAAA,IAAA,+BA2kHb,MAAA,SAA6BiB,GAClB,OAAA,KAAK8pB,uBAAuB,KAAK9C,mBAAmBxsB,GAAIwF,KA5kHtD,CAAA,IAAA,4BA+kHb,MAAA,SAA0B9D,EAAO8D,GACtB,OAAA,KAAK8pB,uBAAuB,KAAKC,gBAAgBvvB,GAAIwF,EAAM9D,KAhlHzD,CAAA,IAAA,yBAmlHb,MAAA,SAAuB8tB,GAAahqB,IAAAA,EAAO,UAAA,OAAA,QAAA,IAAA,UAAA,GAAA,UAAA,GAAA,UAAW9D,EAAO,UAAA,OAAA,EAAA,UAAA,QAAA,EACnDjV,EAAK,KACLg6B,EAAkB,WAATjhB,EACT+F,EAAQ9e,EAAG49B,gBACXoF,EAAWD,EAAc,IAAMhqB,EAC/BykB,EAAS1e,EAAMkkB,GACfC,EAAUjjC,EAAGo+B,qBAAuBxnB,GAAQ3B,GAC9CuoB,GAAAA,EACOD,OAAAA,GAAiBC,EAAQyF,GAE9B3I,IAAAA,EAASt6B,EAAGZ,MAAMk7B,OAClB6F,EAAY7F,EAAO4I,wBAAwBljC,EAAG89B,MAAOiF,GACrDI,EAAWnJ,EAAS,CAAI+I,GAAAA,OAAAA,EAAoB,SAAA,QAASA,EAAa,IAAM,CAACA,EAAa,IACtF1C,EAAS/F,EAAOgG,gBAAgBtgC,EAAG0+B,aAAcyB,GACjDr5B,EAAQ4J,OAAOD,KAAK8G,GAASU,SAAS8qB,IAEtC1rB,EAASijB,EAAO8I,oBAAoB/C,EAAQv5B,EADlC,WAAM9G,OAAAA,EAAG6f,WAAW5K,EAAO+kB,IACuBmJ,GAK3D9rB,OAJHA,EAAO0jB,UACP1jB,EAAO0jB,QAAUkI,EACjBnkB,EAAMkkB,GAAYtyB,OAAO6gB,OAAOgM,GAAiBlmB,EAAQ4rB,KAEtD5rB,IAxmHE,CAAA,IAAA,qBA2mHb,MAAA,SAAmBpC,EAAOouB,EAAYrJ,GAC5Bh6B,IAQF2V,EARE3V,EAAK,KACLZ,EAAQY,EAAGZ,MACX0f,EAAQ9e,EAAG49B,gBACXoF,EAAwBK,aAAAA,OAAAA,GACxB7F,EAAS1e,EAAMkkB,GACjBxF,GAAAA,EACOA,OAAAA,EAGPp+B,IAA4B,IAA5BA,EAAMuW,QAAQ8B,UAAqB,CAC7B6iB,IAAAA,EAASt6B,EAAGZ,MAAMk7B,OAClB6F,EAAY7F,EAAOgJ,0BAA0BtjC,EAAG89B,MAAOuF,GACvDhD,EAAS/F,EAAOgG,gBAAgBtgC,EAAG0+B,aAAcyB,GACvDxqB,EAAU2kB,EAAOiG,eAAeF,EAAQrgC,EAAG6f,WAAW5K,EAAO+kB,EAAQqJ,IAEnEnJ,IAAAA,EAAa,IAAIG,GAAWj7B,EAAOuW,GAAWA,EAAQukB,YAIrDA,OAHHvkB,GAAWA,EAAQ4tB,aACnBzkB,EAAMkkB,GAAYtyB,OAAO6gB,OAAO2I,IAE7BA,IA/nHE,CAAA,IAAA,mBAkoHb,MAAA,SAAiBvkB,GACT,GAACA,EAAQolB,QAGN,OAAA,KAAK3Q,iBAAmB,KAAKA,eAAiB1Z,OAAOW,OAAO,GAAIsE,MAtoH9D,CAAA,IAAA,iBAyoHb,MAAA,SAAeoD,EAAMyqB,GACV,OAACA,GAAiBlG,GAAmBvkB,IAAS,KAAK3Z,MAAMqkC,sBA1oHvD,CAAA,IAAA,gBA6oHb,MAAA,SAAcpd,EAASpR,EAAO6kB,EAAY/gB,GAClCukB,GAAmBvkB,GACnBrI,OAAOW,OAAOgV,EAASyT,GAElB4J,KAAAA,mBAAmBzuB,EAAO8D,GAAMwW,OAAOlJ,EAASyT,KAjpHhD,CAAA,IAAA,sBAqpHb,MAAA,SAAoB0J,EAAezqB,EAAM8hB,GACjC2I,IAAkBlG,GAAmBvkB,IAChC2qB,KAAAA,wBAAmBvkC,EAAW4Z,GAAMwW,OAAOiU,EAAe3I,KAvpH1D,CAAA,IAAA,YA2pHb,MAAA,SAAUxU,EAASpR,EAAO8D,EAAMihB,GAC5B3T,EAAQ2T,OAASA,EACXrkB,IAAAA,EAAU,KAAK2Q,SAASrR,EAAO+kB,GAChC0J,KAAAA,mBAAmBzuB,EAAO8D,EAAMihB,GAAQzK,OAAOlJ,EAAS,CACzD1Q,SAAWqkB,GAAU,KAAK2J,iBAAiBhuB,IAAaA,MA/pHnD,CAAA,IAAA,mBAmqHb,MAAA,SAAiB0Q,EAASrR,EAAcC,GAC/B2uB,KAAAA,UAAUvd,EAASpR,EAAO,UAAU,KApqHhC,CAAA,IAAA,gBAuqHb,MAAA,SAAcoR,EAASrR,EAAcC,GAC5B2uB,KAAAA,UAAUvd,EAASpR,EAAO,UAAU,KAxqHhC,CAAA,IAAA,2BA2qHb,MAAA,WACUoR,IAAAA,EAAU,KAAK4D,YAAYiC,QAC7B7F,GACKud,KAAAA,UAAUvd,OAASlnB,EAAW,UAAU,KA9qHxC,CAAA,IAAA,wBAkrHb,MAAA,WACUknB,IAAAA,EAAU,KAAK4D,YAAYiC,QAC7B7F,GACKud,KAAAA,UAAUvd,OAASlnB,EAAW,UAAU,KArrHxC,CAAA,IAAA,kBAyrHb,MAAA,SAAgB6gC,GACNhgC,IAAAA,EAAK,KACL6jC,EAAU7jC,EAAGiqB,YAAY5L,KAAK7d,OAC9BsjC,EAAU9jC,EAAGg+B,MAAMx9B,OACrBsjC,EAAUD,EACV7jC,EAAG+jC,gBAAgBF,EAASC,EAAUD,EAAS7D,GACxC8D,EAAUD,GACjB7jC,EAAGgkC,gBAAgBF,EAASD,EAAUC,GAEpCtD,IAAAA,EAAQ1gC,KAAKC,IAAI+jC,EAASD,GAC5BrD,GACAxgC,EAAGihC,MAAM,EAAGT,KApsHP,CAAA,IAAA,kBAwsHb,MAAA,SAAgBhiC,EAAOgiC,GAAOR,IAKtBv/B,EALsBu/B,IAAmB,UAAA,OAAA,QAAA,IAAA,UAAA,KAAA,UAAA,GACvChgC,EAAK,KACLisB,EAAOjsB,EAAGiqB,YACV5L,EAAO4N,EAAK5N,KACZ5f,EAAMD,EAAQgiC,EAEdyD,EAAO,SAACC,GAELzjC,IADLyjC,EAAI1jC,QAAUggC,EACT//B,EAAIyjC,EAAI1jC,OAAS,EAAGC,GAAKhC,EAAKgC,IAC/ByjC,EAAIzjC,GAAKyjC,EAAIzjC,EAAI+/B,IAIpB//B,IADLwjC,EAAK5lB,GACA5d,EAAIjC,EAAOiC,EAAIhC,IAAOgC,EACvB4d,EAAK5d,GAAK,IAAIT,EAAG8iC,gBAEjB9iC,EAAG+9B,UACHkG,EAAKhY,EAAKoR,SAEdr9B,EAAGihC,MAAMziC,EAAOgiC,GACZR,GACAhgC,EAAGmkC,eAAe9lB,EAAM7f,EAAOgiC,EAAO,WA7tHjC,CAAA,IAAA,iBAiuHb,MAAA,SAAena,EAAS7nB,EAAOgiC,EAAOznB,MAjuHzB,CAAA,IAAA,kBAouHb,MAAA,SAAgBva,EAAOgiC,GACbxgC,IACAisB,EADK,KACKhC,YACZjqB,GAFO,KAEJ+9B,SAAU,CACPqG,IAAAA,EAAUnY,EAAKoR,QAAQ/d,OAAO9gB,EAAOgiC,GACvCvU,EAAKuS,UACLpB,GAAYnR,EAAMmY,GAG1BnY,EAAK5N,KAAKiB,OAAO9gB,EAAOgiC,KA7uHf,CAAA,IAAA,cAgvHb,MAAA,WACUA,IAAAA,EAAQ6D,UAAU7jC,OACnBujC,KAAAA,gBAAgB,KAAKrF,aAAargB,KAAK7d,OAASggC,EAAOA,KAlvHnD,CAAA,IAAA,aAqvHb,MAAA,WACSwD,KAAAA,gBAAgB,KAAK/Z,YAAY5L,KAAK7d,OAAS,EAAG,KAtvH9C,CAAA,IAAA,eAyvHb,MAAA,WACSwjC,KAAAA,gBAAgB,EAAG,KA1vHf,CAAA,IAAA,gBA6vHb,MAAA,SAAcxlC,EAAOgiC,GACZwD,KAAAA,gBAAgBxlC,EAAOgiC,GACvBuD,KAAAA,gBAAgBvlC,EAAO6lC,UAAU7jC,OAAS,KA/vHtC,CAAA,IAAA,iBAkwHb,MAAA,WACSujC,KAAAA,gBAAgB,EAAGM,UAAU7jC,YAnwHzB,EAAA,GAuwHjBk9B,GAAkBnmB,SAAW,GAC7BmmB,GAAkBhgC,UAAUqiC,mBAAqB,KACjDrC,GAAkBhgC,UAAUolC,gBAAkB,KAExCwB,IAAAA,GA3wHW,WA4wHC,SAAA,IAAA,EAAA,KAAA,GACL7+B,KAAAA,OAAItG,EACJ8c,KAAAA,OAAI9c,EACJ66B,KAAAA,QAAS,EACTrkB,KAAAA,aAAUxW,EACV67B,KAAAA,iBAAc77B,EAjxHV,OAAA,EAAA,EAAA,CAAA,CAAA,IAAA,kBAoxHb,MAAA,SAAgB0rB,GACG,IAAA,EAAA,KAAK0Z,SAAS,CAAC,IAAK,KAAM1Z,GAClC,MAAA,CAACplB,EADDA,EAAAA,EACIwW,EADDA,EAAAA,KArxHD,CAAA,IAAA,WAyxHb,MAAA,WACWH,OAAAA,GAAS,KAAKrW,IAAMqW,GAAS,KAAKG,KA1xHhC,CAAA,IAAA,WA6xHb,MAAA,SAASyQ,EAAO8X,GACNxkC,IAAAA,EAAK,KACLX,EAAQ,KAAK27B,YACf,IAACwJ,IAAUnlC,EACJW,OAAAA,EAEL4R,IAAAA,EAAM,GAILA,OAHP8a,EAAM9sB,QAAQ,SAAAitB,GACVjb,EAAIib,GAAQxtB,EAAMwtB,IAASxtB,EAAMwtB,GAAMmN,SAAW36B,EAAMwtB,GAAMuM,IAAMp5B,EAAG6sB,KAEpEjb,MAvyHE,EAAA,GA2yHjB0yB,GAAQ/sB,SAAW,GACnB+sB,GAAQG,mBAAgBtlC,EAElBulC,IAAAA,GAAY,IAAI1lC,IAab2lC,SAAAA,GAAaC,EAAKC,EAAQlvB,GACxBmvB,OAZFA,SAAgBD,EAAQlvB,GAC7BA,EAAUA,GAAW,GACfqtB,IAAAA,EAAW6B,EAASE,KAAKC,UAAUrvB,GACrCsvB,EAAYP,GAAUxjC,IAAI8hC,GAKvBiC,OAJFA,IACDA,EAAY,IAAIC,KAAKC,aAAaN,EAAQlvB,GAC1C+uB,GAAUrjC,IAAI2hC,EAAUiC,IAErBA,EAIAH,CAAgBD,EAAQlvB,GAASyvB,OAAOR,GAG7CS,IAAAA,GAAa,CACfhuB,OAAOtE,SAAAA,GACInO,OAAAA,GAAQmO,GAASA,EAAQ,GAAKA,GAEzCuyB,QAAQC,SAAAA,EAAWtwB,EAAOuwB,GAClBD,GAAc,IAAdA,EACO,MAAA,IAELV,IACFY,EADEZ,EAAS,KAAKzlC,MAAMuW,QAAQkvB,OAE9Ba,EAAQH,EACRC,GAAAA,EAAMhlC,OAAS,EAAG,CACZmlC,IAAAA,EAAU7lC,KAAK+B,IAAI/B,KAAKqc,IAAIqpB,EAAM,GAAGzyB,OAAQjT,KAAKqc,IAAIqpB,EAAMA,EAAMhlC,OAAS,GAAGuS,SAChF4yB,EAAU,MAAQA,EAAU,QAC5BF,EAAW,cAEfC,EAoBHE,SAAeL,EAAWC,GAC3BE,IAAAA,EAAQF,EAAMhlC,OAAS,EAAIglC,EAAM,GAAGzyB,MAAQyyB,EAAM,GAAGzyB,MAAQyyB,EAAM,GAAGzyB,MAAQyyB,EAAM,GAAGzyB,MACvFjT,KAAKqc,IAAIupB,GAAS,GAAKH,IAAczlC,KAAKyb,MAAMgqB,KAChDG,EAAQH,EAAYzlC,KAAKyb,MAAMgqB,IAE5BG,OAAAA,EAzBSE,CAAeL,EAAWC,GAEhCK,IAAAA,EAAW3qB,GAAMpb,KAAKqc,IAAIupB,IAC1BI,EAAahmC,KAAK+B,IAAI/B,KAAKC,KAAK,EAAID,KAAKyb,MAAMsqB,GAAW,IAAK,GAC/DlwB,EAAU,CAAC8vB,SAAAA,EAAUM,sBAAuBD,EAAYE,sBAAuBF,GAE9EnB,OADPj0B,OAAOW,OAAOsE,EAAS,KAAKA,QAAQ6vB,MAAMJ,QACnCT,GAAaY,EAAWV,EAAQlvB,IAE3CswB,YAAYV,SAAAA,EAAWtwB,EAAOuwB,GACtBD,GAAc,IAAdA,EACO,MAAA,IAELhM,IAAAA,EAASgM,EAAazlC,KAAKwb,IAAI,GAAIxb,KAAKyb,MAAML,GAAMqqB,KACtDhM,OAAW,IAAXA,GAA2B,IAAXA,GAA2B,IAAXA,EACzB8L,GAAWC,QAAQ1nC,KAAK,KAAM2nC,EAAWtwB,EAAOuwB,GAEpD,KAYXU,IAAAA,GAAQ,CAACb,WAAAA,IA8DJc,SAAAA,GAAS5sB,EAAOisB,GACfY,IAAAA,EAAW7sB,EAAM5D,QAAQ6vB,MACzBa,EAAaD,EAASE,eAyBvBC,SAAkBhtB,GACjBitB,IAAAA,EAASjtB,EAAM5D,QAAQ6wB,OACvBC,EAAaltB,EAAMmtB,YACnBC,EAAWptB,EAAMqtB,QAAUH,GAAcD,EAAS,EAAI,GACtDK,EAAWttB,EAAMutB,WAAaL,EAC7B3mC,OAAAA,KAAKyb,MAAMzb,KAAKC,IAAI4mC,EAAUE,IA9BQN,CAAkBhtB,GACzDwtB,EAAeX,EAASY,MAAMC,QAgD/BC,SAAgB1B,GACf7pB,IACFlb,EAAGoU,EADD8G,EAAS,GAEVlb,IAAAA,EAAI,EAAGoU,EAAO2wB,EAAMhlC,OAAQC,EAAIoU,EAAMpU,IACnC+kC,EAAM/kC,GAAGumC,OACTrrB,EAAOla,KAAKhB,GAGbkb,OAAAA,EAxDuCurB,CAAgB1B,GAAS,GACjE2B,EAAkBJ,EAAavmC,OAC/B4mC,EAAQL,EAAa,GACrBM,EAAON,EAAaI,EAAkB,GACtCG,EAAW,GACbH,GAAAA,EAAkBd,EAEXiB,OAoDNC,SAAW/B,EAAO8B,EAAUP,EAAcS,GAC3ChH,IAEA//B,EAFA+/B,EAAQ,EACRiH,EAAOV,EAAa,GAGnBtmC,IADL+mC,EAAU1nC,KAAK4nC,KAAKF,GACf/mC,EAAI,EAAGA,EAAI+kC,EAAMhlC,OAAQC,IACtBA,IAAMgnC,IACNH,EAAS7lC,KAAK+jC,EAAM/kC,IAEpBgnC,EAAOV,IADPvG,EAC4BgH,IA9DhCD,CAAW/B,EAAO8B,EAAUP,EAAcI,EAAkBd,GACrDiB,EAELE,IAAAA,EAuBDG,SAAiBZ,EAAcvB,EAAOa,GACrCuB,IAAAA,EAgEDC,SAAe3D,GACdryB,IACFpR,EAAGqnC,EADDj2B,EAAMqyB,EAAI1jC,OAEZqR,GAAAA,EAAM,EACC,OAAA,EAENi2B,IAAAA,EAAO5D,EAAI,GAAIzjC,EAAI,EAAGA,EAAIoR,IAAOpR,EAC9ByjC,GAAAA,EAAIzjC,GAAKyjC,EAAIzjC,EAAI,KAAOqnC,EACjB,OAAA,EAGRA,OAAAA,EA3EkBD,CAAed,GAClCS,EAAUhC,EAAMhlC,OAAS6lC,EAC3B,IAACuB,EACM9nC,OAAAA,KAAK+B,IAAI2lC,EAAS,GAGxB,IADCO,IAAAA,EAAUrsB,GAAWksB,GAClBnnC,EAAI,EAAGoU,EAAOkzB,EAAQvnC,OAAS,EAAGC,EAAIoU,EAAMpU,IAAK,CAChD03B,IAAAA,EAAS4P,EAAQtnC,GACnB03B,GAAAA,EAASqP,EACFrP,OAAAA,EAGRr4B,OAAAA,KAAK+B,IAAI2lC,EAAS,GApCTG,CAAiBZ,EAAcvB,EAAOa,GAClDc,GAAAA,EAAkB,EAAG,CACjB1mC,IAAAA,EAAGoU,EACDmzB,EAAkBb,EAAkB,EAAIrnC,KAAKyD,OAAO8jC,EAAOD,IAAUD,EAAkB,IAAM,KAE9F1mC,IADLkqB,GAAK6a,EAAO8B,EAAUE,EAASh0B,GAAcw0B,GAAmB,EAAIZ,EAAQY,EAAiBZ,GACxF3mC,EAAI,EAAGoU,EAAOsyB,EAAkB,EAAG1mC,EAAIoU,EAAMpU,IAC9CkqB,GAAK6a,EAAO8B,EAAUE,EAAST,EAAatmC,GAAIsmC,EAAatmC,EAAI,IAG9D6mC,OADP3c,GAAK6a,EAAO8B,EAAUE,EAASH,EAAM7zB,GAAcw0B,GAAmBxC,EAAMhlC,OAAS6mC,EAAOW,GACrFV,EAGJA,OADP3c,GAAK6a,EAAO8B,EAAUE,GACfF,EAoDF3c,SAAAA,GAAK6a,EAAO8B,EAAUE,EAASS,EAAYC,GAC1C1pC,IAGFgC,EAAQC,EAAGgnC,EAHTjpC,EAAQyV,GAAeg0B,EAAY,GACnCxpC,EAAMqB,KAAKC,IAAIkU,GAAei0B,EAAU1C,EAAMhlC,QAASglC,EAAMhlC,QAC/DggC,EAAQ,EAQLiH,IANPD,EAAU1nC,KAAK4nC,KAAKF,GAChBU,IAEAV,GADAhnC,EAAS0nC,EAAWD,GACDnoC,KAAKyb,MAAM/a,EAASgnC,IAE3CC,EAAOjpC,EACAipC,EAAO,GACVjH,IACAiH,EAAO3nC,KAAKyD,MAAM/E,EAAQgiC,EAAQgH,GAEjC/mC,IAAAA,EAAIX,KAAK+B,IAAIrD,EAAO,GAAIiC,EAAIhC,EAAKgC,IAC9BA,IAAMgnC,IACNH,EAAS7lC,KAAK+jC,EAAM/kC,IACpB+/B,IACAiH,EAAO3nC,KAAKyD,MAAM/E,EAAQgiC,EAAQgH,IA3J9CjwB,GAASlW,IAAI,QAAS,CAClBiwB,SAAS,EACTkV,QAAQ,EACR/xB,SAAS,EACT0zB,aAAa,EACbC,OAAQ,QACR3a,MAAO,EACP4a,KAAM,CACF/W,SAAS,EACThO,UAAW,EACXglB,YAAY,EACZC,iBAAiB,EACjBC,WAAW,EACX/B,WAAY,EACZgC,UAAW,SAAC9K,EAAMhoB,GAAYA,OAAAA,EAAQ2N,WACtColB,UAAW,SAAC/K,EAAMhoB,GAAYA,OAAAA,EAAQxD,OACtCq0B,QAAQ,EACRmC,WAAY,GACZC,iBAAkB,EAClBjxB,YAAa,SAACgmB,EAAMhoB,GAAYA,OAAAA,EAAQxD,OACxCkP,YAAa,SAACsc,EAAMhoB,GAAYA,OAAAA,EAAQ2N,YAE5CulB,MAAO,CACHvX,SAAS,EACT3O,KAAM,GACNgN,QAAS,CACLhO,IAAK,EACLC,OAAQ,IAGhB4jB,MAAO,CACHsD,YAAa,EACbC,YAAa,GACbC,QAAQ,EACRC,gBAAiB,EACjBC,gBAAiB,GACjBvZ,QAAS,EACT2B,SAAS,EACT6U,UAAU,EACVgD,gBAAiB,EACjBC,YAAa,EACbnsC,SAAUipC,GAAMb,WAAWhuB,OAC3BgyB,MAAO,GACPrC,MAAO,GACP1oC,MAAO,SACPgrC,WAAY,UAGpB/xB,GAASgyB,MAAM,cAAe,QAAS,GAAI,SAC3ChyB,GAASgyB,MAAM,aAAc,QAAS,GAAI,eAC1ChyB,GAASgyB,MAAM,cAAe,QAAS,GAAI,SAC3ChyB,GAASmC,SAAS,QAAS,CACvBc,WAAW,EACXH,YAAa,SAACV,GAAS,OAACA,EAAKW,WAAW,YAAcX,EAAKW,WAAW,UAAqB,aAATX,GAAgC,WAATA,GACzGY,WAAY,SAACZ,GAASA,MAAS,eAATA,GAAkC,mBAATA,KAEnDpC,GAASmC,SAAS,SAAU,CACxBc,UAAW,UAqHTgvB,IAAAA,GAAe,SAAClrC,GAAUA,MAAU,SAAVA,EAAmB,QAAoB,UAAVA,EAAoB,OAASA,GACpFmrC,GAAiB,SAAClwB,EAAOmwB,EAAMlD,GAAWkD,MAAS,QAATA,GAA2B,SAATA,EAAkBnwB,EAAMmwB,GAAQlD,EAASjtB,EAAMmwB,GAAQlD,GAEhHmD,SAAAA,GAAOzF,EAAK0F,GAKVnpC,IAJDkb,IAAAA,EAAS,GACTkuB,EAAY3F,EAAI1jC,OAASopC,EACzB/3B,EAAMqyB,EAAI1jC,OACZC,EAAI,EACDA,EAAIoR,EAAKpR,GAAKopC,EACjBluB,EAAOla,KAAKyiC,EAAIpkC,KAAKyb,MAAM9a,KAExBkb,OAAAA,EAGFmuB,SAAAA,GAAoBvwB,EAAOtE,EAAO80B,GACjCvpC,IAMFgmC,EANEhmC,EAAS+Y,EAAMisB,MAAMhlC,OACrBwpC,EAAalqC,KAAKC,IAAIkV,EAAOzU,EAAS,GACtChC,EAAQ+a,EAAM0wB,YACdxrC,EAAM8a,EAAM2wB,UAEdC,EAAY5wB,EAAM6wB,gBAAgBJ,GAElCD,KAAAA,IAEIvD,EADW,IAAXhmC,EACSV,KAAK+B,IAAIsoC,EAAY3rC,EAAOC,EAAM0rC,GAC1B,IAAVl1B,GACGsE,EAAM6wB,gBAAgB,GAAKD,GAAa,GAExCA,EAAY5wB,EAAM6wB,gBAAgBJ,EAAa,IAAM,GAEnEG,GAAaH,EAAa/0B,EAAQuxB,GAAUA,GAC5BhoC,EAZJ,MAYuB2rC,EAAY1rC,EAZnC,OAgBT0rC,OAAAA,EAiBFE,SAAAA,GAAkB10B,GAChBA,OAAAA,EAAQ6yB,UAAY7yB,EAAQ8wB,WAAa,EAG3C6D,SAAAA,GAAe30B,EAASuX,GACzB,IAACvX,EAAQ2b,QACF,OAAA,EAELnZ,IAAAA,EAAO8U,GAAOtX,EAAQwC,KAAM+U,GAC5ByC,EAAU3C,GAAUrX,EAAQga,SAE1B7M,OADMle,GAAQ+Q,EAAQgN,MAAQhN,EAAQgN,KAAKniB,OAAS,GAC5C2X,EAAKI,WAAcoX,EAAQ3P,OAkBtCuqB,SAAAA,GAAWjsC,EAAOisB,EAAU9V,GAC7B7C,IAAAA,EAAMvT,EAAmBC,GAItBsT,OAHF6C,GAAwB,UAAb8V,IAA2B9V,GAAwB,UAAb8V,KAClD3Y,EAAM43B,GAAa53B,IAEhBA,EAmBL44B,IAAAA,GApoIW,SAAA,GAAA,EAAA,EAooIGlG,IApoIH,IAAA,EAAA,EAAA,GAqoID7L,SAAAA,EAAAA,GAAK,IAAA,EAAA,OAAA,EAAA,KAAA,IACb,EAAA,EAAA,KAAA,OACKllB,GAAKklB,EAAIllB,GACThU,EAAAA,KAAOk5B,EAAIl5B,KACXoW,EAAAA,aAAUxW,EACVuZ,EAAAA,IAAM+f,EAAI/f,IACVtZ,EAAAA,MAAQq5B,EAAIr5B,MACZuiB,EAAAA,SAAMxiB,EACNyiB,EAAAA,YAASziB,EACTR,EAAAA,UAAOQ,EACPP,EAAAA,WAAQO,EACRwf,EAAAA,WAAQxf,EACR6gB,EAAAA,YAAS7gB,EACTsrC,EAAAA,SAAW,CACZ9rC,KAAM,EACNC,MAAO,EACP+iB,IAAK,EACLC,OAAQ,GAEP4B,EAAAA,cAAWrkB,EACXipB,EAAAA,eAAYjpB,EACZurC,EAAAA,gBAAavrC,EACbwrC,EAAAA,mBAAgBxrC,EAChByrC,EAAAA,iBAAczrC,EACd0rC,EAAAA,kBAAe1rC,EACf0qB,EAAAA,UAAO1qB,EACP2rC,EAAAA,mBAAgB3rC,EAChBY,EAAAA,SAAMZ,EACN0C,EAAAA,SAAM1C,EACNqmC,EAAAA,MAAQ,GACRuF,EAAAA,eAAiB,KACjBC,EAAAA,YAAc,KACdC,EAAAA,YAAc,KACdrE,EAAAA,QAAU,EACVE,EAAAA,WAAa,EACboE,EAAAA,kBAAoB,GACpBjB,EAAAA,iBAAc9qC,EACd+qC,EAAAA,eAAY/qC,EACZgrB,EAAAA,gBAAiB,EACjBghB,EAAAA,cAAWhsC,EACXisC,EAAAA,cAAWjsC,EACXksC,EAAAA,mBAAgBlsC,EAChBmsC,EAAAA,mBAAgBnsC,EAChBosC,EAAAA,aAAe,EACfC,EAAAA,aAAe,EACfC,EAAAA,OAAS,GACTC,EAAAA,mBAAoB,EACpBrN,EAAAA,cAAWl/B,EA/CH,EAroIJ,OAAA,EAAA,EAAA,CAAA,CAAA,IAAA,OAurIb,MAAA,SAAKwW,GACK3V,IAAAA,EAAK,KACXA,EAAG2V,QAAUA,EACb3V,EAAG6pB,KAAOlU,EAAQkU,KAClB7pB,EAAGorC,SAAWprC,EAAGihC,MAAMtrB,EAAQ5V,KAC/BC,EAAGmrC,SAAWnrC,EAAGihC,MAAMtrB,EAAQ9T,KAC/B7B,EAAGsrC,cAAgBtrC,EAAGihC,MAAMtrB,EAAQg2B,cACpC3rC,EAAGqrC,cAAgBrrC,EAAGihC,MAAMtrB,EAAQi2B,gBA9rI3B,CAAA,IAAA,QAisIb,MAAA,SAAMjJ,EAAK1tB,GACA0tB,OAAAA,IAlsIE,CAAA,IAAA,gBAqsIb,MAAA,WACSyI,IAAAA,EAAoD,KAApDA,SAAUD,EAA0C,KAA1CA,SAAUG,EAAgC,KAAhCA,cAAeD,EAAiB,KAAjBA,cAKjC,OAJPD,EAAWr3B,GAAgBq3B,EAAUv3B,OAAOgH,mBAC5CswB,EAAWp3B,GAAgBo3B,EAAUt3B,OAAO4tB,mBAC5C6J,EAAgBv3B,GAAgBu3B,EAAez3B,OAAOgH,mBACtDwwB,EAAgBt3B,GAAgBs3B,EAAex3B,OAAO4tB,mBAC/C,CACH1hC,IAAKgU,GAAgBq3B,EAAUE,GAC/BzpC,IAAKkS,GAAgBo3B,EAAUE,GAC/B1J,WAAY/tB,GAAew3B,GAC3BxJ,WAAYhuB,GAAeu3B,MA/sItB,CAAA,IAAA,YAmtIb,MAAA,SAAU7J,GACAthC,IAEF0E,EADqC1E,EAD9B,KACiC0hC,gBAAvC3hC,EAAAA,EAAAA,IAAK8B,EAAAA,EAAAA,IAAK8/B,EAAAA,EAAAA,WAAYC,EAAAA,EAAAA,WAEvBD,GAAAA,GAAcC,EACP,MAAA,CAAC7hC,IAAAA,EAAK8B,IAAAA,GAGZ,IADCgqC,IAAAA,EANK,KAMMC,0BACRrrC,EAAI,EAAGoU,EAAOg3B,EAAMrrC,OAAQC,EAAIoU,IAAQpU,EAC7CiE,EAAQmnC,EAAMprC,GAAGqpB,WAAWiiB,UARrB,KAQmCzK,GACrCK,IACD5hC,EAAMD,KAAKC,IAAIA,EAAK2E,EAAM3E,MAEzB6hC,IACD//B,EAAM/B,KAAK+B,IAAIA,EAAK6C,EAAM7C,MAG3B,MAAA,CACH9B,IAAKgU,GAAgBhU,EAAKgU,GAAgBlS,EAAK9B,IAC/C8B,IAAKkS,GAAgBlS,EAAKkS,GAAgBhU,EAAK8B,OAtuI1C,CAAA,IAAA,aA0uIb,MAAA,WAEW,MAAA,CACHlD,KAFO,KAEEisC,aAAe,EACxBjpB,IAHO,KAGC+oB,YAAc,EACtB9rC,MAJO,KAIGisC,cAAgB,EAC1BjpB,OALO,KAKI+oB,eAAiB,KAhvIvB,CAAA,IAAA,WAovIb,MAAA,WACW,OAAA,KAAKnF,QArvIH,CAAA,IAAA,YAwvIb,MAAA,WACUnnB,IAAAA,EAAO,KAAKjf,MAAMif,KACjB,OAAA,KAAK1I,QAAQmrB,SAAW,KAAKrQ,eAAiBpS,EAAK2tB,QAAU3tB,EAAK4tB,UAAY5tB,EAAKyiB,QAAU,KA1vI3F,CAAA,IAAA,eA6vIb,MAAA,WACS2K,KAAAA,OAAS,GACTC,KAAAA,mBAAoB,IA/vIhB,CAAA,IAAA,eAkwIb,MAAA,WACIzuC,GAAS,KAAK0Y,QAAQu2B,aAAc,CAAC,SAnwI5B,CAAA,IAAA,SAswIb,MAAA,SAAO1oB,EAAU4E,EAAWD,GAClBnoB,IAAAA,EAAK,KACLomC,EAAWpmC,EAAG2V,QAAQ6vB,MACtB2G,EAAa/F,EAAS+F,WAC5BnsC,EAAGksC,eACHlsC,EAAGwjB,SAAWA,EACdxjB,EAAGooB,UAAYA,EACfpoB,EAAGyqC,SAAWtiB,EAAUzX,OAAOW,OAAO,CAClC1S,KAAM,EACNC,MAAO,EACP+iB,IAAK,EACLC,OAAQ,GACTuG,GACHnoB,EAAGwlC,MAAQ,KACXxlC,EAAGirC,YAAc,KACjBjrC,EAAG+qC,eAAiB,KACpB/qC,EAAGgrC,YAAc,KACjBhrC,EAAGosC,sBACHpsC,EAAGqsC,gBACHrsC,EAAGssC,qBACHtsC,EAAG8mC,WAAa9mC,EAAGywB,eACbzwB,EAAG2e,MAAQwJ,EAAQxpB,KAAOwpB,EAAQvpB,MAClCoB,EAAGggB,OAASmI,EAAQxG,IAAMwG,EAAQvG,OACnC5hB,EAAG0rC,oBACJ1rC,EAAGusC,mBACHvsC,EAAGwsC,sBACHxsC,EAAGysC,kBACHzsC,EAAG0rC,mBAAoB,GAE3B1rC,EAAG0sC,mBACH1sC,EAAGwlC,MAAQxlC,EAAG2sC,cAAgB,GAC9B3sC,EAAG4sC,kBACGC,IAAAA,EAAkBV,EAAansC,EAAGwlC,MAAMhlC,OAC9CR,EAAG8sC,sBAAsBD,EAAkBlD,GAAO3pC,EAAGwlC,MAAO2G,GAAcnsC,EAAGwlC,OAC7ExlC,EAAGkwB,YACHlwB,EAAG+sC,+BACH/sC,EAAGgtC,yBACHhtC,EAAGitC,8BACC7G,EAAS9U,UAAY8U,EAASD,UAAgC,SAApBC,EAASjxB,UACnDnV,EAAGwlC,MAAQW,GAASnmC,EAAIA,EAAGwlC,OAC3BxlC,EAAGirC,YAAc,MAEjB4B,GACA7sC,EAAG8sC,sBAAsB9sC,EAAGwlC,OAEhCxlC,EAAGktC,YACHltC,EAAGmtC,MACHntC,EAAGotC,WACHptC,EAAGqtC,gBAtzIM,CAAA,IAAA,YAyzIb,MAAA,WACUrtC,IAEFstC,EAAYC,EAFVvtC,EAAK,KACPwtC,EAAgBxtC,EAAG2V,QAAQlB,QAE3BzU,EAAGywB,gBACH6c,EAAattC,EAAGrB,KAChB4uC,EAAWvtC,EAAGpB,QAEd0uC,EAAattC,EAAG2hB,IAChB4rB,EAAWvtC,EAAG4hB,OACd4rB,GAAiBA,GAErBxtC,EAAGiqC,YAAcqD,EACjBttC,EAAGkqC,UAAYqD,EACfvtC,EAAGmqB,eAAiBqjB,EACpBxtC,EAAG4mC,QAAU2G,EAAWD,EACxBttC,EAAGytC,eAAiBztC,EAAG2V,QAAQ+3B,gBAz0ItB,CAAA,IAAA,cA40Ib,MAAA,WACIzwC,GAAS,KAAK0Y,QAAQ03B,YAAa,CAAC,SA70I3B,CAAA,IAAA,sBAg1Ib,MAAA,WACIpwC,GAAS,KAAK0Y,QAAQy2B,oBAAqB,CAAC,SAj1InC,CAAA,IAAA,gBAo1Ib,MAAA,WACUpsC,IAAAA,EAAK,KACPA,EAAGywB,gBACHzwB,EAAG2e,MAAQ3e,EAAGwjB,SACdxjB,EAAGrB,KAAO,EACVqB,EAAGpB,MAAQoB,EAAG2e,QAEd3e,EAAGggB,OAAShgB,EAAGooB,UACfpoB,EAAG2hB,IAAM,EACT3hB,EAAG4hB,OAAS5hB,EAAGggB,QAEnBhgB,EAAG4qC,YAAc,EACjB5qC,EAAG0qC,WAAa,EAChB1qC,EAAG6qC,aAAe,EAClB7qC,EAAG2qC,cAAgB,IAl2IV,CAAA,IAAA,qBAq2Ib,MAAA,WACI1tC,GAAS,KAAK0Y,QAAQ22B,mBAAoB,CAAC,SAt2IlC,CAAA,IAAA,aAy2Ib,MAAA,SAAW3yB,GACI,KACRva,MAAMuuC,cAAch0B,EADZ,KACqBkG,cAChC5iB,GAFW,KAEC0Y,QAAQgE,GAAO,CAFhB,SA12IF,CAAA,IAAA,mBA+2Ib,MAAA,WACSi0B,KAAAA,WAAW,sBAh3IP,CAAA,IAAA,sBAm3Ib,MAAA,cAn3Ia,CAAA,IAAA,kBAs3Ib,MAAA,WACSA,KAAAA,WAAW,qBAv3IP,CAAA,IAAA,mBA03Ib,MAAA,WACSA,KAAAA,WAAW,sBA33IP,CAAA,IAAA,aA83Ib,MAAA,WACW,MAAA,KA/3IE,CAAA,IAAA,kBAk4Ib,MAAA,WACSA,KAAAA,WAAW,qBAn4IP,CAAA,IAAA,8BAs4Ib,MAAA,WACI3wC,GAAS,KAAK0Y,QAAQk4B,4BAA6B,CAAC,SAv4I3C,CAAA,IAAA,qBA04Ib,MAAA,SAAmBrI,GACTxlC,IAEFS,EAAGoU,EAAM/T,EADPslC,EADK,KACSzwB,QAAQ6vB,MAEvB/kC,IAAAA,EAAI,EAAGoU,EAAO2wB,EAAMhlC,OAAQC,EAAIoU,EAAMpU,KACvCK,EAAO0kC,EAAM/kC,IACRyhC,MAAQjlC,GAASmpC,EAASnpC,SAAU,CAAC6D,EAAKiS,MAAOtS,EAAG+kC,GALlD,QA34IF,CAAA,IAAA,6BAo5Ib,MAAA,WACIvoC,GAAS,KAAK0Y,QAAQm4B,2BAA4B,CAAC,SAr5I1C,CAAA,IAAA,+BAw5Ib,MAAA,WACI7wC,GAAS,KAAK0Y,QAAQo3B,6BAA8B,CAAC,SAz5I5C,CAAA,IAAA,yBA45Ib,MAAA,WACU/sC,IAOFyoC,EAAWrgB,EAAW2lB,EAPpB/tC,EAAK,KACL2V,EAAU3V,EAAG2V,QACbywB,EAAWzwB,EAAQ6vB,MACnBwI,EAAWhuC,EAAGwlC,MAAMhlC,OACpBsoC,EAAc1C,EAAS0C,aAAe,EACtCC,EAAc3C,EAAS2C,YACzB+B,EAAgBhC,EAEhB,IAAC9oC,EAAGiuC,eAAiB7H,EAAS9U,SAAWwX,GAAeC,GAAeiF,GAAY,IAAMhuC,EAAGywB,eAC5FzwB,EAAG8qC,cAAgBhC,MADnB,CAIEoF,IAAAA,EAAaluC,EAAGmuC,iBAChBC,EAAgBF,EAAWG,OAAO1vB,MAClC2vB,EAAiBJ,EAAWK,QAAQvuB,OACpCwD,EAAWvF,GAAYje,EAAGZ,MAAMuf,MAAQyvB,EAAe,EAAGpuC,EAAGwjB,UAE/D4qB,EAAgB,GADpB3F,EAAY9yB,EAAQ6wB,OAASxmC,EAAGwjB,SAAWwqB,EAAWxqB,GAAYwqB,EAAW,MAEzEvF,EAAYjlB,GAAYwqB,GAAYr4B,EAAQ6wB,OAAS,GAAM,IAC3Dpe,EAAYpoB,EAAGooB,UAAYiiB,GAAkB10B,EAAQ0yB,MAC/CjC,EAASzW,QAAU2a,GAAe30B,EAAQkzB,MAAO7oC,EAAGZ,MAAMuW,QAAQwC,MACxE41B,EAAmBjuC,KAAK8b,KAAKwyB,EAAgBA,EAAgBE,EAAiBA,GAC9ExD,EAAgBnuB,GAAU7c,KAAKC,IAC3BD,KAAK0uC,KAAK1uC,KAAKC,KAAKmuC,EAAWK,QAAQvuB,OAAS,GAAKyoB,EAAW,IAChE3oC,KAAK0uC,KAAK1uC,KAAKC,IAAIqoB,EAAY2lB,EAAkB,IAAMjuC,KAAK0uC,KAAKF,EAAiBP,KAEtFjD,EAAgBhrC,KAAK+B,IAAIinC,EAAahpC,KAAKC,IAAIgpC,EAAa+B,KAEhE9qC,EAAG8qC,cAAgBA,KAz7IV,CAAA,IAAA,8BA47Ib,MAAA,WACI7tC,GAAS,KAAK0Y,QAAQs3B,4BAA6B,CAAC,SA77I3C,CAAA,IAAA,YAg8Ib,MAAA,WACIhwC,GAAS,KAAK0Y,QAAQu3B,UAAW,CAAC,SAj8IzB,CAAA,IAAA,MAo8Ib,MAAA,WACUltC,IAAAA,EAAK,KACLyuC,EAAU,CACZ9vB,MAAO,EACPqB,OAAQ,GAEL5gB,EAAuEY,EAAvEZ,MAAuEY,EAAAA,EAAhE2V,QAAiBywB,EAAPZ,EAAAA,MAAwBkJ,EAAP7F,EAAAA,MAAwB8F,EAANtG,EAAAA,KACrD/W,EAAUtxB,EAAGiuC,aACbxd,EAAezwB,EAAGywB,eACpBa,GAAAA,EAAS,CACHsd,IAAAA,EAActE,GAAeoE,EAAWtvC,EAAMuW,QAAQwC,MAQxDiuB,GAPA3V,GACAge,EAAQ9vB,MAAQ3e,EAAGwjB,SACnBirB,EAAQzuB,OAASqqB,GAAkBsE,GAAYC,IAE/CH,EAAQzuB,OAAShgB,EAAGooB,UACpBqmB,EAAQ9vB,MAAQ0rB,GAAkBsE,GAAYC,GAE9CxI,EAAS9U,SAAWtxB,EAAGwlC,MAAMhlC,OAAQ,CACER,IAAAA,EAAAA,EAAGmuC,iBAAnC/G,EAAAA,EAAAA,MAAOC,EAAAA,EAAAA,KAAMgH,EAAAA,EAAAA,OAAQE,EAAAA,EAAAA,QACtBM,EAAiC,EAAnBzI,EAASzW,QACvBmf,EAAeryB,GAAUzc,EAAG8qC,eAC5B9pB,EAAMlhB,KAAKkhB,IAAI8tB,GACf/tB,EAAMjhB,KAAKihB,IAAI+tB,GACjBre,GAAAA,EAAc,CACRse,IAAAA,EAAchuB,EAAMstB,EAAO1vB,MAAQqC,EAAMutB,EAAQvuB,OACvDyuB,EAAQzuB,OAASlgB,KAAKC,IAAIC,EAAGooB,UAAWqmB,EAAQzuB,OAAS+uB,EAAcF,OACpE,CACGG,IAAAA,EAAa5I,EAAS4C,OAAS,EAAIhoB,EAAMqtB,EAAO1vB,MAAQoC,EAAMwtB,EAAQvuB,OAC5EyuB,EAAQ9vB,MAAQ7e,KAAKC,IAAIC,EAAGwjB,SAAUirB,EAAQ9vB,MAAQqwB,EAAaH,GAEvE7uC,EAAGivC,kBAAkB7H,EAAOC,EAAMtmB,EAAKC,IAG/ChhB,EAAGkvC,iBACCze,GACAzwB,EAAG2e,MAAQ3e,EAAG4mC,QAAUxnC,EAAMuf,MAAQ3e,EAAGyqC,SAAS9rC,KAAOqB,EAAGyqC,SAAS7rC,MACrEoB,EAAGggB,OAASyuB,EAAQzuB,SAEpBhgB,EAAG2e,MAAQ8vB,EAAQ9vB,MACnB3e,EAAGggB,OAAShgB,EAAG4mC,QAAUxnC,EAAM4gB,OAAShgB,EAAGyqC,SAAS9oB,IAAM3hB,EAAGyqC,SAAS7oB,UA5+IjE,CAAA,IAAA,oBAg/Ib,MAAA,SAAkBwlB,EAAOC,EAAMtmB,EAAKC,GAC1BhhB,IAAAA,EAAK,KACiCA,EAAAA,EAAG2V,QAAxC6vB,EAAAA,EAAAA,MAAQlnC,EAAAA,EAAAA,MAAOqxB,EAAAA,EAAAA,QAAUpF,EAAAA,EAAAA,SAC1B4kB,EAAiC,IAArBnvC,EAAG8qC,cACfsE,EAAgC,QAAb7kB,GAAkC,MAAZvqB,EAAG6pB,KAC9C7pB,GAAAA,EAAGywB,eAAgB,CACb4e,IAAAA,EAAarvC,EAAGoqC,gBAAgB,GAAKpqC,EAAGrB,KACxC2wC,EAActvC,EAAGpB,MAAQoB,EAAGoqC,gBAAgBpqC,EAAGwlC,MAAMhlC,OAAS,GAChEoqC,EAAc,EACdC,EAAe,EACfsE,EACIC,GACAxE,EAAc5pB,EAAMomB,EAAMzoB,MAC1BksB,EAAe9pB,EAAMsmB,EAAKrnB,SAE1B4qB,EAAc7pB,EAAMqmB,EAAMpnB,OAC1B6qB,EAAe7pB,EAAMqmB,EAAK1oB,OAEb,UAAVrgB,EACPusC,EAAexD,EAAK1oB,MACH,QAAVrgB,EACPssC,EAAcxD,EAAMzoB,OAEpBisB,EAAcxD,EAAMzoB,MAAQ,EAC5BksB,EAAexD,EAAK1oB,MAAQ,GAEhC3e,EAAG4qC,YAAc9qC,KAAK+B,KAAK+oC,EAAcyE,EAAa1f,GAAW3vB,EAAG2e,OAAS3e,EAAG2e,MAAQ0wB,GAAa,GACrGrvC,EAAG6qC,aAAe/qC,KAAK+B,KAAKgpC,EAAeyE,EAAc3f,GAAW3vB,EAAG2e,OAAS3e,EAAG2e,MAAQ2wB,GAAc,OACtG,CACC5E,IAAAA,EAAarD,EAAKrnB,OAAS,EAC3B2qB,EAAgBvD,EAAMpnB,OAAS,EACrB,UAAV1hB,GACAosC,EAAa,EACbC,EAAgBvD,EAAMpnB,QACL,QAAV1hB,IACPosC,EAAarD,EAAKrnB,OAClB2qB,EAAgB,GAEpB3qC,EAAG0qC,WAAaA,EAAa/a,EAC7B3vB,EAAG2qC,cAAgBA,EAAgBhb,KAvhJ9B,CAAA,IAAA,iBA2hJb,MAAA,WACU3vB,IAAAA,EAAK,KACPA,EAAGyqC,WACHzqC,EAAGyqC,SAAS9rC,KAAOmB,KAAK+B,IAAI7B,EAAG4qC,YAAa5qC,EAAGyqC,SAAS9rC,MACxDqB,EAAGyqC,SAAS9oB,IAAM7hB,KAAK+B,IAAI7B,EAAG0qC,WAAY1qC,EAAGyqC,SAAS9oB,KACtD3hB,EAAGyqC,SAAS7rC,MAAQkB,KAAK+B,IAAI7B,EAAG6qC,aAAc7qC,EAAGyqC,SAAS7rC,OAC1DoB,EAAGyqC,SAAS7oB,OAAS9hB,KAAK+B,IAAI7B,EAAG2qC,cAAe3qC,EAAGyqC,SAAS7oB,WAjiJvD,CAAA,IAAA,WAqiJb,MAAA,WACI3kB,GAAS,KAAK0Y,QAAQy3B,SAAU,CAAC,SAtiJxB,CAAA,IAAA,eAyiJb,MAAA,WAC6B,IAAA,EAAA,KAAKz3B,QAAvBkU,EAAAA,EAAAA,KAAMU,EAAAA,EAAAA,SACNA,MAAa,QAAbA,GAAmC,WAAbA,GAAkC,MAATV,IA3iJ7C,CAAA,IAAA,aA8iJb,MAAA,WACW,OAAA,KAAKlU,QAAQ6Z,WA/iJX,CAAA,IAAA,wBAkjJb,MAAA,SAAsBgW,GACP,KACRqI,8BADQ,KAER0B,mBAAmB/J,GAFX,KAGRsI,+BAtjJM,CAAA,IAAA,iBAyjJb,MAAA,WACU9tC,IAAAA,EAAK,KACPkuC,EAAaluC,EAAGirC,YAChB,IAACiD,EAAY,CACP/B,IAAAA,EAAansC,EAAG2V,QAAQ6vB,MAAM2G,WAChC3G,EAAQxlC,EAAGwlC,MACX2G,EAAa3G,EAAMhlC,SACnBglC,EAAQmE,GAAOnE,EAAO2G,IAE1BnsC,EAAGirC,YAAciD,EAAaluC,EAAGwvC,mBAAmBhK,EAAOA,EAAMhlC,QAE9D0tC,OAAAA,IApkJE,CAAA,IAAA,qBAukJb,MAAA,SAAmB1I,EAAOhlC,GACfkY,IAKHjY,EAAG6P,EAAG2O,EAAMijB,EAAOuN,EAAUC,EAAY5wB,EAAOvG,EAAYoG,EAAOqB,EAAQ2vB,EALxEj3B,EAAkC,KAAlCA,IAAwBk3B,EAAU,KAA7B1E,kBACN2E,EAAS,GACTC,EAAU,GACZC,EAAkB,EAClBC,EAAmB,EAElBvvC,IAAAA,EAAI,EAAGA,EAAID,IAAUC,EAAG,CAOrB,GANJyhC,EAAQsD,EAAM/kC,GAAGyhC,MACjBuN,EAAW,KAAKQ,wBAAwBxvC,GACxCiY,EAAIP,KAAOu3B,EAAaD,EAASjxB,OACjCM,EAAQ8wB,EAAOF,GAAcE,EAAOF,IAAe,CAACrxB,KAAM,GAAIC,GAAI,IAClE/F,EAAak3B,EAASl3B,WACtBoG,EAAQqB,EAAS,EACZxM,GAAc0uB,IAAWt9B,GAAQs9B,IAG/B,GAAIt9B,GAAQs9B,GACV5xB,IAAAA,EAAI,EAAG2O,EAAOijB,EAAM1hC,OAAQ8P,EAAI2O,IAAQ3O,EAEpCkD,GADLm8B,EAAczN,EAAM5xB,KACgB1L,GAAQ+qC,KACxChxB,EAAQP,GAAa1F,EAAKoG,EAAMT,KAAMS,EAAMR,GAAIK,EAAOgxB,GACvD3vB,GAAUzH,QAPlBoG,EAAQP,GAAa1F,EAAKoG,EAAMT,KAAMS,EAAMR,GAAIK,EAAOujB,GACvDliB,EAASzH,EAUbs3B,EAAOpuC,KAAKkd,GACZmxB,EAAQruC,KAAKue,GACb+vB,EAAkBjwC,KAAK+B,IAAI8c,EAAOoxB,GAClCC,EAAmBlwC,KAAK+B,IAAIme,EAAQgwB,IAniBvCjxB,SAAe6wB,EAAQpvC,GAC5B+T,GAAKq7B,EAAQ,SAAC9wB,GACJR,IAEF7d,EAFE6d,EAAKQ,EAAMR,GACXe,EAAQf,EAAG9d,OAAS,EAEtB6e,GAAAA,EAAQ7e,EAAQ,CACXC,IAAAA,EAAI,EAAGA,EAAI4e,IAAS5e,SACdqe,EAAMT,KAAKC,EAAG7d,IAEzB6d,EAAGgB,OAAO,EAAGD,MA4hBjBN,CAAe6wB,EAAQpvC,GACjB6tC,IAAAA,EAASwB,EAAOp6B,QAAQs6B,GACxBxB,EAAUuB,EAAQr6B,QAAQu6B,GAC1BE,EAAU,SAAC35B,GAAS,MAAA,CAACoI,MAAOkxB,EAAOt5B,IAAQ,EAAGyJ,OAAQ8vB,EAAQv5B,IAAQ,IACrE,MAAA,CACH6wB,MAAO8I,EAAQ,GACf7I,KAAM6I,EAAQ1vC,EAAS,GACvB6tC,OAAQ6B,EAAQ7B,GAChBE,QAAS2B,EAAQ3B,MA9mJZ,CAAA,IAAA,mBAknJb,MAAA,SAAiBx7B,GACNA,OAAAA,IAnnJE,CAAA,IAAA,mBAsnJb,MAAA,SAAiBA,EAAOkC,GACbosB,OAAAA,MAvnJE,CAAA,IAAA,mBA0nJb,MAAA,SAAiB7hB,MA1nJJ,CAAA,IAAA,kBA6nJb,MAAA,SAAgBvK,GACNuwB,IAAAA,EAAQ,KAAKA,MACfvwB,OAAAA,EAAQ,GAAKA,EAAQuwB,EAAMhlC,OAAS,EAC7B,KAEJ,KAAK2vC,iBAAiB3K,EAAMvwB,GAAOlC,SAloJjC,CAAA,IAAA,qBAqoJb,MAAA,SAAmBq9B,GACTpwC,IAAAA,EAAK,KACPA,EAAGmqB,iBACHimB,EAAU,EAAIA,GAEZ5wB,IAAAA,EAAQxf,EAAGiqC,YAAcmG,EAAUpwC,EAAG4mC,QACrC1oB,OAAAA,GAAYle,EAAGytC,eAAiBluB,GAAYvf,EAAGZ,MAAOogB,EAAO,GAAKA,KA3oJhE,CAAA,IAAA,qBA8oJb,MAAA,SAAmBA,GACT4wB,IAAAA,GAAW5wB,EAAQ,KAAKyqB,aAAe,KAAKrD,QAC3C,OAAA,KAAKzc,eAAiB,EAAIimB,EAAUA,IAhpJlC,CAAA,IAAA,eAmpJb,MAAA,WACW,OAAA,KAAKD,iBAAiB,KAAKE,kBAppJzB,CAAA,IAAA,eAupJb,MAAA,WACWtwC,IAAAA,EAAY,KAAZA,IAAK8B,EAAO,KAAPA,IACL9B,OAAAA,EAAM,GAAK8B,EAAM,EAAIA,EACxB9B,EAAM,GAAK8B,EAAM,EAAI9B,EACjB,IA3pJC,CAAA,IAAA,aA8pJb,MAAA,SAAWkV,GACDjV,IAlkBc6lB,EAAQtM,EAkkBtBvZ,EAAK,KACLwlC,EAAQxlC,EAAGwlC,OAAS,GACtBvwB,GAAAA,GAAS,GAAKA,EAAQuwB,EAAMhlC,OAAQ,CAC9BM,IAAAA,EAAO0kC,EAAMvwB,GACZnU,OAAAA,EAAKu9B,WACPv9B,EAAKu9B,SAhkBbiS,SAAkBzqB,EAAQ5Q,EAAOnU,GAC/B4P,OAAAA,OAAOW,OAAOX,OAAO2E,OAAOwQ,GAAS,CACxC/kB,KAAAA,EACAmU,MAAAA,EACA1V,KAAM,SA4jBmB+wC,CAAkBtwC,EAAG6f,aAAc5K,EAAOnU,IAE5Dd,OAAAA,EAAGq+B,WACLr+B,EAAGq+B,UA1kBYxY,EA0kBkB7lB,EAAGZ,MAAMygB,aA1kBnBtG,EA0kBiCvZ,EAzkB1D0Q,OAAOW,OAAOX,OAAO2E,OAAOwQ,GAAS,CACxCtM,MAAAA,EACAha,KAAM,cAhmIG,CAAA,IAAA,YA0qJb,MAAA,WACUS,IACAuwC,EADK,KACY56B,QAAQ6vB,MACzBgL,EAAM/zB,GAFD,KAEcquB,eACnB9pB,EAAMlhB,KAAKqc,IAAIrc,KAAKkhB,IAAIwvB,IACxBzvB,EAAMjhB,KAAKqc,IAAIrc,KAAKihB,IAAIyvB,IACxBtC,EALK,KAKWC,iBAChBxe,EAAU4gB,EAAYpH,iBAAmB,EACzC5kC,EAAI2pC,EAAaA,EAAWG,OAAO1vB,MAAQgR,EAAU,EACrDjsB,EAAIwqC,EAAaA,EAAWK,QAAQvuB,OAAS2P,EAAU,EACtD3vB,OATI,KASDywB,eACJ/sB,EAAIsd,EAAMzc,EAAIwc,EAAMxc,EAAIyc,EAAMtd,EAAIqd,EAClCrd,EAAIqd,EAAMxc,EAAIyc,EAAMtd,EAAIsd,EAAMzc,EAAIwc,IAtrJ/B,CAAA,IAAA,aAyrJb,MAAA,WACUuQ,IAAAA,EAAU,KAAK3b,QAAQ2b,QACzBA,MAAY,SAAZA,IACSA,EAEN,KAAKwa,0BAA0BtrC,OAAS,IA9rJtC,CAAA,IAAA,wBAisJb,MAAA,SAAsBsqB,GACZ9qB,IAiBFywC,EAAahwC,EAAG0pC,EAAWuG,EAC3BC,EAAKC,EAAKC,EAAKC,EAAKC,EAAIC,EAAIC,EAAIC,EAlB9BlxC,EAAK,KACL6pB,EAAO7pB,EAAG6pB,KACVzqB,EAAQY,EAAGZ,MACXuW,EAAU3V,EAAG2V,QACZ0yB,EAAkB1yB,EAAlB0yB,KAAM9d,EAAY5U,EAAZ4U,SACPic,EAAS6B,EAAK7B,OACd/V,EAAezwB,EAAGywB,eAElB0gB,EADQnxC,EAAGwlC,MACShlC,QAAUgmC,EAAS,EAAI,GAC3C4K,EAAK/G,GAAkBhC,GACvB9nC,EAAQ,GACR8wC,EAAahJ,EAAKiJ,WAAWtxC,EAAG6f,WAAW,IAC3C0xB,EAAYF,EAAW/I,WAAa+I,EAAWhwB,YAAc,EAC7DmwB,EAAgBD,EAAY,EAC5BE,EAAmB,SAAUjyB,GACxBD,OAAAA,GAAYngB,EAAOogB,EAAO+xB,IAIjChnB,GAAa,QAAbA,EACAkmB,EAAcgB,EAAiBzxC,EAAG4hB,QAClCgvB,EAAM5wC,EAAG4hB,OAASwvB,EAClBN,EAAML,EAAce,EACpBR,EAAKS,EAAiB3mB,EAAUnJ,KAAO6vB,EACvCN,EAAKpmB,EAAUlJ,YACZ,GAAiB,WAAb2I,EACPkmB,EAAcgB,EAAiBzxC,EAAG2hB,KAClCqvB,EAAKlmB,EAAUnJ,IACfuvB,EAAKO,EAAiB3mB,EAAUlJ,QAAU4vB,EAC1CZ,EAAMH,EAAce,EACpBV,EAAM9wC,EAAG2hB,IAAMyvB,OACZ,GAAiB,SAAb7mB,EACPkmB,EAAcgB,EAAiBzxC,EAAGpB,OAClC+xC,EAAM3wC,EAAGpB,MAAQwyC,EACjBP,EAAMJ,EAAce,EACpBT,EAAKU,EAAiB3mB,EAAUnsB,MAAQ6yC,EACxCP,EAAKnmB,EAAUlsB,WACZ,GAAiB,UAAb2rB,EACPkmB,EAAcgB,EAAiBzxC,EAAGrB,MAClCoyC,EAAKjmB,EAAUnsB,KACfsyC,EAAKQ,EAAiB3mB,EAAUlsB,OAAS4yC,EACzCb,EAAMF,EAAce,EACpBX,EAAM7wC,EAAGrB,KAAOyyC,OACb,GAAa,MAATvnB,EAAc,CACjBU,GAAa,WAAbA,EACAkmB,EAAcgB,GAAkB3mB,EAAUnJ,IAAMmJ,EAAUlJ,QAAU,EAAI,SACrE,GAAIjO,GAAS4W,GAAW,CACrBmnB,IAAAA,EAAiBhhC,OAAOD,KAAK8Z,GAAU,GACvCxX,EAAQwX,EAASmnB,GACvBjB,EAAcgB,EAAiBzxC,EAAGZ,MAAMoa,OAAOk4B,GAAgBvB,iBAAiBp9B,IAEpFi+B,EAAKlmB,EAAUnJ,IACfuvB,EAAKpmB,EAAUlJ,OAEfkvB,GADAF,EAAMH,EAAce,GACRJ,OACT,GAAa,MAATvnB,EAAc,CACjBU,GAAa,WAAbA,EACAkmB,EAAcgB,GAAkB3mB,EAAUnsB,KAAOmsB,EAAUlsB,OAAS,QACjE,GAAI+U,GAAS4W,GAAW,CACrBmnB,IAAAA,EAAiBhhC,OAAOD,KAAK8Z,GAAU,GACvCxX,EAAQwX,EAASmnB,GACvBjB,EAAcgB,EAAiBzxC,EAAGZ,MAAMoa,OAAOk4B,GAAgBvB,iBAAiBp9B,IAGpF89B,GADAF,EAAMF,EAAce,GACRJ,EACZL,EAAKjmB,EAAUnsB,KACfsyC,EAAKnmB,EAAUlsB,MAEd6B,IAAAA,EAAI,EAAGA,EAAI0wC,IAAe1wC,EAAG,CACxBkxC,IAAAA,EAActJ,EAAKiJ,WAAWtxC,EAAG6f,WAAWpf,IAC5C6iB,EAAYquB,EAAYruB,UACxBsuB,EAAYD,EAAYx/B,MACxBw2B,EAAaN,EAAKM,YAAc,GAChCC,EAAmB+I,EAAY/I,iBAC/BH,EAAYkJ,EAAYlJ,UACxBC,EAAYiJ,EAAYjJ,UACxBmJ,EAAiBF,EAAYE,gBAAkB,GAC/CC,EAAuBH,EAAYG,0BAEvB3yC,KADlBgrC,EAAYL,GAAoB9pC,EAAIS,EAAG+lC,MAIvCkK,EAAmBnxB,GAAYngB,EAAO+qC,EAAW7mB,GAC7CmN,EACAkgB,EAAME,EAAME,EAAKE,EAAKP,EAEtBE,EAAME,EAAME,EAAKE,EAAKR,EAE1BnwC,EAAMkB,KAAK,CACPkvC,IAAAA,EACAC,IAAAA,EACAC,IAAAA,EACAC,IAAAA,EACAC,GAAAA,EACAC,GAAAA,EACAC,GAAAA,EACAC,GAAAA,EACAvyB,MAAO2E,EACPnR,MAAOy/B,EACPjJ,WAAAA,EACAC,iBAAAA,EACAH,UAAAA,EACAC,UAAAA,EACAmJ,eAAAA,EACAC,qBAAAA,KAKDvxC,OAFPP,EAAGurC,aAAe4F,EAClBnxC,EAAGwrC,aAAeiF,EACXlwC,IA/yJE,CAAA,IAAA,qBAkzJb,MAAA,SAAmBuqB,GACT9qB,IAWFS,EAAGoU,EAAYqtB,EAAOz8B,EAAGwW,EAAGkH,EAAW3D,EAAOrH,EAAMI,EAAYw5B,EAAWC,EAXzEhyC,EAAK,KACL6pB,EAAO7pB,EAAG6pB,KACVlU,EAAU3V,EAAG2V,QACZ4U,EAAgC5U,EAAhC4U,SAAiBgmB,EAAe56B,EAAtB6vB,MACX/U,EAAezwB,EAAGywB,eAClB+U,EAAQxlC,EAAGwlC,MACVlnC,EAA8BiyC,EAA9BjyC,MAAOgrC,EAAuBiH,EAAvBjH,WAAY3Z,EAAW4gB,EAAX5gB,QACpByhB,EAAK/G,GAAkB10B,EAAQ0yB,MAC/B4J,EAAiBb,EAAKzhB,EACtBrP,GAAY7D,GAAUzc,EAAG8qC,eACzBvqC,EAAQ,GAEV6iB,EAAe,SACfmH,GAAa,QAAbA,EACAtO,EAAIjc,EAAG4hB,OAASqwB,EAChB9uB,EAAYnjB,EAAGkyC,+BACZ,GAAiB,WAAb3nB,EACPtO,EAAIjc,EAAG2hB,IAAMswB,EACb9uB,EAAYnjB,EAAGkyC,+BACZ,GAAiB,SAAb3nB,EAAqB,CACtB3Y,IAAAA,EAAM,KAAKugC,wBAAwBf,GACzCjuB,EAAYvR,EAAIuR,UAChB1d,EAAImM,EAAInM,OACL,GAAiB,UAAb8kB,EAAsB,CACvB3Y,IAAAA,EAAM,KAAKugC,wBAAwBf,GACzCjuB,EAAYvR,EAAIuR,UAChB1d,EAAImM,EAAInM,OACL,GAAa,MAATokB,EAAc,CACjBU,GAAa,WAAbA,EACAtO,GAAM6O,EAAUnJ,IAAMmJ,EAAUlJ,QAAU,EAAKqwB,OAC5C,GAAIt+B,GAAS4W,GAAW,CACrBmnB,IAAAA,EAAiBhhC,OAAOD,KAAK8Z,GAAU,GACvCxX,EAAQwX,EAASmnB,GACvBz1B,EAAIjc,EAAGZ,MAAMoa,OAAOk4B,GAAgBvB,iBAAiBp9B,GAASk/B,EAElE9uB,EAAYnjB,EAAGkyC,+BACZ,GAAa,MAATroB,EAAc,CACjBU,GAAa,WAAbA,EACA9kB,GAAMqlB,EAAUnsB,KAAOmsB,EAAUlsB,OAAS,EAAKqzC,OAC5C,GAAIt+B,GAAS4W,GAAW,CACrBmnB,IAAAA,EAAiBhhC,OAAOD,KAAK8Z,GAAU,GACvCxX,EAAQwX,EAASmnB,GACvBjsC,EAAIzF,EAAGZ,MAAMoa,OAAOk4B,GAAgBvB,iBAAiBp9B,GAEzDoQ,EAAY,KAAKgvB,wBAAwBf,GAAIjuB,UAEpC,MAAT0G,IACc,UAAVvrB,EACA8kB,EAAe,MACE,QAAV9kB,IACP8kB,EAAe,WAGjB8qB,IAAAA,EAAaluC,EAAGmuC,iBACjB1tC,IAAAA,EAAI,EAAGoU,EAAO2wB,EAAMhlC,OAAQC,EAAIoU,IAAQpU,EAAG,CAE5CyhC,EADOsD,EAAM/kC,GACAyhC,MACPyP,IAAAA,EAAcpB,EAAYe,WAAWtxC,EAAG6f,WAAWpf,IACzD+e,EAAQxf,EAAGoqC,gBAAgB3pC,GAAK8vC,EAAYnH,YAE5C7wB,GADAJ,EAAOnY,EAAGiwC,wBAAwBxvC,IAChB8X,WAEZ65B,IAAAA,GADNL,EAAYntC,GAAQs9B,GAASA,EAAM1hC,OAAS,GACd,EACxB2R,EAAQw/B,EAAYx/B,MACpB6Q,EAAc2uB,EAAYzI,gBAC1BnmB,EAAc4uB,EAAY1I,gBAC5BxY,GACAhrB,EAAI+Z,EAGIwyB,EAFS,QAAbznB,EACmB,SAAf+e,GAAsC,IAAbhpB,GACXyxB,EAAYx5B,EAAaA,EAAa,EAC9B,WAAf+wB,GACO4E,EAAWK,QAAQvuB,OAAS,EAAIoyB,EAAY75B,EAAaA,GAEzD21B,EAAWK,QAAQvuB,OAASzH,EAAa,EAGxC,SAAf+wB,GAAsC,IAAbhpB,EACZ/H,EAAa,EACJ,WAAf+wB,EACM4E,EAAWK,QAAQvuB,OAAS,EAAIoyB,EAAY75B,EAE5C21B,EAAWK,QAAQvuB,OAAS+xB,EAAYx5B,IAI7D0D,EAAIuD,EACJwyB,GAAc,EAAID,GAAax5B,EAAa,GAEhDhY,EAAMkB,KAAK,CACP6e,SAAAA,EACA4hB,MAAAA,EACA/pB,KAAAA,EACAhG,MAAAA,EACA6Q,YAAAA,EACAD,YAAAA,EACAivB,WAAAA,EACA7uB,UAAAA,EACAC,aAAAA,EACAH,YAAa,CAACxd,EAAGwW,KAGlB1b,OAAAA,IAz5JE,CAAA,IAAA,0BA45Jb,MAAA,WACUP,IACoBA,EADf,KACkB2V,QAAtB4U,EAAAA,EAAAA,SAAUib,EAAAA,EAAAA,MAEbllB,IADc7D,GAFP,KAEoBquB,eAEpBvgB,MAAa,QAAbA,EAAqB,OAAS,QAErCjsB,IAAAA,EAAQ,SAMLA,MALa,UAAhBknC,EAAMlnC,MACNA,EAAQ,OACe,QAAhBknC,EAAMlnC,QACbA,EAAQ,SAELA,IAz6JE,CAAA,IAAA,0BA46Jb,MAAA,SAAwB8yC,GACdpxC,IAKFmjB,EACA1d,EANEzF,EAAK,KAC8CA,EAAAA,EAAG2V,QAArD4U,EAAAA,EAAAA,SAAUib,EAAAA,EAAAA,MAAQ8D,EAAAA,EAAAA,WAAYN,EAAAA,EAAAA,OAAQrZ,EAAAA,EAAAA,QAEvCsiB,EAAiBb,EAAKzhB,EACtB0e,EAFaruC,EAAGmuC,iBAEIE,OAAO1vB,MAsC1B,MAnCU,SAAb4L,EACIye,GACA7lB,EAAY,OACZ1d,EAAIzF,EAAGpB,MAAQ+wB,IAEflqB,EAAIzF,EAAGpB,MAAQqzC,EACI,SAAf3I,EACAnmB,EAAY,QACU,WAAfmmB,GACPnmB,EAAY,SACZ1d,GAAM4oC,EAAS,IAEflrB,EAAY,OACZ1d,EAAIzF,EAAGrB,OAGK,UAAb4rB,EACHye,GACA7lB,EAAY,QACZ1d,EAAIzF,EAAGrB,KAAOgxB,IAEdlqB,EAAIzF,EAAGrB,KAAOszC,EACK,SAAf3I,EACAnmB,EAAY,OACU,WAAfmmB,GACPnmB,EAAY,SACZ1d,GAAK4oC,EAAS,IAEdlrB,EAAY,QACZ1d,EAAIzF,EAAGpB,QAIfukB,EAAY,QAET,CAACA,UAAAA,EAAW1d,EAAAA,KAv9JV,CAAA,IAAA,oBA09Jb,MAAA,WACUzF,IAAAA,EAAK,KACPA,IAAAA,EAAG2V,QAAQ6vB,MAAMwD,OAAjBhpC,CAGEZ,IAAAA,EAAQY,EAAGZ,MACXmrB,EAAWvqB,EAAG2V,QAAQ4U,SACxBA,MAAa,SAAbA,GAAoC,UAAbA,EAChB,CAAC5I,IAAK,EAAGhjB,KAAMqB,EAAGrB,KAAMijB,OAAQxiB,EAAM4gB,OAAQphB,MAAOoB,EAAGpB,OAElD,QAAb2rB,GAAmC,WAAbA,EACf,CAAC5I,IAAK3hB,EAAG2hB,IAAKhjB,KAAM,EAAGijB,OAAQ5hB,EAAG4hB,OAAQhjB,MAAOQ,EAAMuf,YAD9D4L,KAp+JK,CAAA,IAAA,iBAy+Jb,MAAA,WACW7R,IAAAA,EAA6D,KAA7DA,IAAehB,EAA8C,KAAxD/B,QAAU+B,gBAAkB/Y,EAA4B,KAA5BA,KAAMgjB,EAAsB,KAAtBA,IAAKhD,EAAiB,KAAjBA,MAAOqB,EAAU,KAAVA,OACtDtI,IACAgB,EAAIsG,OACJtG,EAAIwK,UAAYxL,EAChBgB,EAAI25B,SAAS1zC,EAAMgjB,EAAKhD,EAAOqB,GAC/BtH,EAAI0G,aA/+JC,CAAA,IAAA,uBAm/Jb,MAAA,SAAqBrM,GACX/S,IACAqoC,EADK,KACK1yB,QAAQ0yB,KACpB,IAFO,KAEH4F,eAAiB5F,EAAK/W,QACnB,OAAA,EAELkU,IACAvwB,EANK,KAKMuwB,MACG8M,UAAU,SAAA1c,GAAKA,OAAAA,EAAE7iB,QAAUA,IAC3CkC,OAAAA,GAAS,EACIozB,EAAKiJ,WARX,KAQyBzxB,WAAW5K,IAC/BqO,UAET,IA//JE,CAAA,IAAA,WAkgKb,MAAA,SAASwH,GACC9qB,IAOFS,EAAGoU,EAPD7U,EAAK,KACLqoC,EAAOroC,EAAG2V,QAAQ0yB,KAClB3vB,EAAM1Y,EAAG0Y,IACTtZ,EAAQY,EAAGZ,MACXiyC,EAAahJ,EAAKiJ,WAAWtxC,EAAG6f,WAAW,IAC3C0xB,EAAYlJ,EAAKC,WAAa+I,EAAWhwB,YAAc,EACvD9gB,EAAQP,EAAG+qC,iBAAmB/qC,EAAG+qC,eAAiB/qC,EAAGuyC,sBAAsBznB,IAE3E0nB,EAAW,SAACrtC,EAAIC,EAAIkT,GACjBA,EAAMqG,OAAUrG,EAAMnG,QAG3BuG,EAAIsG,OACJtG,EAAI4K,UAAYhL,EAAMqG,MACtBjG,EAAI2K,YAAc/K,EAAMnG,MACxBuG,EAAI+5B,YAAYn6B,EAAMqwB,YAAc,IACpCjwB,EAAIg6B,eAAiBp6B,EAAMswB,iBAC3BlwB,EAAIiI,YACJjI,EAAIoI,OAAO3b,EAAGM,EAAGN,EAAG8W,GACpBvD,EAAIuI,OAAO7b,EAAGK,EAAGL,EAAG6W,GACpBvD,EAAI4I,SACJ5I,EAAI0G,YAEJipB,GAAAA,EAAK/W,QACA7wB,IAAAA,EAAI,EAAGoU,EAAOtU,EAAMC,OAAQC,EAAIoU,IAAQpU,EAAG,CACtCC,IAAAA,EAAOH,EAAME,GACf4nC,EAAKE,iBACLiK,EACI,CAAC/sC,EAAG/E,EAAKqwC,GAAI90B,EAAGvb,EAAKswC,IACrB,CAACvrC,EAAG/E,EAAKuwC,GAAIh1B,EAAGvb,EAAKwwC,IACrBxwC,GAGJ2nC,EAAKG,WACLgK,EACI,CAAC/sC,EAAG/E,EAAKiwC,IAAK10B,EAAGvb,EAAKkwC,KACtB,CAACnrC,EAAG/E,EAAKmwC,IAAK50B,EAAGvb,EAAKowC,KACtB,CACI3+B,MAAOzR,EAAKgoC,UACZ/pB,MAAOje,EAAK+nC,UACZE,WAAYjoC,EAAKmxC,eACjBjJ,iBAAkBloC,EAAKoxC,uBAMvCP,GAAAA,EAAW,CACLoB,IAGF5B,EAAIE,EAAID,EAAIE,EAHVyB,EAAWtK,EAAKiJ,WAAWtxC,EAAG6f,WAAW7f,EAAGurC,aAAe,IAC3DqH,EAAgBD,EAASrvB,UACzBmtB,EAAczwC,EAAGwrC,aAEnBxrC,EAAGywB,gBACHsgB,EAAKxxB,GAAYngB,EAAOY,EAAGrB,KAAM4yC,GAAaA,EAAY,EAC1DN,EAAK1xB,GAAYngB,EAAOY,EAAGpB,MAAOg0C,GAAiBA,EAAgB,EACnE5B,EAAKE,EAAKT,IAEVO,EAAKzxB,GAAYngB,EAAOY,EAAG2hB,IAAK4vB,GAAaA,EAAY,EACzDL,EAAK3xB,GAAYngB,EAAOY,EAAG4hB,OAAQgxB,GAAiBA,EAAgB,EACpE7B,EAAKE,EAAKR,GAEd+B,EACI,CAAC/sC,EAAGsrC,EAAI90B,EAAG+0B,GACX,CAACvrC,EAAGwrC,EAAIh1B,EAAGi1B,GACX,CAACvyB,MAAO4yB,EAAWp/B,MAAOwgC,EAASh7B,iBAnkKlC,CAAA,IAAA,aAukKb,MAAA,SAAWmT,GACD9qB,IAAAA,EAAK,KAEP,GADgBA,EAAG2V,QAAQ6vB,MACdlU,QAAb,CAGE5Y,IAAAA,EAAM1Y,EAAG0Y,IACT+I,EAAOzhB,EAAG6yC,oBACZpxB,GACAI,GAASnJ,EAAK+I,GAEZlhB,IACFE,EAAGoU,EADDtU,EAAQP,EAAGgrC,cAAgBhrC,EAAGgrC,YAAchrC,EAAG8yC,mBAAmBhoB,IAEnErqB,IAAAA,EAAI,EAAGoU,EAAOtU,EAAMC,OAAQC,EAAIoU,IAAQpU,EAAG,CACtCC,IAAAA,EAAOH,EAAME,GACbgvC,EAAW/uC,EAAKyX,KAGtBuK,GAAWhK,EAFGhY,EAAKwhC,MAEI,EADfxhC,EAAKsxC,WACgBvC,EAAU/uC,GAEvC+gB,GACAM,GAAWrJ,MA5lKN,CAAA,IAAA,YAgmKb,MAAA,WACWA,IAAAA,EAA4C,KAA5CA,IAA4C,EAAA,KAAvC/C,QAAU4U,EAAAA,EAAAA,SAAUse,EAAAA,EAAAA,MAAOp0B,EAAAA,EAAAA,QACnC,GAACo0B,EAAMvX,QAAP,CAGEnZ,IAAAA,EAAO8U,GAAO4b,EAAM1wB,MACpBwX,EAAU3C,GAAU6b,EAAMlZ,SAC1BrxB,EAAQuqC,EAAMvqC,MAChBkoC,EAASruB,EAAKI,WAAa,EACd,WAAbgS,GACAic,GAAU7W,EAAQ/N,OACdhd,GAAQikC,EAAMlmB,QACd6jB,GAAUruB,EAAKI,YAAcswB,EAAMlmB,KAAKniB,OAAS,KAGrDgmC,GAAU7W,EAAQhO,IAEuBoxB,IAAAA,EA7/B5CA,SAAUx5B,EAAOitB,EAAQjc,EAAUjsB,GACjCqjB,IAEH6B,EAAUwvB,EAAQC,EAFftxB,EAA4BpI,EAA5BoI,IAAKhjB,EAAuB4a,EAAvB5a,KAAMijB,EAAiBrI,EAAjBqI,OAAQhjB,EAAS2a,EAAT3a,MACtB0hB,EAAW,EAWR,OATH/G,EAAMkX,gBACNuiB,EAASz0C,EAAeD,EAAOK,EAAMC,GACrCq0C,EAASxJ,GAAelwB,EAAOgR,EAAUic,GACzChjB,EAAW5kB,EAAQD,IAEnBq0C,EAASvJ,GAAelwB,EAAOgR,EAAUic,GACzCyM,EAAS10C,EAAeD,EAAOsjB,EAAQD,GACvCrB,EAAwB,SAAbiK,GAAuBxP,GAAUA,IAEzC,CAACi4B,OAAAA,EAAQC,OAAAA,EAAQzvB,SAAAA,EAAUlD,SAAAA,GAg/BeyyB,CAAU,KAAMvM,EAAQjc,EAAUjsB,GAAxE00C,EAAAA,EAAAA,OAAQC,EAAAA,EAAAA,OAAQzvB,EAAAA,EAAAA,SAAUlD,EAAAA,EAAAA,SACjCoC,GAAWhK,EAAKmwB,EAAMlmB,KAAM,EAAG,EAAGxK,EAAM,CACpChG,MAAO02B,EAAM12B,MACbqR,SAAAA,EACAlD,SAAAA,EACA6C,UAAWonB,GAAWjsC,EAAOisB,EAAU9V,GACvC2O,aAAc,SACdH,YAAa,CAAC+vB,EAAQC,QAxnKjB,CAAA,IAAA,OA4nKb,MAAA,SAAKnoB,GACK9qB,IAAAA,EAAK,KACNA,EAAGiuC,eAGRjuC,EAAGkzC,iBACHlzC,EAAGmzC,SAASroB,GACZ9qB,EAAGozC,YACHpzC,EAAGqzC,WAAWvoB,MApoKL,CAAA,IAAA,UAuoKb,MAAA,WACU9qB,IAAAA,EAAK,KACL4iB,EAAO5iB,EAAG2V,QACV29B,EAAK1wB,EAAK4iB,OAAS5iB,EAAK4iB,MAAMzV,GAAK,EACnCwjB,EAAK3wB,EAAKylB,MAAQzlB,EAAKylB,KAAKtY,GAAK,EACnC,OAAC/vB,EAAGiuC,cAAgBqF,IAAOC,GAAMvzC,EAAGW,OAAS6pC,EAAM9sC,UAAUiD,KAQ1D,CAAC,CACJovB,EAAGwjB,EACH5yC,KAAKmqB,SAAAA,GACD9qB,EAAGkzC,iBACHlzC,EAAGmzC,SAASroB,GACZ9qB,EAAGozC,cAER,CACCrjB,EAAGujB,EACH3yC,KAAKmqB,SAAAA,GACD9qB,EAAGqzC,WAAWvoB,MAjBX,CAAC,CACJiF,EAAGujB,EACH3yC,KAAKmqB,SAAAA,GACD9qB,EAAGW,KAAKmqB,QAhpKX,CAAA,IAAA,0BAmqKb,MAAA,SAAwBvrB,GACdS,IAIFS,EAAGoU,EAHDg3B,EADK,KACMzsC,MAAMsrB,+BACjB8oB,EAFK,KAEO3pB,KAAO,SACnBlO,EAAS,GAEVlb,IAAAA,EAAI,EAAGoU,EAAOg3B,EAAMrrC,OAAQC,EAAIoU,IAAQpU,EAAG,CACtCwrB,IAAAA,EAAO4f,EAAMprC,GACfwrB,EAAKunB,KAPF,KAOiBjgC,IAAQhU,GAAQ0sB,EAAK1sB,OAASA,GAClDoc,EAAOla,KAAKwqB,GAGbtQ,OAAAA,IA/qKE,CAAA,IAAA,0BAkrKb,MAAA,SAAwB1G,GAEbgY,OAAAA,GADM,KAAKtX,QAAQ6vB,MAAM8L,WAAW,KAAKzxB,WAAW5K,IACxCkD,UAprKV,EAAA,GAwrKRs7B,SAAAA,GAAgBpT,GAAwD,IAAA,EAAhD8C,EAAW,UAAA,OAAA,QAAA,IAAA,UAAA,GAAA,UAAA,GAAA,CAAC,IAAKuQ,EAAarT,UAAAA,OAAAA,QAAAA,IAAAA,UAAAA,GAAAA,UAAAA,GAAAA,EAAQnT,EAAU,UAAA,OAAA,EAAA,UAAA,QAAA,EACxEtW,GAAQsW,KACTA,EAAWymB,GAAS,YAAatT,IAE/BvhB,IAAAA,GACD80B,EAAAA,EAAAA,GAAAA,OAAOC,YAAc,UACV,EAAA,EAAA,cAAA,GACHxT,EAAAA,EAAAA,UAAAA,GACIqT,EAAAA,EAAAA,cAAAA,GACFxmB,EAAAA,EAAAA,YAAAA,GACD,EAAA,EAAA,WAAA,SAAC9V,GAAUq8B,OAAAA,GAAiBr8B,CAAAA,GAAUipB,OAAAA,EAAAA,IAAS8C,EAAUuQ,EAAYxmB,KANnF,GAQO,OAAA,IAAI4mB,MAAMh1B,EAAO,CACpBi1B,eAAe3+B,SAAAA,EAAQyX,GAIZ,cAHAzX,EAAOyX,UACPzX,EAAO4+B,aACP3T,EAAO,GAAGxT,IACV,GAEX3rB,IAAIkU,SAAAA,EAAQyX,GACDonB,OAAAA,GAAQ7+B,EAAQyX,EACnB,WAAMqnB,OA8LbA,SAAqBrnB,EAAMsW,EAAU9C,EAAQ7L,GAC9CzhB,IAAAA,EADqD,EAEpCowB,EAAAA,EAAAA,GAFoC,IAE1B,IAAA,EAAA,MAAA,EAAA,EAAA,KAAA,MAAA,CAApBgR,IAAAA,EAAoB,EAAA,MAEvBv9B,GADJ7D,EAAQ4gC,GAASS,GAAQD,EAAQtnB,GAAOwT,GACpCzpB,GAAQ7D,GACDshC,OAAAA,GAAiBxnB,EAAM9Z,GACxBuhC,GAAkBjU,EAAQ7L,EAAO3H,EAAM9Z,GACvCA,GAP2C,MAAA,GAAA,EAAA,EAAA,GAAA,QAAA,EAAA,KA9LvCmhC,CAAqBrnB,EAAMsW,EAAU9C,EAAQjrB,MAE3Dm/B,yBAAyBn/B,SAAAA,EAAQyX,GACtB2nB,OAAAA,QAAQD,yBAAyBn/B,EAAOq/B,QAAQ,GAAI5nB,IAE/D6nB,eAAiB,WACNF,OAAAA,QAAQE,eAAerU,EAAO,KAEzCzF,IAAIxlB,SAAAA,EAAQyX,GACD8nB,OAAAA,GAAqBv/B,GAAQw/B,SAAS/nB,IAEjDgoB,QAAQz/B,SAAAA,GACGu/B,OAAAA,GAAqBv/B,IAEhC/T,IAAI+T,SAAAA,EAAQyX,EAAM9Z,GAIP,OAHPstB,EAAO,GAAGxT,GAAQ9Z,SACXqC,EAAOyX,UACPzX,EAAO4+B,OACP,KAKVc,SAAAA,GAAetgB,EAAO1c,EAASi9B,EAAUC,GACxCl2B,IAAAA,EAAQ,CACVykB,YAAY,EACZ0R,OAAQzgB,EACR0gB,SAAUp9B,EACVq9B,UAAWJ,EACXK,OAAQ,IAAI3vB,IACZjO,aAAcA,GAAagd,EAAOwgB,GAClC1D,WAAY,SAAC54B,GAAQo8B,OAAAA,GAAetgB,EAAO9b,EAAKq8B,EAAUC,IAC1DK,SAAU,SAACj+B,GAAU09B,OAAAA,GAAetgB,EAAM6gB,SAASj+B,GAAQU,EAASi9B,EAAUC,KAE3E,OAAA,IAAIlB,MAAMh1B,EAAO,CACpBi1B,eAAe3+B,SAAAA,EAAQyX,GAGZ,cAFAzX,EAAOyX,UACP2H,EAAM3H,IACN,GAEX3rB,IAAIkU,SAAAA,EAAQyX,EAAMyoB,GACPrB,OAAAA,GAAQ7+B,EAAQyX,EACnB,WAAM0oB,OAkDbA,SAAoBngC,EAAQyX,EAAMyoB,GAChCL,IAAAA,EAA0D7/B,EAA1D6/B,OAAQC,EAAkD9/B,EAAlD8/B,SAAUC,EAAwC//B,EAAxC+/B,UAAyBp+B,EAAe3B,EAA7BoC,aAChCzE,EAAQkiC,EAAOpoB,GACfhW,GAAW9D,IAAUgE,EAAYy+B,aAAa3oB,KAC9C9Z,EAWC0iC,SAAmB5oB,EAAM9Z,EAAOqC,EAAQkgC,GACtCL,IAAAA,EAAuC7/B,EAAvC6/B,OAAQC,EAA+B9/B,EAA/B8/B,SAAUC,EAAqB//B,EAArB+/B,UAAWC,EAAUhgC,EAAVggC,OAChCA,GAAAA,EAAOxa,IAAI/N,GACL,MAAA,IAAI6oB,MAAM,uBAAyB,EAAIN,GAAQO,KAAK,MAAQ,KAAO9oB,GAE7EuoB,EAAO1vB,IAAImH,GACX9Z,EAAQA,EAAMmiC,EAAUC,GAAaG,GACrCF,EAAOpzC,OAAO6qB,GACVlZ,GAASZ,KACTA,EAAQuhC,GAAkBW,EAAOR,QAASQ,EAAQpoB,EAAM9Z,IAErDA,OAAAA,EAtBK0iC,CAAmB5oB,EAAM9Z,EAAOqC,EAAQkgC,IAEhD1wC,GAAQmO,IAAUA,EAAMvS,SACxBuS,EAsBC6iC,SAAc/oB,EAAM9Z,EAAOqC,EAAQygC,GACjCZ,IAAAA,EAA0D7/B,EAA1D6/B,OAAQC,EAAkD9/B,EAAlD8/B,SAAUC,EAAwC//B,EAAxC+/B,UAAyBp+B,EAAe3B,EAA7BoC,aAChCZ,GAAAA,GAAQs+B,EAASjgC,QAAU4gC,EAAYhpB,GACvC9Z,EAAQA,EAAMmiC,EAASjgC,MAAQlC,EAAMvS,aAClC,GAAImT,GAASZ,EAAM,IAAK,CACrBmxB,IAAAA,EAAMnxB,EACNstB,EAAS4U,EAAOR,QAAQ7mB,OAAO,SAAA1pB,GAAKA,OAAAA,IAAMggC,IAChDnxB,EAAQ,GACWmxB,IAJQ,EAIRA,EAAAA,EAAAA,GAJQ,IAIH,IAAA,EAAA,MAAA,EAAA,EAAA,KAAA,MAAA,CAAbxjC,IAAAA,EAAa,EAAA,MACdo1C,EAAWxB,GAAkBjU,EAAQ4U,EAAQpoB,EAAMnsB,GACzDqS,EAAMtR,KAAKqzC,GAAegB,EAAUZ,EAAUC,GAAaA,EAAUtoB,GAAO9V,KANrD,MAAA,GAAA,EAAA,EAAA,GAAA,QAAA,EAAA,KASxBhE,OAAAA,EAnCK6iC,CAAc/oB,EAAM9Z,EAAOqC,EAAQ2B,EAAY8+B,cAEvDxB,GAAiBxnB,EAAM9Z,KACvBA,EAAQ+hC,GAAe/hC,EAAOmiC,EAAUC,GAAaA,EAAUtoB,GAAO9V,IAEnEhE,OAAAA,EA9DWwiC,CAAoBngC,EAAQyX,EAAMyoB,MAEhDf,yBAAyBn/B,SAAAA,EAAQyX,GACtBzX,OAAAA,EAAOoC,aAAau+B,QACrBvB,QAAQ5Z,IAAIpG,EAAO3H,GAAQ,CAAC1S,YAAY,EAAM8K,cAAc,QAAQ9lB,EACpEq1C,QAAQD,yBAAyB/f,EAAO3H,IAElD6nB,eAAiB,WACNF,OAAAA,QAAQE,eAAelgB,IAElCoG,IAAIxlB,SAAAA,EAAQyX,GACD2nB,OAAAA,QAAQ5Z,IAAIpG,EAAO3H,IAE9BgoB,QAAU,WACCL,OAAAA,QAAQK,QAAQrgB,IAE3BnzB,IAAI+T,SAAAA,EAAQyX,EAAM9Z,GAGP,OAFPyhB,EAAM3H,GAAQ9Z,SACPqC,EAAOyX,IACP,KAKVrV,SAAAA,GAAagd,GAAOjd,IAAAA,EAAW,UAAA,OAAA,QAAA,IAAA,UAAA,GAAA,UAAA,GAAA,CAACy+B,YAAY,EAAMC,WAAW,GACwCzhB,EAAAA,EAAnGna,YAAAA,OAAc9C,IAAAA,EAAAA,EAASy+B,WAD2C,EACiCxhB,EAAAA,EAAhEja,WAAAA,OAAahD,IAAAA,EAAAA,EAAS0+B,UADS,EACiCzhB,EAAAA,EAA/B0hB,SACpE,MAAA,CACHH,aAFkFx+B,IAAAA,EAAAA,EAASw+B,QADtB,EAIrEC,WAAY37B,EACZ47B,UAAW17B,EACXi7B,aAAc3+B,GAAWwD,GAAeA,EAAc,WAAMA,OAAAA,GAC5Dw7B,YAAah/B,GAAW0D,GAAcA,EAAa,WAAMA,OAAAA,IAI3D65B,IAAAA,GAAU,SAACD,EAAQx6B,GAASw6B,OAAAA,EAASA,EAASz9B,GAAYiD,GAAQA,GAClE06B,GAAmB,SAACxnB,EAAM9Z,GAAUY,OAAAA,GAASZ,IAAmB,aAAT8Z,GAEpDonB,SAAAA,GAAQ7+B,EAAQyX,EAAMM,GACvBpa,IAAAA,EAAQqC,EAAOyX,GACfjW,OAAAA,GAAQ7D,GACDA,GAEXA,EAAQoa,IACJvW,GAAQ7D,KACRqC,EAAOyX,GAAQ9Z,GAEZA,GAgDFojC,SAAAA,GAAgBjpB,EAAUL,EAAM9Z,GAC9B8D,OAAAA,GAAWqW,GAAYA,EAASL,EAAM9Z,GAASma,EAGpDkpB,IAAAA,GAAW,SAAC5gC,EAAKqQ,GAAWrQ,OAAQ,IAARA,EAAeqQ,EAC5B,iBAARrQ,EAAmBgB,GAAiBqP,EAAQrQ,QAAOrW,GAEvDk3C,SAAAA,GAAUh1C,EAAKi1C,EAAc9gC,EAAK+gC,GAClBD,IADkC,EAClCA,EAAAA,EAAAA,GADkC,IACpB,IAAA,EAAA,MAAA,EAAA,EAAA,KAAA,MAAA,CAAxBzwB,IAAAA,EAAwB,EAAA,MACzBzO,EAAQg/B,GAAS5gC,EAAKqQ,GACxBzO,GAAAA,EAAO,CACP/V,EAAIqkB,IAAItO,GACF8V,IAAAA,EAAWipB,GAAgB/+B,EAAMoD,UAAWhF,EAAK4B,GACnDR,GAAAA,GAAQsW,IAAaA,IAAa1X,GAAO0X,IAAaqpB,EAC/CrpB,OAAAA,OAER,IAAc,IAAV9V,GAAmBR,GAAQ2/B,IAAmB/gC,IAAQ+gC,EACtD,OAAA,MAVwC,MAAA,GAAA,EAAA,EAAA,GAAA,QAAA,EAAA,IAahD,OAAA,EAGFjC,SAAAA,GAAkBgC,EAAcR,EAAUjpB,EAAM9Z,GAC/C2gC,IAAAA,EAAaoC,EAASU,YACtBtpB,EAAWipB,GAAgBL,EAASt7B,UAAWqS,EAAM9Z,GACrD0jC,EAAgBH,GAAAA,OAAAA,EAAAA,GAAiB5C,EAAAA,IACjCryC,EAAM,IAAIokB,IACVixB,EAAcJ,EAAa,IAC7B3iC,GAAS+iC,IAAkB7pB,KAAQ6pB,GACnCr1C,EAAIqkB,IAAIgxB,EAAY7pB,GAAQ,IAEhCxrB,EAAIqkB,IAAI3S,GACJyC,IAAAA,EAAMmhC,GAAiBt1C,EAAKo1C,EAAW5pB,EAAMK,GAAYL,GACzDrX,OAAQ,OAARA,MAGAoB,GAAQsW,IAAaA,IAAaL,GAEtB,QADZrX,EAAMmhC,GAAiBt1C,EAAKo1C,EAAWvpB,EAAU1X,MAK9Ci+B,GAAoBpyC,EAAAA,GAAM,CAAC,IAAKqyC,EAAYxmB,IAG9CypB,SAAAA,GAAiBt1C,EAAKo1C,EAAWjhC,EAAK0X,GACpC1X,KAAAA,GACHA,EAAM6gC,GAAUh1C,EAAKo1C,EAAWjhC,EAAK0X,GAElC1X,OAAAA,EAeFm+B,SAAAA,GAASn+B,EAAK6qB,GACCA,IADO,EACPA,EAAAA,EAAAA,GADO,IACC,IAAA,EAAA,MAAA,EAAA,EAAA,KAAA,MAAA,CAAjBjpB,IAAAA,EAAiB,EAAA,MACpB,GAACA,EAAD,CAGErE,IAAAA,EAAQqE,EAAM5B,GAChBoB,GAAAA,GAAQ7D,GACDA,OAAAA,IAPY,MAAA,GAAA,EAAA,EAAA,GAAA,QAAA,EAAA,KAYtB4hC,SAAAA,GAAqBv/B,GACtB3E,IAAAA,EAAO2E,EAAO4+B,MAIXvjC,OAHFA,IACDA,EAAO2E,EAAO4+B,MAKb4C,SAAyBvW,GACxBh/B,IADgC,EAChCA,EAAM,IAAIokB,IACI4a,EAAAA,EAAAA,GAFkB,IAEV,IAAA,EAAA,MAAA,EAAA,EAAA,KAAA,MAAA,CAAjBjpB,IAAiB,EAAjBA,EAAiB,EAAA,MACN1G,EAAAA,EAAAA,OAAOD,KAAK2G,GAAOwW,OAAO,SAAAxpB,GAAK,OAACA,EAAEkW,WAAW,QADvC,IAC8C,IAAA,EAAA,MAAA,EAAA,EAAA,KAAA,MAAA,CAA3D9E,IAAAA,EAA2D,EAAA,MAClEnU,EAAIqkB,IAAIlQ,IAFY,MAAA,GAAA,EAAA,EAAA,GAAA,QAAA,EAAA,MAFU,MAAA,GAAA,EAAA,EAAA,GAAA,QAAA,EAAA,IAO3BnU,OAAAA,EAAAA,GAZeu1C,CAAyBxhC,EAAOq/B,UAEnDhkC,EAaLomC,IAAAA,GAAUhjC,OAAOgjC,SAAW,MAC5BC,GAAW,SAACC,EAAQt2C,GAAMA,OAAAA,EAAIs2C,EAAOv2C,SAAWu2C,EAAOt2C,GAAGkqB,MAAQosB,EAAOt2C,IAEtEu2C,SAAAA,GAAYC,EAAYC,EAAaC,EAAYvhB,GAChD3T,IAAAA,EAAWg1B,EAAWtsB,KAAOusB,EAAcD,EAC3CG,EAAUF,EACVzP,EAAO0P,EAAWxsB,KAAOusB,EAAcC,EACvCE,EAAM95B,GAAsB65B,EAASn1B,GACrCq1B,EAAM/5B,GAAsBkqB,EAAM2P,GACpCG,EAAMF,GAAOA,EAAMC,GACnBE,EAAMF,GAAOD,EAAMC,GAGjBG,EAAK7hB,GAFX2hB,EAAMx7B,MAAMw7B,GAAO,EAAIA,GAGjBG,EAAK9hB,GAFX4hB,EAAMz7B,MAAMy7B,GAAO,EAAIA,GAGhB,MAAA,CACHv1B,SAAU,CACNxc,EAAG2xC,EAAQ3xC,EAAIgyC,GAAMhQ,EAAKhiC,EAAIwc,EAASxc,GACvCwW,EAAGm7B,EAAQn7B,EAAIw7B,GAAMhQ,EAAKxrB,EAAIgG,EAAShG,IAE3CwrB,KAAM,CACFhiC,EAAG2xC,EAAQ3xC,EAAIiyC,GAAMjQ,EAAKhiC,EAAIwc,EAASxc,GACvCwW,EAAGm7B,EAAQn7B,EAAIy7B,GAAMjQ,EAAKxrB,EAAIgG,EAAShG,KAwD1C07B,SAAAA,GAAoBZ,GACnBa,IAGFn3C,EAAGo3C,EAAaC,EAHdF,EAAYb,EAAOv2C,OACnBu3C,EAASt6C,MAAMm6C,GAAWx2B,KAAK,GAC/B42B,EAAKv6C,MAAMm6C,GAEbK,EAAanB,GAASC,EAAQ,GAC7Bt2C,IAAAA,EAAI,EAAGA,EAAIm3C,IAAan3C,EAIrB,GAHJo3C,EAAcC,EACdA,EAAeG,EACfA,EAAanB,GAASC,EAAQt2C,EAAI,GAC7Bq3C,EAAD,CAGAG,GAAAA,EAAY,CACNC,IAAAA,EAAeD,EAAWxyC,EAAIqyC,EAAaryC,EACjDsyC,EAAOt3C,GAAqB,IAAhBy3C,GAAqBD,EAAWh8B,EAAI67B,EAAa77B,GAAKi8B,EAAc,EAEpFF,EAAGv3C,GAAMo3C,EACFI,EACI98B,GAAK48B,EAAOt3C,EAAI,MAAQ0a,GAAK48B,EAAOt3C,IAAO,GACvCs3C,EAAOt3C,EAAI,GAAKs3C,EAAOt3C,IAAM,EAFxBs3C,EAAOt3C,EAAI,GADRs3C,EAAOt3C,IApE7B03C,SAAepB,EAAQgB,EAAQC,GAI/B,IAHCJ,IACFQ,EAAQC,EAAOC,EAAMC,EAAkBT,EADrCF,EAAYb,EAAOv2C,OAErBy3C,EAAanB,GAASC,EAAQ,GACzBt2C,EAAI,EAAGA,EAAIm3C,EAAY,IAAKn3C,EACjCq3C,EAAeG,EACfA,EAAanB,GAASC,EAAQt2C,EAAI,GAC7Bq3C,GAAiBG,IAGlBj8B,GAAa+7B,EAAOt3C,GAAI,EAAGo2C,IAC3BmB,EAAGv3C,GAAKu3C,EAAGv3C,EAAI,GAAK,GAGxB23C,EAASJ,EAAGv3C,GAAKs3C,EAAOt3C,GACxB43C,EAAQL,EAAGv3C,EAAI,GAAKs3C,EAAOt3C,IAC3B83C,EAAmBz4C,KAAKwb,IAAI88B,EAAQ,GAAKt4C,KAAKwb,IAAI+8B,EAAO,KACjC,IAGxBC,EAAO,EAAIx4C,KAAK8b,KAAK28B,GACrBP,EAAGv3C,GAAK23C,EAASE,EAAOP,EAAOt3C,GAC/Bu3C,EAAGv3C,EAAI,GAAK43C,EAAQC,EAAOP,EAAOt3C,MAmDtC03C,CAAepB,EAAQgB,EAAQC,GA/C1BQ,SAAgBzB,EAAQiB,GAIxB,IAHCJ,IACFtsB,EAAQusB,EAAaC,EADnBF,EAAYb,EAAOv2C,OAErBy3C,EAAanB,GAASC,EAAQ,GACzBt2C,EAAI,EAAGA,EAAIm3C,IAAan3C,EAIzB,GAHJo3C,EAAcC,EACdA,EAAeG,EACfA,EAAanB,GAASC,EAAQt2C,EAAI,GAC7Bq3C,EAAD,CAGWA,IAAAA,EAAAA,EAARryC,EAAAA,EAAAA,EAAGwW,EAAAA,EAAAA,EACN47B,IACAvsB,GAAU7lB,EAAIoyC,EAAYpyC,GAAK,EAC/BqyC,EAAax1B,KAAO7c,EAAI6lB,EACxBwsB,EAAat1B,KAAOvG,EAAIqP,EAAS0sB,EAAGv3C,IAEpCw3C,IACA3sB,GAAU2sB,EAAWxyC,EAAIA,GAAK,EAC9BqyC,EAAav1B,KAAO9c,EAAI6lB,EACxBwsB,EAAar1B,KAAOxG,EAAIqP,EAAS0sB,EAAGv3C,KA4B5C+3C,CAAgBzB,EAAQiB,GAGnBS,SAAAA,GAAgBC,EAAI34C,EAAK8B,GACvB/B,OAAAA,KAAK+B,IAAI/B,KAAKC,IAAI24C,EAAI72C,GAAM9B,GAyB9B44C,SAAAA,GAA2B5B,EAAQphC,EAAS8L,EAAMuX,GACnDv4B,IAAAA,EAAGoU,EAAM2M,EAAOo3B,EAIhBjjC,GAHAA,EAAQkjC,WACR9B,EAASA,EAAOnpB,OAAO,SAAC8qB,GAAO,OAACA,EAAG/tB,QAEA,aAAnChV,EAAQmjC,uBACRnB,GAAoBZ,OACjB,CACCrW,IAAAA,EAAO1H,EAAO+d,EAAOA,EAAOv2C,OAAS,GAAKu2C,EAAO,GAChDt2C,IAAAA,EAAI,EAAGoU,EAAOkiC,EAAOv2C,OAAQC,EAAIoU,IAAQpU,EAE1Cm4C,EAAgB5B,GACZtW,EAFJlf,EAAQu1B,EAAOt2C,GAIXs2C,EAAOj3C,KAAKC,IAAIU,EAAI,EAAGoU,GAAQmkB,EAAO,EAAI,IAAMnkB,GAChDc,EAAQojC,SAEZv3B,EAAMc,KAAOs2B,EAAc32B,SAASxc,EACpC+b,EAAMgB,KAAOo2B,EAAc32B,SAAShG,EACpCuF,EAAMe,KAAOq2B,EAAcnR,KAAKhiC,EAChC+b,EAAMiB,KAAOm2B,EAAcnR,KAAKxrB,EAChCykB,EAAOlf,EAGX7L,EAAQqjC,iBA9CPA,SAAgBjC,EAAQt1B,GACzBhhB,IAAAA,EAAGoU,EAAM2M,EAAOy3B,EAAQC,EACxBC,EAAa53B,GAAew1B,EAAO,GAAIt1B,GACtChhB,IAAAA,EAAI,EAAGoU,EAAOkiC,EAAOv2C,OAAQC,EAAIoU,IAAQpU,EAC1Cy4C,EAAaD,EACbA,EAASE,EACTA,EAAa14C,EAAIoU,EAAO,GAAK0M,GAAew1B,EAAOt2C,EAAI,GAAIghB,GACtDw3B,IAGLz3B,EAAQu1B,EAAOt2C,GACXy4C,IACA13B,EAAMc,KAAOm2B,GAAgBj3B,EAAMc,KAAMb,EAAK9iB,KAAM8iB,EAAK7iB,OACzD4iB,EAAMgB,KAAOi2B,GAAgBj3B,EAAMgB,KAAMf,EAAKE,IAAKF,EAAKG,SAExDu3B,IACA33B,EAAMe,KAAOk2B,GAAgBj3B,EAAMe,KAAMd,EAAK9iB,KAAM8iB,EAAK7iB,OACzD4iB,EAAMiB,KAAOg2B,GAAgBj3B,EAAMiB,KAAMhB,EAAKE,IAAKF,EAAKG,UA8B5Do3B,CAAgBjC,EAAQt1B,GAIvB23B,SAAAA,GAAaj0C,EAAIC,EAAIwwB,EAAG7c,GACtB,MAAA,CACHtT,EAAGN,EAAGM,EAAImwB,GAAKxwB,EAAGK,EAAIN,EAAGM,GACzBwW,EAAG9W,EAAG8W,EAAI2Z,GAAKxwB,EAAG6W,EAAI9W,EAAG8W,IAIxBo9B,SAAAA,GAAsBl0C,EAAIC,EAAIwwB,EAAG7c,GAC/B,MAAA,CACHtT,EAAGN,EAAGM,EAAImwB,GAAKxwB,EAAGK,EAAIN,EAAGM,GACzBwW,EAAY,WAATlD,EAAoB6c,EAAI,GAAMzwB,EAAG8W,EAAI7W,EAAG6W,EAC5B,UAATlD,EAAmB6c,EAAI,EAAIzwB,EAAG8W,EAAI7W,EAAG6W,EACjC2Z,EAAI,EAAIxwB,EAAG6W,EAAI9W,EAAG8W,GAI3Bq9B,SAAAA,GAAqBn0C,EAAIC,EAAIwwB,EAAG7c,GAC/BwgC,IAAAA,EAAM,CAAC9zC,EAAGN,EAAGod,KAAMtG,EAAG9W,EAAGsd,MACzB+2B,EAAM,CAAC/zC,EAAGL,EAAGkd,KAAMrG,EAAG7W,EAAGod,MACzBhgB,EAAI42C,GAAaj0C,EAAIo0C,EAAK3jB,GAC1BnzB,EAAI22C,GAAaG,EAAKC,EAAK5jB,GAC3BlzB,EAAI02C,GAAaI,EAAKp0C,EAAIwwB,GAC1BjzB,EAAIy2C,GAAa52C,EAAGC,EAAGmzB,GACvBhzB,EAAIw2C,GAAa32C,EAAGC,EAAGkzB,GACtBwjB,OAAAA,GAAaz2C,EAAGC,EAAGgzB,GAGxB6jB,IAAAA,GAAwB,SAAUC,EAAO/6B,GACpC,MAAA,CACHlZ,EAAEA,SAAAA,GACSi0C,OAAAA,EAAQA,EAAQ/6B,EAAQlZ,GAEnCk0C,SAASp1C,SAAAA,GACLoa,EAAQpa,GAEZ4e,UAAU7kB,SAAAA,GACFA,MAAU,WAAVA,EACOA,EAEM,UAAVA,EAAoB,OAAS,SAExCs7C,MAAMn0C,SAAAA,EAAGsN,GACEtN,OAAAA,EAAIsN,GAEf8mC,WAAWp0C,SAAAA,EAAGq0C,GACHr0C,OAAAA,EAAIq0C,KAIjBC,GAAwB,WACnB,MAAA,CACHt0C,EAAEA,SAAAA,GACSA,OAAAA,GAEXk0C,SAASp1C,SAAAA,KAET4e,UAAU7kB,SAAAA,GACCA,OAAAA,GAEXs7C,MAAMn0C,SAAAA,EAAGsN,GACEtN,OAAAA,EAAIsN,GAEf8mC,WAAWp0C,SAAAA,EAAGu0C,GACHv0C,OAAAA,KAKVw0C,SAAAA,GAAcC,EAAKR,EAAO/6B,GACxBu7B,OAAAA,EAAMT,GAAsBC,EAAO/6B,GAASo7B,KAG9CI,SAAAA,GAAsBzhC,EAAK0hC,GAC5B9hC,IAAAA,EAAO+hC,EACO,QAAdD,GAAqC,QAAdA,IAEvBC,EAAW,EADX/hC,EAAQI,EAAIkH,OAAOtH,OAETkO,iBAAiB,aACvBlO,EAAMgiC,oBAAoB,cAE9BhiC,EAAMiiC,YAAY,YAAaH,EAAW,aAC1C1hC,EAAI8hC,kBAAoBH,GAIvBI,SAAAA,GAAqB/hC,EAAK2hC,QACdl7C,IAAbk7C,WACO3hC,EAAI8hC,kBACX9hC,EAAIkH,OAAOtH,MAAMiiC,YAAY,YAAaF,EAAS,GAAIA,EAAS,KAI/DK,SAAAA,GAAWl+B,GACZA,MAAa,UAAbA,EACO,CACHm+B,QAAS/8B,GACTg9B,QAASl9B,GACTm9B,UAAWl9B,IAGZ,CACHg9B,QAAS,SAACx2C,EAAGD,EAAGtB,GAAMuB,OAAAA,GAAKD,GAAKC,GAAKvB,GACrCg4C,QAAS,SAACp4C,EAAGC,GAAMD,OAAAA,EAAIC,GACvBo4C,UAAW,SAAAp1C,GAAKA,OAAAA,IAIfq1C,SAAAA,GAAet8C,EAAOC,EAAKu6B,EAAMwH,GAC/B,MAAA,CACHhiC,MAAOA,EAAQgiC,EACf/hC,IAAKA,EAAM+hC,EACXxH,KAAMA,IAASv6B,EAAMD,EAAQ,GAAKgiC,GAAU,GA6B3Cua,SAAAA,GAAcC,EAASjE,EAAQ3O,GAChC,IAACA,EACM,MAAA,CAAC4S,GAcP,IAZEx+B,IAOHzJ,EAAOyO,EAAOy5B,EAPXz+B,EAA8C4rB,EAA9C5rB,SAAiB0+B,EAA6B9S,EAApC5pC,MAAwB28C,EAAY/S,EAAjB3pC,IAC9B+hC,EAAQuW,EAAOv2C,OACiBk6C,EAAAA,GAAWl+B,GAA1Co+B,EAAAA,EAAAA,QAASD,EAAAA,EAAAA,QAASE,EAAAA,EAAAA,UACEO,EAhCtBA,SAAWJ,EAASjE,EAAQ3O,GAC1B5rB,IAIH/b,EAAGoU,EAJA2H,EAA8C4rB,EAA9C5rB,SAAiB0+B,EAA6B9S,EAApC5pC,MAAwB28C,EAAY/S,EAAjB3pC,IACPi8C,EAAAA,GAAWl+B,GAAjCm+B,EAAAA,EAAAA,QAASE,EAAAA,EAAAA,UACVra,EAAQuW,EAAOv2C,OAChBhC,EAAoBw8C,EAApBx8C,MAAOC,EAAau8C,EAAbv8C,IAAKu6B,EAAQgiB,EAARhiB,KAEbA,GAAAA,EAAM,CAGDv4B,IAFLjC,GAASgiC,EACT/hC,GAAO+hC,EACF//B,EAAI,EAAGoU,EAAO2rB,EAAO//B,EAAIoU,GACrB8lC,EAAQE,EAAU9D,EAAOv4C,EAAQgiC,GAAOhkB,IAAY0+B,EAAYC,KADnC16C,EAIlCjC,IACAC,IAEJD,GAASgiC,EACT/hC,GAAO+hC,EAKJ,OAHH/hC,EAAMD,IACNC,GAAO+hC,GAEJ,CAAChiC,MAAAA,EAAOC,IAAAA,EAAKu6B,KAAAA,GAUOoiB,CAAWJ,EAASjE,EAAQ3O,GAAhD5pC,EAAAA,EAAAA,MAAOC,EAAAA,EAAAA,IAAKu6B,EAAAA,EAAAA,KACbrd,EAAS,GACX0/B,GAAS,EACTC,EAAW,KAITC,EAAc,WAAMF,OAAAA,GAFEV,EAAQO,EAAYD,EAAWloC,IAA6C,IAAnC6nC,EAAQM,EAAYD,IAGnFO,EAAa,WAAM,OAACH,GAF6B,IAA7BT,EAAQO,EAAUpoC,IAAgB4nC,EAAQQ,EAAUF,EAAWloC,IAGhFtS,EAAIjC,EAAOkiC,EAAOliC,EAAOiC,GAAKhC,IAAOgC,GAC1C+gB,EAAQu1B,EAAOt2C,EAAI+/B,IACT7V,OAGV5X,EAAQ8nC,EAAUr5B,EAAMhF,IACxB6+B,EAASV,EAAQ5nC,EAAOmoC,EAAYC,GACnB,OAAbG,GAAqBC,MACrBD,EAA0C,IAA/BV,EAAQ7nC,EAAOmoC,GAAoBz6C,EAAIigC,GAErC,OAAb4a,GAAqBE,MACrB7/B,EAAOla,KAAKq5C,GAAeQ,EAAU76C,EAAGu4B,EAAMwH,IAC9C8a,EAAW,MAEf5a,EAAOjgC,EACPw6C,EAAYloC,GAKT4I,OAHU,OAAb2/B,GACA3/B,EAAOla,KAAKq5C,GAAeQ,EAAU78C,EAAKu6B,EAAMwH,IAE7C7kB,EAGF8/B,SAAAA,GAAe54B,EAAMulB,GAGrB,IAFCzsB,IAAAA,EAAS,GACT+/B,EAAW74B,EAAK64B,SACbj7C,EAAI,EAAGA,EAAIi7C,EAASl7C,OAAQC,IAAK,CAChCk7C,IAAAA,EAAMZ,GAAcW,EAASj7C,GAAIoiB,EAAKk0B,OAAQ3O,GAChDuT,EAAIn7C,QACJmb,EAAOla,KAAPka,MAAAA,EAAeggC,EAAAA,IAGhBhgC,OAAAA,EAqDFigC,SAAAA,GAAiB/4B,GAChBk0B,IAAAA,EAASl0B,EAAKk0B,OACd8B,EAAWh2B,EAAKlN,QAAQkjC,SACxBrY,EAAQuW,EAAOv2C,OACjB,IAACggC,EACM,MAAA,GAELxH,IAAAA,IAASnW,EAAKkW,MACC8iB,EA1DhBA,SAAgB9E,EAAQvW,EAAOxH,EAAM6f,GACtCr6C,IAAAA,EAAQ,EACRC,EAAM+hC,EAAQ,EACdxH,GAAAA,IAAS6f,EACFr6C,KAAAA,EAAQgiC,IAAUuW,EAAOv4C,GAAOmsB,MACnCnsB,IAGDA,KAAAA,EAAQgiC,GAASuW,EAAOv4C,GAAOmsB,MAClCnsB,IAMGC,IAJPD,GAASgiC,EACLxH,IACAv6B,GAAOD,GAEJC,EAAMD,GAASu4C,EAAOt4C,EAAM+hC,GAAO7V,MACtClsB,IAGG,MAAA,CAACD,MAAAA,EAAOC,IADfA,GAAO+hC,GAwCcqb,CAAgB9E,EAAQvW,EAAOxH,EAAM6f,GAAnDr6C,EAAAA,EAAAA,MAAOC,EAAAA,EAAAA,IACVo6C,OAAa,IAAbA,EACO,CAAC,CAACr6C,MAAAA,EAAOC,IAAAA,EAAKu6B,KAAAA,IAtCpB8iB,SAAc/E,EAAQv4C,EAAOqD,EAAKm3B,GACjCwH,IAIF/hC,EAJE+hC,EAAQuW,EAAOv2C,OACfmb,EAAS,GACX0rB,EAAO7oC,EACPkiC,EAAOqW,EAAOv4C,GAEbC,IAAAA,EAAMD,EAAQ,EAAGC,GAAOoD,IAAOpD,EAAK,CAC/BmD,IAAAA,EAAMm1C,EAAOt4C,EAAM+hC,GACrB5+B,EAAI+oB,MAAQ/oB,EAAIm6C,KACXrb,EAAK/V,OACNqO,GAAO,EACPrd,EAAOla,KAAK,CAACjD,MAAOA,EAAQgiC,EAAO/hC,KAAMA,EAAM,GAAK+hC,EAAOxH,KAAAA,IAC3Dx6B,EAAQ6oC,EAAOzlC,EAAIm6C,KAAOt9C,EAAM,OAGpC4oC,EAAO5oC,EACHiiC,EAAK/V,OACLnsB,EAAQC,IAGhBiiC,EAAO9+B,EAKJ+Z,OAHM,OAAT0rB,GACA1rB,EAAOla,KAAK,CAACjD,MAAOA,EAAQgiC,EAAO/hC,IAAK4oC,EAAO7G,EAAOxH,KAAAA,IAEnDrd,EAiBAmgC,CAAc/E,EAAQv4C,EAFjBC,EAAMD,EAAQC,EAAM+hC,EAAQ/hC,IACjBokB,EAAKm5B,WAAuB,IAAVx9C,GAAeC,IAAQ+hC,EAAQ,GAIxEyb,IAAAA,GAAuBvrC,OAAO6gB,OAAO,CACrCmE,UAAW,KACXwmB,cAAenmB,GACf5jB,MAAOA,EACPe,cAAeA,EACfG,KAAMA,GACNC,IAAKA,GACLE,cAAeA,GACf5O,QAASA,GACT+O,SAAUA,GACVG,SAAUF,GACVG,gBAAiBA,GACjBE,eAAgBA,GAChBC,aAAcA,GACdI,YAAaA,GACbrX,SAAUA,GACVsX,KAAMA,GACNG,eAAgBA,GAChBQ,MAAOA,GACPQ,QAASA,GACTI,MAAOA,GACPG,QAASA,GACTC,UAAWA,GACXimC,YAl4JKA,SAAY/kC,EAAOrE,EAAOkP,EAAUm1B,QAC3Bj4C,IAAV4T,GACAqpC,QAAQC,KAAKjlC,EAAQ,MAAQ6K,EACzB,gCAAkCm1B,EAAU,cAg4JpD5gC,iBAAkBA,GAClBE,YAAaA,GACbE,QAASA,GACTC,WAAYA,GACZsH,aAAcA,GACdC,aAAcA,GACdQ,aAAcA,GACdW,YAAaA,GACbI,YAAaA,GACbM,UAAWA,GACXsB,eAAgBA,GAChBM,SAAUA,GACVE,WAAYA,GACZC,eAAgBA,GAChBI,eAAgBA,GAChBM,WAAYA,GACZyB,QAASA,GACTM,aAAcA,GACdC,cAAeA,GACfC,eAAgBA,GAChBE,kBAAmBA,GACnBS,oBAAqBA,GACrBE,aAAcA,GACdiuB,gBAAiBA,GACjBqB,eAAgBA,GAChBt9B,aAAcA,GACdw/B,YAAaA,GACbW,oBAAqBA,GACrBgB,2BAA4BA,GAC5BhzB,eAAgBA,GAChBW,SAAUA,GACVoD,oBAAqB3C,GACrBgB,eAAgBA,GAChBc,YAAaA,GACbK,6BAA8BA,GAC9BK,aAAcA,GACdmmB,WA/4LKA,SAAW4M,EAAWC,EAAWC,GAC/BD,OAAAA,EAAY,IAAMD,EAAY,MAAQE,GA+4L7Cz/C,iBAAkBA,EAClBI,UAAWA,EACXa,SAAUA,EACVK,mBAAoBA,EACpBE,eAAgBA,EAChBG,OAAQA,EACR06C,aAAcA,GACdC,sBAAuBA,GACvBC,qBAAsBA,GACtB3U,aAAcA,GACdpY,aAAcA,GACdO,OAAQA,GACRC,cAAeA,GACfC,UAAWA,GACXC,OAAQA,GACRE,QAASA,GACTI,UAAWA,GACX9S,GAAIA,GACJC,IAAKA,GACLC,MAAOA,GACPC,SAAUA,GACVE,YAAaA,GACbC,QAASA,GACTC,WAAYA,GACZC,cAAeA,GACfC,MAAOA,GACPC,KAAMA,GACNC,QAASA,GACTM,WAAYA,GACZI,SAAUA,GACVE,aAAcA,GACdI,YAAaA,GACbE,mBAAoBA,GACpBG,UAAWA,GACXE,UAAWA,GACXE,eAAgBA,GAChBC,kBAAmBA,GACnBS,sBAAuBA,GACvBG,WAAYA,GACZC,gBAAiBA,GACjBC,cAAeA,GACfK,YAAaA,GACbC,YAAaA,GACb+7B,cAAeA,GACfE,sBAAuBA,GACvBM,qBAAsBA,GACtBM,cAAeA,GACfU,eAAgBA,GAChBG,iBAAkBA,KAGhBa,GAt8LW,WAu8LDl9C,SAAAA,EAAAA,EAAM6X,EAAOi+B,GAAU,EAAA,KAAA,GAC1B91C,KAAAA,KAAOA,EACP6X,KAAAA,MAAQA,EACRi+B,KAAAA,SAAWA,EACX90C,KAAAA,MAAQmQ,OAAO2E,OAAO,MA38LlB,OAAA,EAAA,EAAA,CAAA,CAAA,IAAA,YA88Lb,MAAA,SAAU9V,GACCmR,OAAAA,OAAOhT,UAAUg/C,cAAc9+C,KAAK,KAAK2B,KAAK7B,UAAW6B,EAAK7B,aA/8L5D,CAAA,IAAA,WAk9Lb,MAAA,SAASgD,GACCV,IAEF28C,EADEvrC,EAAQV,OAAOgkC,eAAeh0C,IAqEnCk8C,SAAkBxrC,GAChB,MAAA,OAAQA,GAAS,aAAcA,GApE9BwrC,CAAkBxrC,KAClBurC,EAJO,KAIUE,SAASzrC,IAExB7Q,IAAAA,EANK,KAMMA,MACXgT,EAAK7S,EAAK6S,GACV6D,EARK,KAQMA,MAAQ,IAAM7D,EAC3B,IAACA,EACK,MAAA,IAAImiC,MAAM,2BAA6Bh1C,GAE7C6S,OAAAA,KAAMhT,EACC6W,GAEX7W,EAAMgT,GAAM7S,EA4BXo8C,SAAiBp8C,EAAM0W,EAAOulC,GAC7BI,IAAAA,EAAejnC,GAAMpF,OAAO2E,OAAO,MAAO,CAC5CsnC,EAAcplC,GAASrW,IAAIy7C,GAAe,GAC1CplC,GAASrW,IAAIkW,GACb1W,EAAK6W,WAETA,GAASlW,IAAI+V,EAAO2lC,GAChBr8C,EAAK+jC,eAQJuY,SAAc5lC,EAAO6lC,GAC1BvsC,OAAOD,KAAKwsC,GAAQr9C,QAAQ,SAAA4c,GAClB0gC,IAAAA,EAAgB1gC,EAAStF,MAAM,KAC/BimC,EAAaD,EAAcn8C,MAC3Bq8C,EAAc,CAAChmC,GAAO0Z,OAAOosB,GAAevH,KAAK,KACjD0H,EAAQJ,EAAOzgC,GAAUtF,MAAM,KAC/B2C,EAAawjC,EAAMt8C,MACnB6Y,EAAcyjC,EAAM1H,KAAK,KAC/Bp+B,GAASgyB,MAAM6T,EAAaD,EAAYvjC,EAAaC,KAfrDmjC,CAAc5lC,EAAO1W,EAAK+jC,eAE1B/jC,EAAKqW,aACLQ,GAASmC,SAAStC,EAAO1W,EAAKqW,aAtC9B+lC,CAAiBp8C,EAAM0W,EAAOulC,GAhBnB,KAiBJtH,UACH99B,GAAS89B,SAAS30C,EAAK6S,GAAI7S,EAAKoW,WAE7BM,KAv+LE,CAAA,IAAA,MA0+Lb,MAAA,SAAI7D,GACO,OAAA,KAAKhT,MAAMgT,KA3+LT,CAAA,IAAA,aA8+Lb,MAAA,SAAW7S,GACDH,IAAAA,EAAQ,KAAKA,MACbgT,EAAK7S,EAAK6S,GACV6D,EAAQ,KAAKA,MACf7D,KAAMhT,UACCA,EAAMgT,GAEb6D,GAAS7D,KAAMgE,GAASH,YACjBG,GAASH,GAAO7D,GACnB,KAAK8hC,iBACEv+B,GAAUvD,QAx/LhB,EAAA,GA6hMX+pC,IA0GFC,GAAW,IAvoME,WA8hMC,SAAA,IAAA,EAAA,KAAA,GACLC,KAAAA,YAAc,IAAIf,GAAc/e,GAAmB,YAAY,GAC/DzlB,KAAAA,SAAW,IAAIwkC,GAAcnY,GAAS,YACtCjrB,KAAAA,QAAU,IAAIojC,GAAc/rC,OAAQ,WACpC8I,KAAAA,OAAS,IAAIijC,GAAcjS,GAAO,UAClCiT,KAAAA,iBAAmB,CAAC,KAAKD,YAAa,KAAKhkC,OAAQ,KAAKvB,UAniMpD,OAAA,EAAA,EAAA,CAAA,CAAA,IAAA,MAsiMb,MAAA,WAAOza,IAAAA,IAAAA,EAAAA,UAAAA,OAAAA,EAAM,IAAA,MAAA,GAAA,EAAA,EAAA,EAAA,EAAA,IAANA,EAAM,GAAA,UAAA,GACJkgD,KAAAA,MAAM,WAAYlgD,KAviMd,CAAA,IAAA,SA0iMb,MAAA,WAAUA,IAAAA,IAAAA,EAAAA,UAAAA,OAAAA,EAAM,IAAA,MAAA,GAAA,EAAA,EAAA,EAAA,EAAA,IAANA,EAAM,GAAA,UAAA,GACPkgD,KAAAA,MAAM,aAAclgD,KA3iMhB,CAAA,IAAA,iBA8iMb,MAAA,WAAkBA,IAAAA,IAAAA,EAAAA,UAAAA,OAAAA,EAAM,IAAA,MAAA,GAAA,EAAA,EAAA,EAAA,EAAA,IAANA,EAAM,GAAA,UAAA,GACfkgD,KAAAA,MAAM,WAAYlgD,EAAM,KAAKggD,eA/iMzB,CAAA,IAAA,cAkjMb,MAAA,WAAehgD,IAAAA,IAAAA,EAAAA,UAAAA,OAAAA,EAAM,IAAA,MAAA,GAAA,EAAA,EAAA,EAAA,EAAA,IAANA,EAAM,GAAA,UAAA,GACZkgD,KAAAA,MAAM,WAAYlgD,EAAM,KAAKya,YAnjMzB,CAAA,IAAA,aAsjMb,MAAA,WAAcza,IAAAA,IAAAA,EAAAA,UAAAA,OAAAA,EAAM,IAAA,MAAA,GAAA,EAAA,EAAA,EAAA,EAAA,IAANA,EAAM,GAAA,UAAA,GACXkgD,KAAAA,MAAM,WAAYlgD,EAAM,KAAK6b,WAvjMzB,CAAA,IAAA,YA0jMb,MAAA,WAAa7b,IAAAA,IAAAA,EAAAA,UAAAA,OAAAA,EAAM,IAAA,MAAA,GAAA,EAAA,EAAA,EAAA,EAAA,IAANA,EAAM,GAAA,UAAA,GACVkgD,KAAAA,MAAM,WAAYlgD,EAAM,KAAKgc,UA3jMzB,CAAA,IAAA,gBA8jMb,MAAA,SAAcjG,GACH,OAAA,KAAKoqC,KAAKpqC,EAAI,KAAKiqC,YAAa,gBA/jM9B,CAAA,IAAA,aAkkMb,MAAA,SAAWjqC,GACA,OAAA,KAAKoqC,KAAKpqC,EAAI,KAAK0E,SAAU,aAnkM3B,CAAA,IAAA,YAskMb,MAAA,SAAU1E,GACC,OAAA,KAAKoqC,KAAKpqC,EAAI,KAAK8F,QAAS,YAvkM1B,CAAA,IAAA,WA0kMb,MAAA,SAAS9F,GACE,OAAA,KAAKoqC,KAAKpqC,EAAI,KAAKiG,OAAQ,WA3kMzB,CAAA,IAAA,oBA8kMb,MAAA,WAAqBhc,IAAAA,IAAAA,EAAAA,UAAAA,OAAAA,EAAM,IAAA,MAAA,GAAA,EAAA,EAAA,EAAA,EAAA,IAANA,EAAM,GAAA,UAAA,GAClBkgD,KAAAA,MAAM,aAAclgD,EAAM,KAAKggD,eA/kM3B,CAAA,IAAA,iBAklMb,MAAA,WAAkBhgD,IAAAA,IAAAA,EAAAA,UAAAA,OAAAA,EAAM,IAAA,MAAA,GAAA,EAAA,EAAA,EAAA,EAAA,IAANA,EAAM,GAAA,UAAA,GACfkgD,KAAAA,MAAM,aAAclgD,EAAM,KAAKya,YAnlM3B,CAAA,IAAA,gBAslMb,MAAA,WAAiBza,IAAAA,IAAAA,EAAAA,UAAAA,OAAAA,EAAM,IAAA,MAAA,GAAA,EAAA,EAAA,EAAA,EAAA,IAANA,EAAM,GAAA,UAAA,GACdkgD,KAAAA,MAAM,aAAclgD,EAAM,KAAK6b,WAvlM3B,CAAA,IAAA,eA0lMb,MAAA,WAAgB7b,IAAAA,IAAAA,EAAAA,UAAAA,OAAAA,EAAM,IAAA,MAAA,GAAA,EAAA,EAAA,EAAA,EAAA,IAANA,EAAM,GAAA,UAAA,GACbkgD,KAAAA,MAAM,aAAclgD,EAAM,KAAKgc,UA3lM3B,CAAA,IAAA,QA8lMb,MAAA,SAAM0L,EAAQ1nB,EAAMogD,GACV59C,IAAAA,EAAK,KACPxC,EAAAA,GAAMoC,QAAQ,SAAAi+C,GACRC,IAAAA,EAAMF,GAAiB59C,EAAG+9C,oBAAoBF,GAChDD,GAAiBE,EAAIE,UAAUH,IAASC,IAAQ99C,EAAGqZ,SAAWwkC,EAAItqC,GAClEvT,EAAGi+C,MAAM/4B,EAAQ44B,EAAKD,GAEtBtpC,GAAKspC,EAAK,SAAAn9C,GACAw9C,IAAAA,EAAUN,GAAiB59C,EAAG+9C,oBAAoBr9C,GACxDV,EAAGi+C,MAAM/4B,EAAQg5B,EAASx9C,SAvmM7B,CAAA,IAAA,QA6mMb,MAAA,SAAMwkB,EAAQq4B,EAAUY,GACdC,IAAAA,EAAc1nC,GAAYwO,GAChCjoB,GAASkhD,EAAU,SAAWC,GAAc,GAAID,GAChDZ,EAASr4B,GAAQi5B,GACjBlhD,GAASkhD,EAAU,QAAUC,GAAc,GAAID,KAjnMtC,CAAA,IAAA,sBAonMb,MAAA,SAAoB5+C,GACX,IAAA,IAAIkB,EAAI,EAAGA,EAAI,KAAKg9C,iBAAiBj9C,OAAQC,IAAK,CAC7Cq9C,IAAAA,EAAM,KAAKL,iBAAiBh9C,GAC9Bq9C,GAAAA,EAAIE,UAAUz+C,GACPu+C,OAAAA,EAGR,OAAA,KAAKzkC,UA3nMH,CAAA,IAAA,OA8nMb,MAAA,SAAK9F,EAAIqqC,EAAer+C,GACdmB,IAAAA,EAAOk9C,EAAc18C,IAAIqS,GAC3B7S,QAASvB,IAATuB,EACM,MAAA,IAAIg1C,MAAM,IAAMniC,EAAK,yBAA2BhU,EAAO,KAE1DmB,OAAAA,MAnoME,EAAA,IAyoMX29C,GAzoMW,WA0oMC,SAAA,IAAA,EAAA,KAAA,GACLC,KAAAA,MAAQ,GA3oMJ,OAAA,EAAA,EAAA,CAAA,CAAA,IAAA,SA8oMb,MAAA,SAAOl/C,EAAOm/C,EAAM/gD,GACVwC,IAAAA,EAAK,KACE,eAATu+C,IACAv+C,EAAGs+C,MAAQt+C,EAAGw+C,mBAAmBp/C,GAAO,GACxCY,EAAGgB,QAAQhB,EAAGs+C,MAAOl/C,EAAO,YAE1B2X,IAAAA,EAAc/W,EAAGwX,aAAapY,GAC9Buc,EAAS3b,EAAGgB,QAAQ+V,EAAa3X,EAAOm/C,EAAM/gD,GAK7Cme,MAJM,YAAT4iC,IACAv+C,EAAGgB,QAAQ+V,EAAa3X,EAAO,QAC/BY,EAAGgB,QAAQhB,EAAGs+C,MAAOl/C,EAAO,cAEzBuc,IA1pME,CAAA,IAAA,UA6pMb,MAAA,SAAQ5E,EAAa3X,EAAOm/C,EAAM/gD,GAC9BA,EAAOA,GAAQ,GACUuZ,IAFW,EAEXA,EAAAA,EAAAA,GAFW,IAEE,IAAA,EAAA,MAAA,EAAA,EAAA,KAAA,MAAA,CAA3B0nC,IAAAA,EAA2B,EAAA,MAC5BC,EAASD,EAAWC,OAGtBzhD,IAAqC,IAArCA,GAFWyhD,EAAOH,GACP,CAACn/C,EAAO5B,EAAMihD,EAAW9oC,SACX+oC,IAAqBlhD,EAAKmhD,WAC5C,OAAA,GAPqB,MAAA,GAAA,EAAA,EAAA,GAAA,QAAA,EAAA,IAU7B,OAAA,IAvqME,CAAA,IAAA,aA0qMb,MAAA,WACSnrC,GAAc,KAAKi4B,UACfmT,KAAAA,UAAY,KAAKnT,OACjBA,KAAAA,YAAStsC,KA7qMT,CAAA,IAAA,eAirMb,MAAA,SAAaC,GACL,GAAA,KAAKqsC,OACE,OAAA,KAAKA,OAEV10B,IAAAA,EAAc,KAAK00B,OAAS,KAAK+S,mBAAmBp/C,GAEnD2X,OADF8nC,KAAAA,oBAAoBz/C,GAClB2X,IAvrME,CAAA,IAAA,qBA0rMb,MAAA,SAAmB3X,EAAOi8B,GAChBf,IAAAA,EAASl7B,GAASA,EAAMk7B,OACxB3kB,EAAU1B,GAAeqmB,EAAO3kB,SAAW2kB,EAAO3kB,QAAQ0D,QAAS,IACnEA,EAaLylC,SAAWxkB,GAGX,IAFCjhB,IAAAA,EAAU,GACV5I,EAAOC,OAAOD,KAAK8sC,GAASlkC,QAAQ9Y,OACjCE,EAAI,EAAGA,EAAIgQ,EAAKjQ,OAAQC,IAC7B4Y,EAAQ5X,KAAK87C,GAASwB,UAAUtuC,EAAKhQ,KAGpC,IADC2Z,IAAAA,EAAQkgB,EAAOjhB,SAAW,GACvB5Y,EAAI,EAAGA,EAAI2Z,EAAM5Z,OAAQC,IAAK,CAC7Bi+C,IAAAA,EAAStkC,EAAM3Z,IACY,IAA7B4Y,EAAQ5D,QAAQipC,IAChBrlC,EAAQ5X,KAAKi9C,GAGdrlC,OAAAA,EA1BaylC,CAAWxkB,GACpB3kB,OAAY,IAAZA,GAAsB0lB,EAsC5B2jB,SAAkB5/C,EAAOia,EAAS1D,EAAS0lB,GAG3C,IAFC1f,IAAAA,EAAS,GACT7D,EAAU1Y,EAAMygB,aACbpf,EAAI,EAAGA,EAAI4Y,EAAQ7Y,OAAQC,IAAK,CAC/Bi+C,IAAAA,EAASrlC,EAAQ5Y,GACjB8S,EAAKmrC,EAAOnrC,GACZqP,EAAOq8B,GAAQtpC,EAAQpC,GAAK8nB,GACrB,OAATzY,GAGJjH,EAAOla,KAAK,CACRi9C,OAAAA,EACA/oC,QAASupC,GAAW9/C,EAAMk7B,OAAQokB,EAAQ97B,EAAM9K,KAGjD6D,OAAAA,EArDqCqjC,CAAkB5/C,EAAOia,EAAS1D,EAAS0lB,GAAhD,KA9rM1B,CAAA,IAAA,sBAisMb,MAAA,SAAoBj8B,GACV+/C,IAAAA,EAAsB,KAAKP,WAAa,GACxC7nC,EAAc,KAAK00B,OACnB3D,EAAO,SAACtlC,EAAGC,GAAMD,OAAAA,EAAEorB,OAAO,SAAAnoB,GAAK,OAAChD,EAAE28C,KAAK,SAAAnjC,GAAKxW,OAAAA,EAAEi5C,OAAOnrC,KAAO0I,EAAEyiC,OAAOnrC,QACtEvS,KAAAA,QAAQ8mC,EAAKqX,EAAqBpoC,GAAc3X,EAAO,QACvD4B,KAAAA,QAAQ8mC,EAAK/wB,EAAaooC,GAAsB//C,EAAO,aAtsMnD,EAAA,GA0tMR6/C,SAAAA,GAAQtpC,EAAS0lB,GAClB,OAACA,IAAmB,IAAZ1lB,GAGI,IAAZA,EACO,GAEJA,EALI,KA0BNupC,SAAAA,GAAW5kB,EAAQokB,EAAQ97B,EAAM9K,GAChCrH,IAAAA,EAAO6pB,EAAO+kB,gBAAgBX,GAC9Bre,EAAS/F,EAAOgG,gBAAgB1d,EAAMnS,GACrC6pB,OAAAA,EAAOiG,eAAeF,EAAQvoB,EAAS,CAAC,IAAK,CAACk+B,YAAY,EAAOC,WAAW,EAAOF,SAAS,IAG9FuJ,SAAAA,GAAa//C,EAAMoW,GAClB4pC,IAAAA,EAAkBhoC,GAASK,SAASrY,IAAS,GAE5CigD,QADiB7pC,EAAQiC,UAAY,IAAIrY,IAAS,IACnCsZ,WAAalD,EAAQkD,WAAa0mC,EAAgB1mC,WAAa,IA0BhF4mC,SAAAA,GAAclsC,EAAImsC,GACnBnsC,MAAO,MAAPA,GAAqB,MAAPA,EACPA,EAEJmsC,EAAa71B,OAZH,SADKU,EAauBm1B,EAAan1B,WAZnB,WAAbA,EACf,IAEM,SAAbA,GAAoC,UAAbA,EAChB,SADPA,IASmEhX,EAAG9B,OAAO,GAAGV,cAb/E4uC,IAAiBp1B,EAiDjBq1B,SAAAA,GAAYtlB,GACX3kB,IAAAA,EAAU2kB,EAAO3kB,UAAY2kB,EAAO3kB,QAAU,IACpDA,EAAQ0D,QAAUpF,GAAe0B,EAAQ0D,QAAS,IAClD1D,EAAQ6D,OApCHqmC,SAAiBvlB,EAAQ3kB,GACxBmqC,IAAAA,EAAgBhpC,GAAUwjB,EAAO/6B,OAAS,CAACia,OAAQ,IACnDumC,EAAepqC,EAAQ6D,QAAU,GACjCwmC,EAAiBV,GAAahlB,EAAO/6B,KAAMoW,GAC3CsqC,EAAWvvC,OAAO2E,OAAO,MACzBmE,EAAS9I,OAAO2E,OAAO,MAyBtBmE,OAxBP9I,OAAOD,KAAKsvC,GAAcngD,QAAQ,SAAA2T,GACxB2sC,IAAAA,EAAYH,EAAaxsC,GACzBsW,EAAO41B,GAAclsC,EAAI2sC,GACzBC,EA7BLC,SAA0Bv2B,EAAMhR,GAC9BgR,OAAAA,IAAShR,EAAY,UAAY,UA4BlBunC,CAA0Bv2B,EAAMm2B,GAC5CK,EAAsBP,EAActmC,QAAU,GACpDymC,EAASp2B,GAAQo2B,EAASp2B,IAAStW,EACnCiG,EAAOjG,GAAM0C,GAAQvF,OAAO2E,OAAO,MAAO,CAAC,CAACwU,KAAAA,GAAOq2B,EAAWG,EAAoBx2B,GAAOw2B,EAAoBF,OAEjH7lB,EAAOjc,KAAKzG,SAAShY,QAAQ,SAAAssB,GACnB3sB,IAAAA,EAAO2sB,EAAQ3sB,MAAQ+6B,EAAO/6B,KAC9BsZ,EAAYqT,EAAQrT,WAAaymC,GAAa//C,EAAMoW,GAEpD0qC,GADkBvpC,GAAUvX,IAAS,IACCia,QAAU,GACtD9I,OAAOD,KAAK4vC,GAAqBzgD,QAAQ,SAAA0gD,GAC/Bz2B,IAAAA,EAlDT02B,SAA0BhtC,EAAIsF,GAC/BgR,IAAAA,EAAOtW,EAMJsW,MALI,YAAPtW,EACAsW,EAAOhR,EACO,YAAPtF,IACPsW,EAAqB,MAAdhR,EAAoB,IAAM,KAE9BgR,EA2Cc02B,CAA0BD,EAAWznC,GAC5CtF,EAAK2Y,EAAQrC,EAAO,WAAao2B,EAASp2B,IAASA,EACzDrQ,EAAOjG,GAAMiG,EAAOjG,IAAO7C,OAAO2E,OAAO,MACzCY,GAAQuD,EAAOjG,GAAK,CAAC,CAACsW,KAAAA,GAAOk2B,EAAaxsC,GAAK8sC,EAAoBC,SAG3E5vC,OAAOD,KAAK+I,GAAQ5Z,QAAQ,SAAA4V,GAClB+D,IAAAA,EAAQC,EAAOhE,GACrBS,GAAQsD,EAAO,CAAChC,GAASiC,OAAOD,EAAMha,MAAOgY,GAASgC,UAEnDC,EAMUqmC,CAAiBvlB,EAAQ3kB,GAYxC6qC,IAAAA,GAAW,IAAIxhD,IACfyhD,GAAa,IAAIh7B,IAEdi7B,SAAAA,GAAW1d,EAAU2d,GACtBlwC,IAAAA,EAAO+vC,GAASt/C,IAAI8hC,GAMjBvyB,OALFA,IACDA,EAAOkwC,IACPH,GAASn/C,IAAI2hC,EAAUvyB,GACvBgwC,GAAW/6B,IAAIjV,IAEZA,EAGLmwC,IAAAA,GAAa,SAACv/C,EAAK2Q,EAAKwD,GACpBoN,IAAAA,EAAOpM,GAAiBxE,EAAKwD,QACtBrW,IAATyjB,GACAvhB,EAAIqkB,IAAI9C,IAIVi+B,GAp2MW,WAq2MDvmB,SAAAA,EAAAA,GAAQ,EAAA,KAAA,GACXwmB,KAAAA,QA/BJC,SAAWzmB,GAEVjc,IAAAA,GADNic,EAASA,GAAU,IACCjc,KAAOic,EAAOjc,MAAQ,CAACzG,SAAU,GAAIkpB,OAAQ,IAI1DxG,OAHPjc,EAAKzG,SAAWyG,EAAKzG,UAAY,GACjCyG,EAAKyiB,OAASziB,EAAKyiB,QAAU,GAC7B8e,GAAYtlB,GACLA,EAyBYymB,CAAWzmB,GACrB0mB,KAAAA,YAAc,IAAIhiD,IAClBiiD,KAAAA,eAAiB,IAAIjiD,IAx2MjB,OAAA,EAAA,EAAA,CAAA,CAAA,IAAA,OA22Mb,IAAA,WACW,OAAA,KAAK8hD,QAAQvhD,MAGxB,IAAA,SAASA,GACAuhD,KAAAA,QAAQvhD,KAAOA,IAh3MX,CAAA,IAAA,OAm3Mb,IAAA,WACW,OAAA,KAAKuhD,QAAQziC,MAGxB,IAAA,SAASA,GACAyiC,KAAAA,QAAQziC,KAAOA,IAx3MX,CAAA,IAAA,UA23Mb,IAAA,WACW,OAAA,KAAKyiC,QAAQnrC,SAGxB,IAAA,SAAYA,GACHmrC,KAAAA,QAAQnrC,QAAUA,IAh4Md,CAAA,IAAA,UAm4Mb,IAAA,WACW,OAAA,KAAKmrC,QAAQznC,UAp4MX,CAAA,IAAA,SAu4Mb,MAAA,WACUihB,IAAAA,EAAS,KAAKwmB,QACfI,KAAAA,aACLtB,GAAYtlB,KA14MH,CAAA,IAAA,aA64Mb,MAAA,WACS0mB,KAAAA,YAAYG,QACZF,KAAAA,eAAeE,UA/4MX,CAAA,IAAA,mBAk5Mb,MAAA,SAAiBC,GACNV,OAAAA,GAAWU,EACd,WAAM,MAAA,CAAC,CACSA,YAAAA,OAAAA,GACZ,SAt5MC,CAAA,IAAA,4BA05Mb,MAAA,SAA0BA,EAAa/d,GAC5Bqd,OAAAA,GAAcU,GAAAA,OAAAA,EAA0B/d,gBAAAA,OAAAA,GAC3C,WAAM,MAAA,CACF,CACgB+d,YAAAA,OAAAA,EAA2B/d,iBAAAA,OAAAA,GACxBA,eAAAA,OAAAA,IAEnB,CACgB+d,YAAAA,OAAAA,GACZ,SAn6MH,CAAA,IAAA,0BAw6Mb,MAAA,SAAwBA,EAAare,GAC1B2d,OAAAA,GAAcU,GAAAA,OAAAA,EAAere,KAAAA,OAAAA,GAChC,WAAM,MAAA,CAAC,CACSqe,YAAAA,OAAAA,EAAwBre,cAAAA,OAAAA,GACxBqe,YAAAA,OAAAA,GACAre,YAAAA,OAAAA,GACZ,SA96MC,CAAA,IAAA,kBAk7Mb,MAAA,SAAgB2b,GACNnrC,IAAAA,EAAKmrC,EAAOnrC,GACZhU,EAAO,KAAKA,KACXmhD,OAAAA,GAAcnhD,GAAAA,OAAAA,EAAegU,YAAAA,OAAAA,GAChC,WAAM,MAAA,CACSA,CAAAA,WAAAA,OAAAA,IACRmrC,OAAAA,EAAAA,EAAO2C,wBAA0B,UAx7MnC,CAAA,IAAA,gBA47Mb,MAAA,SAAcC,EAAWC,GACfP,IAAAA,EAAc,KAAKA,YACrBliC,EAAQkiC,EAAY9/C,IAAIogD,GAKrBxiC,OAJFA,IAASyiC,IACVziC,EAAQ,IAAI9f,IACZgiD,EAAY3/C,IAAIigD,EAAWxiC,IAExBA,IAn8ME,CAAA,IAAA,kBAs8Mb,MAAA,SAAgBwiC,EAAWE,EAAUD,GAC1B5rC,IAAAA,EAAiB,KAAjBA,QAASpW,EAAQ,KAARA,KACVuf,EAAQ,KAAK2iC,cAAcH,EAAWC,GACtC/jB,EAAS1e,EAAM5d,IAAIsgD,GACrBhkB,GAAAA,EACOA,OAAAA,EAEL6C,IAAAA,EAAS,IAAI5a,IACnB+7B,EAAS5hD,QAAQ,SAAA6Q,GACT6wC,IACAjhB,EAAO3a,IAAI47B,GACX7wC,EAAK7Q,QAAQ,SAAA4V,GAAOorC,OAAAA,GAAWvgB,EAAQihB,EAAW9rC,MAEtD/E,EAAK7Q,QAAQ,SAAA4V,GAAOorC,OAAAA,GAAWvgB,EAAQ1qB,EAASH,KAChD/E,EAAK7Q,QAAQ,SAAA4V,GAAOorC,OAAAA,GAAWvgB,EAAQvpB,GAAUvX,IAAS,GAAIiW,KAC9D/E,EAAK7Q,QAAQ,SAAA4V,GAAOorC,OAAAA,GAAWvgB,EAAQ9oB,GAAU/B,KACjD/E,EAAK7Q,QAAQ,SAAA4V,GAAOorC,OAAAA,GAAWvgB,EAAQtpB,GAAavB,OAElD+G,IAAAA,EAAY8jB,EAAAA,GAIX9jB,OAHHkkC,GAAW7lB,IAAI4mB,IACf1iC,EAAMzd,IAAImgD,EAAUjlC,GAEjBA,IA59ME,CAAA,IAAA,oBA+9Mb,MAAA,WACW5G,IAAAA,EAAiB,KAAjBA,QAASpW,EAAQ,KAARA,KACT,MAAA,CACHoW,EACAmB,GAAUvX,IAAS,GACnBgY,GAASK,SAASrY,IAAS,GAC3B,CAACA,KAAAA,GACDgY,GACAR,MAv+MK,CAAA,IAAA,sBA2+Mb,MAAA,SAAoBspB,EAAQv5B,EAAOgR,GAASqrB,IAAAA,EAAW,UAAA,OAAA,QAAA,IAAA,UAAA,GAAA,UAAA,GAAA,CAAC,IAC9CxnB,EAAS,CAACof,SAAS,GACO2mB,EAAAA,GAAY,KAAKT,eAAgB5gB,EAAQ8C,GAAlE2S,EAAAA,EAAAA,SAAU6L,EAAAA,EAAAA,YACbhsC,EAAUmgC,GAwCb8L,SAAYptB,EAAO1tB,GACY0Q,IADL,EACKA,EAAAA,GAAagd,GAA1CghB,EAAAA,EAAAA,aAAcK,EAAAA,EAAAA,YACF/uC,EAAAA,EAAAA,GAFY,IAEL,IAAA,EAAA,MAAA,EAAA,EAAA,KAAA,MAAA,CAAf+lB,IAAAA,EAAe,EAAA,MACjB2oB,GAAAA,EAAa3oB,IAAShW,GAAW2d,EAAM3H,KACpCgpB,EAAYhpB,IAASjoB,GAAQ4vB,EAAM3H,IAChC,OAAA,GALgB,MAAA,GAAA,EAAA,EAAA,GAAA,QAAA,EAAA,IAQxB,OAAA,GA/CC+0B,CAAY9L,EAAUhvC,KACtB6U,EAAOof,SAAU,EAGjBplB,EAAUm/B,GAAegB,EAFzBh+B,EAAUjB,GAAWiB,GAAWA,IAAYA,EACxB,KAAKyoB,eAAeF,EAAQvoB,EAAS6pC,KAG1C76C,IAVsC,EAUtCA,EAAAA,EAAAA,GAVsC,IAU/B,IAAA,EAAA,MAAA,EAAA,EAAA,KAAA,MAAA,CAAf+lB,IAAAA,EAAe,EAAA,MACtBlR,EAAOkR,GAAQlX,EAAQkX,IAX8B,MAAA,GAAA,EAAA,EAAA,GAAA,QAAA,EAAA,IAalDlR,OAAAA,IAx/ME,CAAA,IAAA,iBA2/Mb,MAAA,SAAe0kB,EAAQvoB,GAASqrB,IAAAA,EAAW,UAAA,OAAA,QAAA,IAAA,UAAA,GAAA,UAAA,GAAA,CAAC,IAAK6R,EAAoB,UAAA,OAAA,EAAA,UAAA,QAAA,EAC1Dc,EAAY4L,GAAY,KAAKT,eAAgB5gB,EAAQ8C,GAArD2S,SACAniC,OAAAA,GAASmE,GACVg9B,GAAegB,EAAUh+B,OAAS3Y,EAAW61C,GAC7Cc,MA//MG,EAAA,GAmgNR4L,SAAAA,GAAYG,EAAexhB,EAAQ8C,GACpCrkB,IAAAA,EAAQ+iC,EAAc3gD,IAAIm/B,GACzBvhB,IACDA,EAAQ,IAAI9f,IACZ6iD,EAAcxgD,IAAIg/B,EAAQvhB,IAExBkkB,IAAAA,EAAWG,EAASwS,OACtBnY,EAAS1e,EAAM5d,IAAI8hC,GAClBxF,IAEDA,EAAS,CACLsY,SAFarC,GAAgBpT,EAAQ8C,GAGrCwe,YAAaxe,EAASvV,OAAO,SAAApb,GAAK,OAACA,EAAEzB,cAAc6jC,SAAS,YAEhE91B,EAAMzd,IAAI2hC,EAAUxF,IAEjBA,OAAAA,EAcPskB,IAEEC,GAAkB,CAAC,MAAO,SAAU,OAAQ,QAAS,aAElDC,SAAAA,GAAqBz3B,EAAUV,GAC7BU,MAAa,QAAbA,GAAmC,WAAbA,IAAiE,IAAvCw3B,GAAgBtsC,QAAQ8U,IAA6B,MAATV,EAG9Fo4B,SAAAA,GAAcC,EAAIC,GAChB,OAAA,SAAU3/C,EAAGC,GACTD,OAAAA,EAAE0/C,KAAQz/C,EAAEy/C,GACb1/C,EAAE2/C,GAAM1/C,EAAE0/C,GACV3/C,EAAE0/C,GAAMz/C,EAAEy/C,IAIfE,SAAAA,GAAqBtqC,GACpB1Y,IAAAA,EAAQ0Y,EAAQ1Y,MAChBw6B,EAAmBx6B,EAAMuW,QAAQ8B,UACvCrY,EAAMuuC,cAAc,eACpB1wC,GAAS28B,GAAoBA,EAAiByoB,WAAY,CAACvqC,GAAU1Y,GAGhEkjD,SAAAA,GAAoBxqC,GACnB1Y,IAAAA,EAAQ0Y,EAAQ1Y,MAChBw6B,EAAmBx6B,EAAMuW,QAAQ8B,UACvCxa,GAAS28B,GAAoBA,EAAiB2oB,WAAY,CAACzqC,GAAU1Y,GAGhEojD,SAAAA,KACE,MAAkB,oBAAXxlD,QAA8C,oBAAbs2B,SAG1CmvB,SAAAA,GAAU/hD,GASRA,OARH8hD,MAAoC,iBAAT9hD,EAC3BA,EAAO4yB,SAASovB,eAAehiD,GACxBA,GAAQA,EAAKF,SACpBE,EAAOA,EAAK,IAEZA,GAAQA,EAAKkf,SACblf,EAAOA,EAAKkf,QAETlf,EAGLiiD,IAAAA,GAAY,GACZC,GAAW,SAACptC,GACRoK,IAAAA,EAAS6iC,GAAUjtC,GAClB9E,OAAAA,OAAO2G,OAAOsrC,IAAW/0B,OAAO,SAAClrB,GAAMA,OAAAA,EAAEkd,SAAWA,IAAQ7e,OAGjEjE,GAplNW,WAqlND4D,SAAAA,EAAAA,EAAM45B,GAAQ,IAAA,EAAA,KAAA,EAAA,KAAA,GAChBt6B,IAAAA,EAAK,KACNs6B,KAAAA,OAASA,EAAS,IAAIumB,GAAOvmB,GAC5BuoB,IAAAA,EAAgBJ,GAAU/hD,GAC1BoiD,EAAgBF,GAASC,GAC3BC,GAAAA,EACM,MAAA,IAAIpN,MACN,4CAA+CoN,EAAcvvC,GAAK,wDAIpEoC,IAAAA,EAAU2kB,EAAOiG,eAAejG,EAAOyoB,oBAAqB/iD,EAAG6f,cAChE9H,KAAAA,SAAW/X,EAAGgjD,oBAAoBH,EAAevoB,GAChDxiB,IAAAA,EAAU9X,EAAG+X,SAASkrC,eAAeJ,EAAeltC,EAAQuS,aAC5DtI,EAAS9H,GAAWA,EAAQ8H,OAC5BI,EAASJ,GAAUA,EAAOI,OAC1BrB,EAAQiB,GAAUA,EAAOjB,MAC1BpL,KAAAA,GAAKD,KACLoF,KAAAA,IAAMZ,EACN8H,KAAAA,OAASA,EACTjB,KAAAA,MAAQA,EACRqB,KAAAA,OAASA,EACTkjC,KAAAA,SAAWvtC,EACXwtC,KAAAA,aAAe,KAAKj7B,YACpB4H,KAAAA,QAAU,GACVszB,KAAAA,UAAY,GACZzmB,KAAAA,aAAUx9B,EACVgwB,KAAAA,MAAQ,GACR1P,KAAAA,6BAA0BtgB,EAC1B2rB,KAAAA,eAAY3rB,EACZyB,KAAAA,QAAU,GACVyiD,KAAAA,gBAAalkD,EACbmkD,KAAAA,WAAa,GACbC,KAAAA,gBAAkB,GAClB/pC,KAAAA,OAAS,GACTD,KAAAA,WAAQpa,EACRqkD,KAAAA,SAAW,IAAInF,GACf/oB,KAAAA,SAAW,GACXmuB,KAAAA,eAAiB,GACjBC,KAAAA,UAAW,EACXjgB,KAAAA,yBAAsBtkC,EACtBk/B,KAAAA,cAAWl/B,EACXwkD,KAAAA,UAAY3lD,EAAS,WAAM,OAAA,EAAKuxB,OAAO,WAAW5Z,EAAQiuC,aAAe,GAC9EjB,GAAU3iD,EAAGuT,IAAMvT,EACd8X,GAAY8H,GAIjB/gB,EAASglD,OAAO7jD,EAAI,WAAYoiD,IAChCvjD,EAASglD,OAAO7jD,EAAI,WAAYsiD,IAChCtiD,EAAG8jD,cACC9jD,EAAG0jD,UACH1jD,EAAGuvB,UAPH6sB,QAAQ2H,MAAM,qEAloNT,OAAA,EAAA,EAAA,CAAA,CAAA,IAAA,cA6oNb,IAAA,WACuF,IAAA,EAAA,KAA5EpuC,QAAUuS,EAAAA,EAAAA,YAAajP,EAAAA,EAAAA,oBAAsB0F,EAA+B,KAA/BA,MAAOqB,EAAwB,KAAxBA,OAAQmjC,EAAgB,KAAhBA,aAC/D,OAAC3vC,GAAc0U,GAGfjP,GAAuBkqC,EAChBA,EAEJnjC,EAASrB,EAAQqB,EAAS,KALtBkI,IAhpNF,CAAA,IAAA,OAwpNb,IAAA,WACW,OAAA,KAAKoS,OAAOjc,MAGvB,IAAA,SAASA,GACAic,KAAAA,OAAOjc,KAAOA,IA7pNV,CAAA,IAAA,UAgqNb,IAAA,WACW,OAAA,KAAK6kC,UAGhB,IAAA,SAAYvtC,GACH2kB,KAAAA,OAAO3kB,QAAUA,IArqNb,CAAA,IAAA,cAwqNb,MAAA,WACU3V,IAAAA,EAAK,KASJA,OARPA,EAAG2tC,cAAc,cACb3tC,EAAG2V,QAAQ2D,WACXtZ,EAAG+zB,SAEHlL,GAAY7oB,EAAIA,EAAG2V,QAAQkC,kBAE/B7X,EAAGgkD,aACHhkD,EAAG2tC,cAAc,aACV3tC,IAlrNE,CAAA,IAAA,sBAqrNb,MAAA,SAAoB4f,EAAQ0a,GACpBA,OAAAA,EAAOviB,SACA,IAAIuiB,EAAOviB,UACVyqC,MAAgD,oBAApByB,iBAAmCrkC,aAAkBqkC,gBAClF,IAAIlyB,GAER,IAAI4C,KA3rNF,CAAA,IAAA,QA8rNb,MAAA,WAEW,OADPhV,GAAY,KAAKC,OAAQ,KAAKlH,KACvB,OAhsNE,CAAA,IAAA,OAmsNb,MAAA,WAEW,OADP7Z,EAASk9C,KAAK,MACP,OArsNE,CAAA,IAAA,SAwsNb,MAAA,SAAOp9B,EAAOqB,GACLnhB,EAASyB,QAAQ,MAGb4jD,KAAAA,kBAAoB,CAACvlC,MAAAA,EAAOqB,OAAAA,GAF5BmkC,KAAAA,QAAQxlC,EAAOqB,KA1sNf,CAAA,IAAA,UAgtNb,MAAA,SAAQrB,EAAOqB,GACLhgB,IAAAA,EAAK,KACL2V,EAAU3V,EAAG2V,QACbiK,EAAS5f,EAAG4f,OACZsI,EAAcvS,EAAQsD,qBAAuBjZ,EAAGkoB,YAChDk8B,EAAUpkD,EAAG+X,SAASgQ,eAAenI,EAAQjB,EAAOqB,EAAQkI,GAC5Dm8B,EAAWrkD,EAAGyf,wBACd6kC,EAAW3uC,EAAQkC,kBAAoB7X,EAAG+X,SAASC,sBACrDhY,EAAG2e,QAAUylC,EAAQzlC,OAAS3e,EAAGggB,SAAWokC,EAAQpkC,QAAUqkC,IAAaC,IAG/EtkD,EAAG2e,MAAQylC,EAAQzlC,MACnB3e,EAAGggB,OAASokC,EAAQpkC,OACpBhgB,EAAGmjD,aAAenjD,EAAGkoB,YACrBW,GAAY7oB,EAAIskD,GAAU,GAC1BtkD,EAAG2tC,cAAc,SAAU,CAACt1B,KAAM+rC,IAClCnnD,GAAS0Y,EAAQ4uC,SAAU,CAACvkD,EAAIokD,GAAUpkD,GACtCA,EAAG0jD,UACC1jD,EAAG2jD,aACH3jD,EAAGwkD,YAnuNF,CAAA,IAAA,sBAwuNb,MAAA,WAGIjwC,GAFgB,KAAKoB,QACS6D,QAAU,GACpB,SAACirC,EAAajR,GAC9BiR,EAAYlxC,GAAKigC,MA5uNZ,CAAA,IAAA,sBAgvNb,MAAA,WACUxzC,IAAAA,EAAK,KACL2V,EAAU3V,EAAG2V,QACb+uC,EAAY/uC,EAAQ6D,OACpBA,EAASxZ,EAAGwZ,OACZmrC,EAAUj0C,OAAOD,KAAK+I,GAAQ9X,OAAO,SAACsQ,EAAKuB,GAEtCvB,OADPA,EAAIuB,IAAM,EACHvB,GACR,IACCzR,EAAQ,GACRmkD,IACAnkD,EAAQA,EAAMuwB,OACVpgB,OAAOD,KAAKi0C,GAAWziD,IAAI,SAACsR,GAClBmsC,IAAAA,EAAegF,EAAUnxC,GACzBsW,EAAO41B,GAAclsC,EAAImsC,GACzBkF,EAAoB,MAAT/6B,EACX4G,EAAwB,MAAT5G,EACd,MAAA,CACHlU,QAAS+pC,EACTmF,UAAWD,EAAW,YAAcn0B,EAAe,SAAW,OAC9Dq0B,MAAOF,EAAW,eAAiBn0B,EAAe,WAAa,cAK/Elc,GAAKhU,EAAO,SAACG,GACHg/C,IAAAA,EAAeh/C,EAAKiV,QACpBpC,EAAKmsC,EAAansC,GAClBsW,EAAO41B,GAAclsC,EAAImsC,GACzBqF,EAAY9wC,GAAeyrC,EAAangD,KAAMmB,EAAKokD,YAC3B3lD,IAA1BugD,EAAan1B,UAA0By3B,GAAqBtC,EAAan1B,SAAUV,KAAUm4B,GAAqBthD,EAAKmkD,aACvHnF,EAAan1B,SAAW7pB,EAAKmkD,WAEjCF,EAAQpxC,IAAM,EACVgG,IAAAA,EAAQ,KACRhG,KAAMiG,GAAUA,EAAOjG,GAAIhU,OAASwlD,EACpCxrC,EAAQC,EAAOjG,IAGfgG,EAAQ,IADWgkC,GAASyH,SAASD,GAC7B,CAAe,CACnBxxC,GAAAA,EACAhU,KAAMwlD,EACNrsC,IAAK1Y,EAAG0Y,IACRtZ,MAAOY,IAEXwZ,EAAOD,EAAMhG,IAAMgG,GAEvBA,EAAM0rC,KAAKvF,EAAc/pC,KAE7BpB,GAAKowC,EAAS,SAACO,EAAY3xC,GAClB2xC,UACM1rC,EAAOjG,KAGtBgB,GAAKiF,EAAQ,SAACD,GACVqW,GAAQM,UAAUlwB,EAAIuZ,EAAOA,EAAM5D,SACnCia,GAAQC,OAAO7vB,EAAIuZ,OAxyNd,CAAA,IAAA,sBA4yNb,MAAA,SAAoB0S,EAAMhX,GAChBwV,IAAAA,EAAW,KAAK24B,UAChB+B,EAAWl5B,EAAKhX,MAClBkwC,IAAalwC,IACbwV,EAAS06B,GAAY16B,EAASxV,GAC9BwV,EAASxV,GAASgX,EAClBA,EAAKhX,MAAQA,KAlzNR,CAAA,IAAA,kBAszNb,MAAA,WACUjV,IACAyqB,EADK,KACS24B,UACdtf,EAFK,KAEQzlB,KAAKzG,SAASpX,OAC3BqjC,EAAUpZ,EAASjqB,OACrBqjC,GAAAA,EAAUC,EAAS,CACd,IAAA,IAAIrjC,EAAIqjC,EAASrjC,EAAIojC,IAAWpjC,EAL9B,KAMA2kD,oBAAoB3kD,GAE3BgqB,EAASnL,OAAOwkB,EAASD,EAAUC,GAR5B,KAURyf,gBAAkB94B,EAAS9sB,MAAM,GAAGke,KAAKomC,GAAc,QAAS,YAj0N1D,CAAA,IAAA,8BAo0Nb,MAAA,WACUjiD,IAAAA,EAAK,KACOyqB,EAA8BzqB,EAAzCojD,UAA4BxrC,EAAa5X,EAApBqe,KAAOzG,SAC/B6S,EAASjqB,OAASoX,EAASpX,eACpBR,EAAG28B,QAEdlS,EAAS7qB,QAAQ,SAACqsB,EAAMhX,GACqC,IAArD2C,EAASgW,OAAO,SAAAnoB,GAAKA,OAAAA,IAAMwmB,EAAKo5B,WAAU7kD,QAC1CR,EAAGolD,oBAAoBnwC,OA50NtB,CAAA,IAAA,2BAi1Nb,MAAA,WACUjV,IAGFS,EAAGoU,EAHD7U,EAAK,KACLslD,EAAiB,GACjB1tC,EAAW5X,EAAGqe,KAAKzG,SAGpBnX,IADLT,EAAGulD,8BACE9kD,EAAI,EAAGoU,EAAO+C,EAASpX,OAAQC,EAAIoU,EAAMpU,IAAK,CACzCyrB,IAAAA,EAAUtU,EAASnX,GACrBwrB,EAAOjsB,EAAGmsB,eAAe1rB,GACvBlB,EAAO2sB,EAAQ3sB,MAAQS,EAAGs6B,OAAO/6B,KAWnC0sB,GAVAA,EAAK1sB,MAAQ0sB,EAAK1sB,OAASA,IAC3BS,EAAGolD,oBAAoB3kD,GACvBwrB,EAAOjsB,EAAGmsB,eAAe1rB,IAE7BwrB,EAAK1sB,KAAOA,EACZ0sB,EAAKpT,UAAYqT,EAAQrT,WAAaymC,GAAa//C,EAAMS,EAAG2V,SAC5DsW,EAAKu5B,MAAQt5B,EAAQs5B,OAAS,EAC9BxlD,EAAGylD,oBAAoBx5B,EAAMxrB,GAC7BwrB,EAAKiW,MAAQ,GAAKhW,EAAQgW,MAC1BjW,EAAKkO,QAAUn6B,EAAG0lD,iBAAiBjlD,GAC/BwrB,EAAKnC,WACLmC,EAAKnC,WAAW67B,YAAYllD,GAC5BwrB,EAAKnC,WAAWyU,iBACb,CACGqnB,IAAAA,EAAkBrI,GAASsI,cAActmD,GACDgY,EAAAA,GAASK,SAASrY,GAAzDwgC,EAAAA,EAAAA,mBAAoB+C,EAAAA,EAAAA,gBAC3BpyB,OAAOW,OAAOu0C,EAAgBloD,UAAW,CACrColC,gBAAiBya,GAASuI,WAAWhjB,GACrC/C,mBAAoBA,GAAsBwd,GAASuI,WAAW/lB,KAElE9T,EAAKnC,WAAa,IAAI87B,EAAgB5lD,EAAIS,GAC1C6kD,EAAe7jD,KAAKwqB,EAAKnC,aAI1Bw7B,OADPtlD,EAAG+lD,kBACIT,IAp3NE,CAAA,IAAA,iBAu3Nb,MAAA,WACUtlD,IAAAA,EAAK,KACXuU,GAAKvU,EAAGqe,KAAKzG,SAAU,SAACsU,EAASlX,GAC7BhV,EAAGmsB,eAAenX,GAAc8U,WAAWk8B,SAC5ChmD,KA33NM,CAAA,IAAA,QA83Nb,MAAA,WACSimD,KAAAA,iBACAtY,KAAAA,cAAc,WAh4NV,CAAA,IAAA,SAm4Nb,MAAA,SAAO50B,GACG/Y,IAAAA,EAAK,KACLs6B,EAASt6B,EAAGs6B,OAClBA,EAAO/K,SACPvvB,EAAGkjD,SAAW5oB,EAAOiG,eAAejG,EAAOyoB,oBAAqB/iD,EAAG6f,cACnEtL,GAAKvU,EAAGwZ,OAAQ,SAACD,GACbqW,GAAQI,UAAUhwB,EAAIuZ,KAEpB2sC,IAAAA,EAAgBlmD,EAAGyjC,qBAAuBzjC,EAAG2V,QAAQ8B,UAIvDzX,GAHJA,EAAGmmD,sBACHnmD,EAAGomD,sBACHpmD,EAAGwjD,SAAS6C,cACuD,IAA/DrmD,EAAG2tC,cAAc,eAAgB,CAAC50B,KAAAA,EAAM4lC,YAAY,IAApD3+C,CAGEslD,IAAAA,EAAiBtlD,EAAGsmD,2BAC1BtmD,EAAG2tC,cAAc,wBAEZ,IADDxd,IAAAA,EAAa,EACR1vB,EAAI,EAAGoU,EAAO7U,EAAGqe,KAAKzG,SAASpX,OAAQC,EAAIoU,EAAMpU,IAAK,CACtCT,IAAd8pB,EAAc9pB,EAAGmsB,eAAe1rB,GAAhCqpB,WACDk8B,GAASE,IAAyD,IAAxCZ,EAAe7vC,QAAQqU,GACvDA,EAAWy8B,sBAAsBP,GACjC71B,EAAarwB,KAAK+B,KAAKioB,EAAWwY,iBAAkBnS,GAExDnwB,EAAG+qB,YAAcoF,EACjBnwB,EAAGwmD,cAAcr2B,GACZ+1B,GACD3xC,GAAK+wC,EAAgB,SAACx7B,GAClBA,EAAWk8B,UAGnBhmD,EAAGymD,gBAAgB1tC,GACnB/Y,EAAG2tC,cAAc,cAAe,CAAC50B,KAAAA,IACjC/Y,EAAG8vB,QAAQjU,KAAKomC,GAAc,IAAK,SAC/BjiD,EAAGqjD,YACHrjD,EAAG0mD,cAAc1mD,EAAGqjD,YAAY,GAEpCrjD,EAAGwkD,YAx6NM,CAAA,IAAA,gBA26Nb,MAAA,SAAcr0B,GACJnwB,IAAAA,EAAK,KACPA,IAAyD,IAAzDA,EAAG2tC,cAAc,eAAgB,CAACgR,YAAY,IAA9C3+C,CAGJ4vB,GAAQL,OAAOvvB,EAAIA,EAAG2e,MAAO3e,EAAGggB,OAAQmQ,GAClC1O,IAAAA,EAAOzhB,EAAG8qB,UACV67B,EAASllC,EAAK9C,OAAS,GAAK8C,EAAKzB,QAAU,EACjDhgB,EAAG8vB,QAAU,GACbvb,GAAKvU,EAAGmvB,MAAO,SAACzH,GAAQ,IAAA,EAChBi/B,GAA2B,cAAjBj/B,EAAI6C,WAGd7C,EAAIwI,WACJxI,EAAIwI,aAERlwB,EAAAA,EAAG8vB,SAAQruB,KAAQimB,MAAAA,EAAAA,EAAAA,EAAIoI,cACxB9vB,GACHA,EAAG8vB,QAAQlwB,QAAQ,SAACc,EAAMuU,GACtBvU,EAAKkmD,KAAO3xC,IAEhBjV,EAAG2tC,cAAc,kBAh8NR,CAAA,IAAA,kBAm8Nb,MAAA,SAAgB50B,GACN/Y,IACA6W,EAA6B,mBAATkC,EACtB/Y,IAAuE,IAFhE,KAEJ2tC,cAAc,uBAAwB,CAAC50B,KAAAA,EAAM4lC,YAAY,IAA5D3+C,CAGC,IAAA,IAAIS,EAAI,EAAGoU,EALL,KAKewJ,KAAKzG,SAASpX,OAAQC,EAAIoU,IAAQpU,EALjD,KAMJomD,eAAepmD,EAAGoW,EAAakC,EAAK,CAAC/D,aAAcvU,IAAMsY,GANrD,KAQR40B,cAAc,sBAAuB,CAAC50B,KAAAA,OA58NhC,CAAA,IAAA,iBA+8Nb,MAAA,SAAe9D,EAAO8D,GACZ/Y,IACAisB,EADK,KACKE,eAAelX,GACzBzX,EAAO,CAACyuB,KAAAA,EAAMhX,MAAAA,EAAO8D,KAAAA,EAAM4lC,YAAY,IACS,IAH3C,KAGJhR,cAAc,sBAAuBnwC,KAG5CyuB,EAAKnC,WAAW7pB,QAAQ8Y,GACxBvb,EAAKmhD,YAAa,EAPP,KAQRhR,cAAc,qBAAsBnwC,MAx9N9B,CAAA,IAAA,SA29Nb,MAAA,WACUwC,IAAAA,EAAK,MACkD,IAAzDA,EAAG2tC,cAAc,eAAgB,CAACgR,YAAY,MAG9C9/C,EAAS+7B,IAAI56B,GACTA,EAAG0jD,WAAa7kD,EAASyB,QAAQN,IACjCnB,EAASL,MAAMwB,IAGnBA,EAAGW,OACHyhD,GAAqB,CAAChjD,MAAOY,QAt+NxB,CAAA,IAAA,OA0+Nb,MAAA,WACUA,IACFS,EADET,EAAK,KAEPA,GAAAA,EAAGkkD,kBAAmB,CACElkD,IAAAA,EAAAA,EAAGkkD,kBAApBvlC,EAAAA,EAAAA,MAAOqB,EAAAA,EAAAA,OACdhgB,EAAGmkD,QAAQxlC,EAAOqB,GAClBhgB,EAAGkkD,kBAAoB,KAGvBlkD,GADJA,EAAGmhD,UACCnhD,EAAG2e,OAAS,GAAK3e,EAAGggB,QAAU,KAGyB,IAAvDhgB,EAAG2tC,cAAc,aAAc,CAACgR,YAAY,IAA5C3+C,CAGE8mD,IAAAA,EAAS9mD,EAAG8vB,QACbrvB,IAAAA,EAAI,EAAGA,EAAIqmD,EAAOtmD,QAAUsmD,EAAOrmD,GAAGsvB,GAAK,IAAKtvB,EACjDqmD,EAAOrmD,GAAGE,KAAKX,EAAG8qB,WAGfrqB,IADPT,EAAG+mD,gBACItmD,EAAIqmD,EAAOtmD,SAAUC,EACxBqmD,EAAOrmD,GAAGE,KAAKX,EAAG8qB,WAEtB9qB,EAAG2tC,cAAc,gBAjgOR,CAAA,IAAA,yBAogOb,MAAA,SAAuBhS,GACb37B,IAGFS,EAAGoU,EAFD4V,EADK,KACS84B,gBACd5nC,EAAS,GAEVlb,IAAAA,EAAI,EAAGoU,EAAO4V,EAASjqB,OAAQC,EAAIoU,IAAQpU,EAAG,CACzCwrB,IAAAA,EAAOxB,EAAShqB,GACjBk7B,IAAiB1P,EAAKkO,SACvBxe,EAAOla,KAAKwqB,GAGbtQ,OAAAA,IA/gOE,CAAA,IAAA,+BAkhOb,MAAA,WACW,OAAA,KAAKigB,wBAAuB,KAnhO1B,CAAA,IAAA,gBAshOb,MAAA,WAEQ57B,IAA+D,IADxD,KACJ2tC,cAAc,qBAAsB,CAACgR,YAAY,IAApD3+C,CAIC,IADCyqB,IAAAA,EAJK,KAISC,+BACXjqB,EAAIgqB,EAASjqB,OAAS,EAAGC,GAAK,IAAKA,EALjC,KAMJumD,aAAav8B,EAAShqB,IANlB,KAQRktC,cAAc,wBA/hOR,CAAA,IAAA,eAkiOb,MAAA,SAAa1hB,GACHjsB,IAAAA,EAAK,KACL0Y,EAAM1Y,EAAG0Y,IACToJ,EAAOmK,EAAKmW,MACZ3gB,EAAOzhB,EAAG8qB,UACVttB,EAAO,CACTyuB,KAAAA,EACAhX,MAAOgX,EAAKhX,MACZ0pC,YAAY,IAEoC,IAAhD3+C,EAAG2tC,cAAc,oBAAqBnwC,KAG1CqkB,GAASnJ,EAAK,CACV/Z,MAAoB,IAAdmjB,EAAKnjB,KAAiB,EAAI8iB,EAAK9iB,KAAOmjB,EAAKnjB,KACjDC,OAAsB,IAAfkjB,EAAKljB,MAAkBoB,EAAG2e,MAAQ8C,EAAK7iB,MAAQkjB,EAAKljB,MAC3D+iB,KAAkB,IAAbG,EAAKH,IAAgB,EAAIF,EAAKE,IAAMG,EAAKH,IAC9CC,QAAwB,IAAhBE,EAAKF,OAAmB5hB,EAAGggB,OAASyB,EAAKG,OAASE,EAAKF,SAEnEqK,EAAKnC,WAAWnpB,OAChBohB,GAAWrJ,GACXlb,EAAKmhD,YAAa,EAClB3+C,EAAG2tC,cAAc,mBAAoBnwC,MAxjO5B,CAAA,IAAA,4BA2jOb,MAAA,SAA0BoF,EAAGmW,EAAMpD,EAASkV,GAClC3F,IAAAA,EAAS6G,GAAYC,MAAMjT,GAC7B,MAAkB,mBAAXmM,EACAA,EAAO,KAAMtiB,EAAG+S,EAASkV,GAE7B,KAhkOE,CAAA,IAAA,iBAmkOb,MAAA,SAAe7V,GACLhV,IACAksB,EADK,KACQ7N,KAAKzG,SAAS5C,GAC3ByV,EAFK,KAES24B,UAChBn3B,EAAOxB,EAASmD,OAAO,SAAAnoB,GAAKA,OAAAA,GAAKA,EAAE4/C,WAAan5B,IAASnrB,MAiBtDkrB,OAhBFA,IACDA,EAAOxB,EAASzV,GAAgB,CAC5BzV,KAAM,KACN8e,KAAM,GACN6N,QAAS,KACTpC,WAAY,KACZm9B,OAAQ,KACRpoB,QAAS,KACTE,QAAS,KACTymB,MAAOt5B,GAAWA,EAAQs5B,OAAS,EACnCvwC,MAAOD,EACPqwC,SAAUn5B,EACVmR,QAAS,GACTtT,SAAS,IAGVkC,IAxlOE,CAAA,IAAA,aA2lOb,MAAA,WACW,OAAA,KAAKoS,WAAa,KAAKA,SAAW,CAACj/B,MAAO,KAAMG,KAAM,YA5lOpD,CAAA,IAAA,yBA+lOb,MAAA,WACW,OAAA,KAAKmrB,+BAA+BlqB,SAhmOlC,CAAA,IAAA,mBAmmOb,MAAA,SAAiBwU,GACPkX,IAAAA,EAAU,KAAK7N,KAAKzG,SAAS5C,GAC/B,IAACkX,EACM,OAAA,EAELD,IAAAA,EAAO,KAAKE,eAAenX,GAC1B,MAAuB,kBAAhBiX,EAAKg7B,QAAwBh7B,EAAKg7B,QAAU/6B,EAAQ+6B,SAzmOzD,CAAA,IAAA,uBA4mOb,MAAA,SAAqBjyC,EAAcmlB,GAClB,KAAKhO,eAAenX,GAC5BiyC,QAAU9sB,IA9mON,CAAA,IAAA,uBAinOb,MAAA,SAAqBllB,GACZwuC,KAAAA,eAAexuC,IAAU,KAAKwuC,eAAexuC,KAlnOzC,CAAA,IAAA,oBAqnOb,MAAA,SAAkBA,GACP,OAAC,KAAKwuC,eAAexuC,KAtnOnB,CAAA,IAAA,2BAynOb,MAAA,SAAyBD,EAAcmlB,GAC7Bn6B,IACA+Y,EAAOohB,EAAU,OAAS,OAC1BlO,EAFK,KAEKE,eAAenX,GACzB3V,EAAQ4sB,EAAKnC,WAAW4Z,wBAAmBvkC,EAAW4Z,GAHjD,KAIRmuC,qBAAqBlyC,EAAcmlB,GACtC96B,EAAMkwB,OAAOtD,EAAM,CAACkO,QAAAA,IALT,KAMR5K,OAAO,SAAC7W,GAAQA,OAAAA,EAAI1D,eAAiBA,EAAe+D,OAAO5Z,MAhoOrD,CAAA,IAAA,OAmoOb,MAAA,SAAK6V,GACImyC,KAAAA,yBAAyBnyC,GAAc,KApoOnC,CAAA,IAAA,OAuoOb,MAAA,SAAKA,GACImyC,KAAAA,yBAAyBnyC,GAAc,KAxoOnC,CAAA,IAAA,sBA2oOb,MAAA,SAAoBA,GACVhV,IACAisB,EADK,KACKm3B,WADL,KACqBA,UAAUpuC,GACtCiX,GAAQA,EAAKnC,aACbmC,EAAKnC,WAAWs9B,kBAHT,KAIGhE,UAAUpuC,MAhpOf,CAAA,IAAA,UAopOb,MAAA,WACUhV,IAEFS,EAAGoU,EAFD7U,EAAK,KACJ4f,EAAe5f,EAAf4f,OAAQlH,EAAO1Y,EAAP0Y,IAIVjY,IAFLT,EAAG+7C,OACHl9C,EAASwoD,OAAOrnD,GACXS,EAAI,EAAGoU,EAAO7U,EAAGqe,KAAKzG,SAASpX,OAAQC,EAAIoU,IAAQpU,EACpDT,EAAGolD,oBAAoB3kD,GAE3BT,EAAGs6B,OAAO4mB,aACNthC,IACA5f,EAAGsnD,eACH3nC,GAAYC,EAAQlH,GACpB1Y,EAAG+X,SAASwvC,eAAe7uC,GAC3B1Y,EAAG4f,OAAS,KACZ5f,EAAG0Y,IAAM,MAEb1Y,EAAG2tC,cAAc,kBACVgV,GAAU3iD,EAAGuT,MAtqOX,CAAA,IAAA,gBAyqOb,MAAA,WAAuB,IAAA,EACZ,OAAKqM,EAAAA,KAAAA,QAAO4nC,UAAnB,MAAA,EAAA,aA1qOS,CAAA,IAAA,aA6qOb,MAAA,WACUxnD,IAAAA,EAAK,KACLP,EAAYO,EAAGsjD,WACfvrC,EAAW/X,EAAG+X,SACd0vC,EAAO,SAACloD,EAAMulB,GAChB/M,EAASsR,iBAAiBrpB,EAAIT,EAAMulB,GACpCrlB,EAAUF,GAAQulB,GAEhB4iC,EAAU,SAACnoD,EAAMulB,GACfrlB,EAAUF,KACVwY,EAASuR,oBAAoBtpB,EAAIT,EAAMulB,UAChCrlB,EAAUF,KAGrBulB,EAAW,SAAUliB,EAAG6C,EAAGwW,GAC3BrZ,EAAE4kB,QAAU/hB,EACZ7C,EAAE6kB,QAAUxL,EACZjc,EAAG0mD,cAAc9jD,IAGjB5C,GADJuU,GAAKvU,EAAG2V,QAAQuC,OAAQ,SAAC3Y,GAASkoD,OAAAA,EAAKloD,EAAMulB,KACzC9kB,EAAG2V,QAAQ2D,WAAY,CAMnBquC,IAAAA,EALJ7iC,EAAW,SAACnG,EAAOqB,GACXhgB,EAAG4f,QACH5f,EAAG+zB,OAAOpV,EAAOqB,IAInB0jC,IAAAA,EAAW,SAAXA,IACFgE,EAAQ,SAAUhE,GAClB1jD,EAAG0jD,UAAW,EACd1jD,EAAG+zB,SACH0zB,EAAK,SAAU3iC,GACf2iC,EAAK,SAAUE,IAEnBA,EAAW,WACP3nD,EAAG0jD,UAAW,EACdgE,EAAQ,SAAU5iC,GAClB2iC,EAAK,SAAU/D,IAEf3rC,EAAS6vC,WAAW5nD,EAAG4f,QACvB8jC,IAEAiE,SAGJ3nD,EAAG0jD,UAAW,IA1tOT,CAAA,IAAA,eA8tOb,MAAA,WACU1jD,IAAAA,EAAK,KACLP,EAAYO,EAAGsjD,WAChB7jD,WAGEO,EAAGsjD,WACV/uC,GAAK9U,EAAW,SAACqlB,EAAUvlB,GACvBS,EAAG+X,SAASuR,oBAAoBtpB,EAAIT,EAAMulB,QAtuOrC,CAAA,IAAA,mBA0uOb,MAAA,SAAiBvkB,EAAOwY,EAAMkuB,GACpBkN,IACIzzC,EAAMD,EAAGoU,EADbs/B,EAASlN,EAAU,MAAQ,SAM5BxmC,IAJQ,YAATsY,GACO,KAAKoT,eAAe5rB,EAAM,GAAGyU,cAC/B8U,WAAW,IAAMqqB,EAAS,uBAE9B1zC,EAAI,EAAGoU,EAAOtU,EAAMC,OAAQC,EAAIoU,IAAQpU,EAAG,CAEtCqpB,IAAAA,GADNppB,EAAOH,EAAME,KACc,KAAK0rB,eAAezrB,EAAKsU,cAAc8U,WAC9DA,GACAA,EAAWqqB,EAAS,cAAczzC,EAAK2lB,QAAS3lB,EAAKsU,aAActU,EAAKuU,UArvOvE,CAAA,IAAA,oBA0vOb,MAAA,WACW,OAAA,KAAKrU,SAAW,KA3vOd,CAAA,IAAA,oBA8vOb,MAAA,SAAkBinD,GACR7nD,IAAAA,EAAK,KACL8nD,EAAa9nD,EAAGY,SAAW,GAC3Bo5B,EAAS6tB,EAAe5lD,IAAI,SAA2B,GAAzB+S,IAAAA,EAAAA,EAAAA,aAAcC,EAAAA,EAAAA,MACxCgX,EAAOjsB,EAAGmsB,eAAenX,GAC3B,IAACiX,EACK,MAAA,IAAIypB,MAAM,6BAA+B1gC,GAE5C,MAAA,CACHA,aAAAA,EACAqR,QAAS4F,EAAK5N,KAAKpJ,GACnBA,MAAAA,MAGSP,GAAeslB,EAAQ8tB,KAEpC9nD,EAAGY,QAAUo5B,EACbh6B,EAAG+nD,mBAAmB/tB,EAAQ8tB,MA/wOzB,CAAA,IAAA,gBAmxOb,MAAA,SAAcvJ,EAAM/gD,GACT,OAAA,KAAKgmD,SAASwE,OAAO,KAAMzJ,EAAM/gD,KApxO/B,CAAA,IAAA,qBAuxOb,MAAA,SAAmBw8B,EAAQ8tB,EAAYG,GAC7BjoD,IACAkoD,EADK,KACavyC,QAAQ6C,MAC1BsvB,EAAO,SAACtlC,EAAGC,GAAMD,OAAAA,EAAEorB,OAAO,SAAAnoB,GAAK,OAAChD,EAAE28C,KAAK,SAAAnjC,GAAKxW,OAAAA,EAAEuP,eAAiBiH,EAAEjH,cAAgBvP,EAAEwP,QAAUgH,EAAEhH,WAC/FkzC,EAAcrgB,EAAKggB,EAAY9tB,GAC/BouB,EAAYH,EAASjuB,EAAS8N,EAAK9N,EAAQ8tB,GAC7CK,EAAY3nD,QALL,KAMJ6nD,iBAAiBF,EAAaD,EAAanvC,MAAM,GAEpDqvC,EAAU5nD,QAAU0nD,EAAanvC,MAR1B,KASJsvC,iBAAiBD,EAAWF,EAAanvC,MAAM,KAjyO7C,CAAA,IAAA,gBAqyOb,MAAA,SAAcnW,EAAGqlD,GACPjoD,IAAAA,EAAK,KACLxC,EAAO,CAAC8D,MAAOsB,EAAGqlD,OAAAA,EAAQtJ,YAAY,GACxC3+C,IAA0C,IAA1CA,EAAG2tC,cAAc,cAAenwC,GAAhCwC,CAGEsvB,IAAAA,EAAUtvB,EAAGsoD,aAAa1lD,EAAGqlD,GAM5BjoD,OALPxC,EAAKmhD,YAAa,EAClB3+C,EAAG2tC,cAAc,aAAcnwC,IAC3B8xB,GAAW9xB,EAAK8xB,UAChBtvB,EAAGwkD,SAEAxkD,KAjzOE,CAAA,IAAA,eAozOb,MAAA,SAAa4C,EAAGqlD,GACNjoD,IAKFsvB,EALEtvB,EAAK,KACiCA,EAAAA,EAArCY,QAASknD,OAAa,IAAA,EAAA,GAFT,EAEanyC,EAAW3V,EAAX2V,QAC3BuyC,EAAevyC,EAAQ6C,MACvBqS,EAAmBo9B,EACrBjuB,EAAS,GAETuuB,EAAY,KAkBTj5B,MAjBQ,aAAX1sB,EAAErD,OACFy6B,EAASh6B,EAAGwoD,0BAA0B5lD,EAAGslD,EAAanvC,KAAMmvC,EAAcr9B,GAC1E09B,EAAuB,UAAX3lD,EAAErD,KAAmBS,EAAGqjD,WAAazgD,GAErD5C,EAAGqjD,WAAa,KAChBpmD,GAAS0Y,EAAQuD,QAAS,CAACtW,EAAGo3B,EAAQh6B,GAAKA,GAC5B,YAAX4C,EAAErD,MAAiC,UAAXqD,EAAErD,MAA+B,gBAAXqD,EAAErD,MAC5CgiB,GAAe3e,EAAG5C,EAAG8qB,UAAW9qB,EAAG+qB,cACnC9tB,GAAS0Y,EAAQwD,QAAS,CAACvW,EAAGo3B,EAAQh6B,GAAKA,KAGnDsvB,GAAW5a,GAAeslB,EAAQ8tB,KACnBG,KACXjoD,EAAGY,QAAUo5B,EACbh6B,EAAG+nD,mBAAmB/tB,EAAQ8tB,EAAYG,IAE9CjoD,EAAGqjD,WAAakF,EACTj5B,MA70OE,EAAA,GAi1OXm5B,GAAoB,WAAMl0C,OAAAA,GAAKzX,GAAM6lD,UAAW,SAACvjD,GAAUA,OAAAA,EAAMokD,SAAS6C,gBA2CvEqC,SAAAA,KACC,MAAA,IAAIhT,MAAM,6GA1CpBhlC,OAAOuJ,iBAAiBnd,GAAO,CAC3Bya,SAAU,CACN4C,YAHW,EAIXpH,MAAOwE,IAEXorC,UAAW,CACPxoC,YAPW,EAQXpH,MAAO4vC,IAEX7rC,UAAW,CACPqD,YAXW,EAYXpH,MAAO+D,IAEXymC,SAAU,CACNpjC,YAfW,EAgBXpH,MAAOwqC,IAEXuE,QAAS,CACL3nC,YAnBW,EAoBXpH,MAr0BM,SAu0BV6vC,SAAU,CACNzoC,YAvBW,EAwBXpH,MAAO6vC,IAEX/F,SAAU,CACN1iC,YA3BW,EA4BXpH,MAAO,WACHwqC,GAAS73B,IAAT63B,MAAAA,GAAA,WACAkL,OAGRE,WAAY,CACRxuC,YAlCW,EAmCXpH,MAAO,WACHwqC,GAAS8J,OAAT9J,MAAAA,GAAA,WACAkL,SASNG,IAAAA,GAh4OW,WAi4ODjzC,SAAAA,EAAAA,GAAS,EAAA,KAAA,GACZA,KAAAA,QAAUA,GAAW,GAl4OjB,OAAA,EAAA,EAAA,CAAA,CAAA,IAAA,UAq4Ob,MAAA,WACW+yC,OAAAA,OAt4OE,CAAA,IAAA,QAy4Ob,MAAA,SAAM31C,EAAOqyB,GACFsjB,OAAAA,OA14OE,CAAA,IAAA,SA64Ob,MAAA,SAAOG,EAAWzjB,GACPsjB,OAAAA,OA94OE,CAAA,IAAA,MAi5Ob,MAAA,SAAIG,EAAWC,EAAQC,GACZL,OAAAA,OAl5OE,CAAA,IAAA,OAq5Ob,MAAA,SAAKlmD,EAAGC,EAAGsmD,GACAL,OAAAA,OAt5OE,CAAA,IAAA,UAy5Ob,MAAA,SAAQG,EAAWE,EAAMC,GACdN,OAAAA,OA15OE,CAAA,IAAA,QA65Ob,MAAA,SAAMG,EAAWE,GACNL,OAAAA,SA95OE,EAAA,GAk6OjBE,GAAYvT,SAAW,SAAU4T,GAC7Bv4C,OAAOW,OAAOu3C,GAAYlrD,UAAWurD,IAErCC,IAAAA,GAAY,CACZC,MAAOP,IAeFQ,SAAAA,GAAqB7vC,GACpBlC,IAEF5W,EAAGoU,EAAMw0C,EAAM3oB,EAFbrpB,EAbDiyC,SAAkB/vC,GACnB,IAACA,EAAMkyB,OAAO8d,KAAM,CAGf,IAFC1d,IAAAA,EAAQtyB,EAAMuyB,wBAAwB,OACxCz0B,EAAS,GACJ5W,EAAI,EAAGoU,EAAOg3B,EAAMrrC,OAAQC,EAAIoU,EAAMpU,IAC3C4W,EAASA,EAAOyZ,OAAO+a,EAAMprC,GAAGqpB,WAAW0/B,mBAAmBjwC,IAElEA,EAAMkyB,OAAO8d,KAAO/jC,GAAanO,EAAOwE,KAAK,SAACrZ,EAAGC,GAAMD,OAAAA,EAAIC,KAExD8W,OAAAA,EAAMkyB,OAAO8d,KAILD,CAAkB/vC,GAC7BxZ,EAAMwZ,EAAMqtB,QAEV6iB,EAAmB,WACrB1pD,EAAMD,KAAKC,IAAIA,EAAKU,GAAKX,KAAKqc,IAAIktC,EAAO3oB,IAAS3gC,GAClD2gC,EAAO2oB,GAEN5oD,IAAAA,EAAI,EAAGoU,EAAOwC,EAAO7W,OAAQC,EAAIoU,IAAQpU,EAC1C4oD,EAAO9vC,EAAM42B,iBAAiB94B,EAAO5W,IACrCgpD,IAEChpD,IAAAA,EAAI,EAAGoU,EAAO0E,EAAMisB,MAAMhlC,OAAQC,EAAIoU,IAAQpU,EAC/C4oD,EAAO9vC,EAAM6wB,gBAAgB3pC,GAC7BgpD,IAEG1pD,OAAAA,EA+DF2pD,SAAAA,GAAWx2B,EAAOxyB,EAAMk8B,EAAQn8B,GAM9BC,OALHkE,GAAQsuB,GAvBPy2B,SAAcz2B,EAAOxyB,EAAMk8B,EAAQn8B,GAClCmpD,IAAAA,EAAahtB,EAAOqE,MAAM/N,EAAM,GAAIzyB,GACpCopD,EAAWjtB,EAAOqE,MAAM/N,EAAM,GAAIzyB,GAClCV,EAAMD,KAAKC,IAAI6pD,EAAYC,GAC3BhoD,EAAM/B,KAAK+B,IAAI+nD,EAAYC,GAC7BC,EAAW/pD,EACXgqD,EAASloD,EACT/B,KAAKqc,IAAIpc,GAAOD,KAAKqc,IAAIta,KACzBioD,EAAWjoD,EACXkoD,EAAShqD,GAEbW,EAAKk8B,EAAO/S,MAAQkgC,EACpBrpD,EAAKspD,QAAU,CACXF,SAAAA,EACAC,OAAAA,EACAvrD,MAAOorD,EACPnrD,IAAKorD,EACL9pD,IAAAA,EACA8B,IAAAA,GAMA8nD,CAAcz2B,EAAOxyB,EAAMk8B,EAAQn8B,GAEnCC,EAAKk8B,EAAO/S,MAAQ+S,EAAOqE,MAAM/N,EAAOzyB,GAErCC,EAGFupD,SAAAA,GAAsBh+B,EAAM5N,EAAM7f,EAAOgiC,GACxCxW,IAKFvpB,EAAGoU,EAAMnU,EAAMwyB,EALblJ,EAASiC,EAAKjC,OACd4S,EAAS3Q,EAAK2Q,OACdkE,EAAS9W,EAAO+W,YAChBC,EAAchX,IAAW4S,EACzBF,EAAS,GAEVj8B,IAAAA,EAAIjC,EAAOqW,EAAOrW,EAAQgiC,EAAO//B,EAAIoU,IAAQpU,EAC9CyyB,EAAQ7U,EAAK5d,IACbC,EAAO,IACFspB,EAAOH,MAAQmX,GAAehX,EAAOiX,MAAMH,EAAOrgC,GAAIA,GAC3Di8B,EAAOj7B,KAAKioD,GAAWx2B,EAAOxyB,EAAMk8B,EAAQn8B,IAEzCi8B,OAAAA,EAGFwtB,SAAAA,GAAWC,GACTA,OAAAA,QAA8BhrD,IAApBgrD,EAAOL,eAA4C3qD,IAAlBgrD,EAAOJ,OAGvDK,IAAAA,GAjiPW,SAAA,GAAA,EAAA,EAiiPW1sB,IAjiPX,IAAA,EAAA,EAAA,GAAA,SAAA,IAAA,OAAA,EAAA,KAAA,GAAA,EAAA,MAAA,KAAA,WAAA,OAAA,EAAA,EAAA,CAAA,CAAA,IAAA,qBAkiPb,MAAA,SAAmBzR,EAAM5N,EAAM7f,EAAOgiC,GAC3BypB,OAAAA,GAAsBh+B,EAAM5N,EAAM7f,EAAOgiC,KAniPvC,CAAA,IAAA,iBAsiPb,MAAA,SAAevU,EAAM5N,EAAM7f,EAAOgiC,GACvBypB,OAAAA,GAAsBh+B,EAAM5N,EAAM7f,EAAOgiC,KAviPvC,CAAA,IAAA,kBA0iPb,MAAA,SAAgBvU,EAAM5N,EAAM7f,EAAOgiC,GACxBxW,IAKHvpB,EAAGoU,EAAMnU,EAAMsR,EALZgY,EAAkBiC,EAAlBjC,OAAQ4S,EAAU3Q,EAAV2Q,OAC0B,EAAA,KAAKmB,SAAvCmD,EAAAA,EAAAA,SAAAA,OAAW,IAAA,EAAA,IAFoB,EAEfC,EAAAA,EAAAA,SAAAA,OAAW,IAAA,EAAA,IAFI,EAGhCkpB,EAA2B,MAAhBrgC,EAAOH,KAAeqX,EAAWC,EAC5CmpB,EAA2B,MAAhB1tB,EAAO/S,KAAeqX,EAAWC,EAC5CzE,EAAS,GAEVj8B,IAAAA,EAAIjC,EAAOqW,EAAOrW,EAAQgiC,EAAO//B,EAAIoU,IAAQpU,EAC9CuR,EAAMqM,EAAK5d,IACXC,EAAO,IACFspB,EAAOH,MAAQG,EAAOiX,MAAMzqB,GAAiBxE,EAAKq4C,GAAW5pD,GAClEi8B,EAAOj7B,KAAKioD,GAAWlzC,GAAiBxE,EAAKs4C,GAAW5pD,EAAMk8B,EAAQn8B,IAEnEi8B,OAAAA,IAvjPE,CAAA,IAAA,wBA0jPb,MAAA,SAAsBh4B,EAAO6U,EAAOmjB,EAAQZ,GACZp3B,EAAAA,EAAAA,EAAAA,WAAAA,wBAAAA,MAAAA,KAAAA,KAAAA,EAAO6U,EAAOmjB,EAAQZ,GAC5CquB,IAAAA,EAASztB,EAAOstB,QAClBG,GAAU5wC,IAAU,KAAK0Q,YAAY2S,SACrCl4B,EAAM3E,IAAMD,KAAKC,IAAI2E,EAAM3E,IAAKoqD,EAAOpqD,KACvC2E,EAAM7C,IAAM/B,KAAK+B,IAAI6C,EAAM7C,IAAKsoD,EAAOtoD,QA/jPlC,CAAA,IAAA,mBAmkPb,MAAA,SAAiBoT,GACPjV,IACAisB,EADK,KACKhC,YACTD,EAAkBiC,EAAlBjC,OAAQ4S,EAAU3Q,EAAV2Q,OACTF,EAHK,KAGOuF,UAAUhtB,GACtBk1C,EAASztB,EAAOstB,QAChBj3C,EAAQm3C,GAAWC,GACnB,IAAMA,EAAO3rD,MAAQ,KAAO2rD,EAAO1rD,IAAM,IACzC,GAAKm+B,EAAOuF,iBAAiBzF,EAAOE,EAAO/S,OAC1C,MAAA,CACHqY,MAAO,GAAKlY,EAAOmY,iBAAiBzF,EAAO1S,EAAOH,OAClD9W,MAAAA,KA9kPK,CAAA,IAAA,aAklPb,MAAA,WACe,KACRqrB,qBAAsB,EACzB,EAAA,EAAA,EAAA,WAAA,aAAA,MAAA,KAAA,MAFW,KAGKnU,YACX6R,MAJM,KAIK4C,aAAa5C,QAvlPpB,CAAA,IAAA,SA0lPb,MAAA,SAAO/iB,GACG/Y,IACAisB,EADK,KACKhC,YADL,KAERka,eAAelY,EAAK5N,KAAM,EAAG4N,EAAK5N,KAAK7d,OAAQuY,KA7lPzC,CAAA,IAAA,iBAgmPb,MAAA,SAAewxC,EAAM/rD,EAAOgiC,EAAOznB,GACzB/Y,IAAAA,EAAK,KACLgmD,EAAiB,UAATjtC,EACR6jB,EAAS58B,EAAGiqB,YAAY2S,OACxBzX,EAAOyX,EAAO4tB,eACdh8B,EAAaoO,EAAOnM,eACpBg6B,EAAQzqD,EAAG0qD,YACXC,EAAY3qD,EAAGwiC,0BAA0BhkC,EAAOua,GAChDyqB,EAAgBxjC,EAAG2jC,iBAAiBgnB,GACpCC,EAAiB5qD,EAAG4qD,eAAe7xC,EAAMyqB,GAC/CxjC,EAAG6qD,oBAAoBrnB,EAAezqB,EAAM4xC,GACvC,IAAA,IAAIlqD,EAAIjC,EAAOiC,EAAIjC,EAAQgiC,EAAO//B,IAAK,CAClCqqD,IAAAA,EAAU9E,EAAQ,CAAC7gC,KAAAA,EAAM4lC,KAAM5lC,GAAQnlB,EAAGgrD,yBAAyBvqD,GACnEwqD,EAAUjrD,EAAGkrD,yBAAyBzqD,EAAGgqD,GACzC3wB,EAAa,CACftL,WAAAA,EACArJ,KAAM2lC,EAAQ3lC,KACd1f,EAAG+oB,EAAas8B,EAAQC,KAAOE,EAAQx/B,OACvCxP,EAAGuS,EAAay8B,EAAQx/B,OAASq/B,EAAQC,KACzC/qC,OAAQwO,EAAay8B,EAAQ5yC,UAAOlZ,EACpCwf,MAAO6P,OAAarvB,EAAY8rD,EAAQ5yC,MAExCuyC,IACA9wB,EAAWnkB,QAAU6tB,GAAiBxjC,EAAGwiC,0BAA0B/hC,EAAGsY,IAE1E/Y,EAAGmrD,cAAcZ,EAAK9pD,GAAIA,EAAGq5B,EAAY/gB,MAznPpC,CAAA,IAAA,aA6nPb,MAAA,SAAWsuB,EAAM3E,GACP1iC,IAOFS,EAAGC,EALDspB,EAFK,KACKC,YACID,OACdS,EAAWT,EAAO8hB,wBAHb,KAGwChO,OAC7C3B,EAAUnS,EAAOrU,QAAQwmB,QACzBtnB,EAAO4V,EAASjqB,OAChB67B,EAAS,GAEV57B,IAAAA,EAAI,EAAGA,EAAIoU,IAAQpU,EAAG,CAEnB,GADJC,EAAO+pB,EAAShqB,QACS,IAAdiiC,EAA2B,CAC5BhwB,IAAAA,EAAMhS,EAAKopB,WAAWmY,UAAUS,GAClChiC,EAAKopB,WAAWG,YAAY2S,OAAO/S,MAEnCrW,GAAAA,GAAcd,IAAQqJ,MAAMrJ,GAC5B,SAOJhS,KAJY,IAAZy7B,IAAqD,IAAhCE,EAAO5mB,QAAQ/U,EAAKo7B,aAC5B38B,IAAZg9B,QAAwCh9B,IAAfuB,EAAKo7B,QAC/BO,EAAO56B,KAAKf,EAAKo7B,OAEjBp7B,EAAKuU,QAAUoyB,EACf,MAMDhL,OAHFA,EAAO77B,QACR67B,EAAO56B,UAAKtC,GAETk9B,IA3pPE,CAAA,IAAA,iBA8pPb,MAAA,SAAepnB,GACJ,OAAA,KAAKm2C,gBAAWjsD,EAAW8V,GAAOzU,SA/pPhC,CAAA,IAAA,iBAkqPb,MAAA,SAAewU,EAAc2E,GACnB0iB,IAAAA,EAAS,KAAK+uB,WAAWp2C,GACzBC,OAAkB9V,IAATwa,EACT0iB,EAAO5mB,QAAQkE,IACd,EACC1E,OAAW,IAAXA,EACFonB,EAAO77B,OAAS,EAChByU,IAzqPG,CAAA,IAAA,YA4qPb,MAAA,WACUjV,IAKFS,EAAGoU,EAJD+N,EADK,KACKjN,QACVsW,EAFK,KAEKhC,YACVD,EAASiC,EAAKjC,OACdqhC,EAAS,GAEV5qD,IAAAA,EAAI,EAAGoU,EAAOoX,EAAK5N,KAAK7d,OAAQC,EAAIoU,IAAQpU,EAC7C4qD,EAAO5pD,KAAKuoB,EAAOmmB,iBAPZ,KAOgClO,UAAUxhC,GAAGupB,EAAOH,MAAOppB,IAEhE6qD,IAAAA,EAAe1oC,EAAK0oC,aAEnB,MAAA,CACHvrD,IAFQurD,GAAgBlC,GAAqBp/B,GAG7CqhC,OAAAA,EACA7sD,MAAOwrB,EAAOigB,YACdxrC,IAAKurB,EAAOkgB,UACZqhB,WAhBO,KAgBQC,iBACfjyC,MAAOyQ,EACPyhC,QAAS7oC,EAAK6oC,QACdx6C,MAAOq6C,EAAe,EAAI1oC,EAAK8oC,mBAAqB9oC,EAAK+oC,iBAhsPpD,CAAA,IAAA,2BAosPb,MAAA,SAAyB12C,GACfjV,IASF+qD,EAAM1yC,EARiBrY,EADhB,KACmBiqB,YAAvB2S,EAAAA,EAAAA,OAAQ4B,EAAAA,EAAAA,SACyBx+B,EAF7B,KAEgC2V,QAA9Bi2C,EAANzmC,EAAAA,KAAiB0mC,EAAAA,EAAAA,aAClBnvB,EAHK,KAGOuF,UAAUhtB,GACtBk1C,EAASztB,EAAOstB,QAChB8B,EAAW5B,GAAWC,GACxBp3C,EAAQ2pB,EAAOE,EAAO/S,MACtBrrB,EAAQ,EACRgC,EAASg+B,EARF,KAQgB3C,WAAWe,EAAQF,EAAQ8B,GAAYzrB,EAE9DvS,IAAWuS,IACXvU,EAAQgC,EAASuS,EACjBvS,EAASuS,GAET+4C,IACA/4C,EAAQo3C,EAAOL,SACftpD,EAAS2pD,EAAOJ,OAASI,EAAOL,SAClB,IAAV/2C,GAAeoI,GAAKpI,KAAWoI,GAAKgvC,EAAOJ,UAC3CvrD,EAAQ,GAEZA,GAASuU,GAEP62C,IAAAA,EAAcp2C,GAAco4C,IAAeE,EAAuBttD,EAAZotD,EACxDzmC,EAAOyX,EAAOuT,iBAAiByZ,GAMnCvxC,GAJI0yC,EADA,KAAK3rD,MAAM2sD,kBAAkB92C,GACtB2nB,EAAOuT,iBAAiB3xC,EAAQgC,GAEhC2kB,GAEGA,OACOhmB,IAAjB0sD,GAA8B/rD,KAAKqc,IAAI9D,GAAQwzC,IAC/CxzC,EAAOA,EAAO,GAAKwzC,EAAeA,EACpB,IAAV94C,IACAoS,GAAQ9M,EAAO,GAEnB0yC,EAAO5lC,EAAO9M,GAEZ2zC,IAAAA,EAAaJ,GAAa,EAC5BzmC,GAAAA,IAASyX,EAAOuT,iBAAiB6b,GAAa,CACxCC,IAAAA,EAAWrvB,EAAOsvB,qBAAqBF,GAAc,EACvD3zC,EAAO,GACP8M,GAAQ8mC,EACR5zC,GAAQ4zC,GACD5zC,EAAO,IACd8M,GAAQ8mC,EACR5zC,GAAQ4zC,GAGT,MAAA,CACH5zC,KAAAA,EACA8M,KAAAA,EACA4lC,KAAAA,EACAt/B,OAAQs/B,EAAO1yC,EAAO,KAzvPjB,CAAA,IAAA,2BA6vPb,MAAA,SAAyBpD,EAAOw1C,GACtBzqD,IAIFyrB,EAAQpT,EAJNrY,EAAK,KACLuZ,EAAQkxC,EAAMlxC,MACd5D,EAAU3V,EAAG2V,QACbw2C,EAAkBl4C,GAAe0B,EAAQw2C,gBAAiBC,EAAAA,GAE5D3B,GAAAA,EAAMgB,QAAS,CACTF,IAAAA,EAAa51C,EAAQ02C,SAAWrsD,EAAGwrD,eAAev2C,GAASw1C,EAAMc,WACjE7mD,EAAiC,SAAzBiR,EAAQ21C,aA5SzBgB,SAA0Br3C,EAAOw1C,EAAO90C,EAAS41C,GAChDF,IAAAA,EAASZ,EAAMY,OACfhC,EAAOgC,EAAOp2C,GAChByrB,EAAOzrB,EAAQ,EAAIo2C,EAAOp2C,EAAQ,GAAK,KACvCwyB,EAAOxyB,EAAQo2C,EAAO7qD,OAAS,EAAI6qD,EAAOp2C,EAAQ,GAAK,KACrDs3C,EAAU52C,EAAQ+1C,mBACX,OAAThrB,IACAA,EAAO2oB,GAAiB,OAAT5hB,EAAgBgjB,EAAMhsD,IAAMgsD,EAAMjsD,MAAQipC,EAAO4hB,IAEvD,OAAT5hB,IACAA,EAAO4hB,EAAOA,EAAO3oB,GAEnBliC,IAAAA,EAAQ6qD,GAAQA,EAAOvpD,KAAKC,IAAI2gC,EAAM+G,IAAS,EAAI8kB,EAElD,MAAA,CACHC,MAFS1sD,KAAKqc,IAAIsrB,EAAO/G,GAAQ,EAAI6rB,EAEvBhB,EACdt6C,MAAO0E,EAAQg2C,cACfntD,MAAAA,GA4RU8tD,CAA0Br3C,EAAOw1C,EAAO90C,EAAS41C,GA9T1DkB,SAAyBx3C,EAAOw1C,EAAO90C,EAAS41C,GAC/CmB,IACFr0C,EAAMpH,EADJy7C,EAAY/2C,EAAQ21C,aASnB,OAPH93C,GAAck5C,IACdr0C,EAAOoyC,EAAM1qD,IAAM4V,EAAQ+1C,mBAC3Bz6C,EAAQ0E,EAAQg2C,gBAEhBtzC,EAAOq0C,EAAYnB,EACnBt6C,EAAQ,GAEL,CACHu7C,MAAOn0C,EAAOkzC,EACdt6C,MAAAA,EACAzS,MAAOisD,EAAMY,OAAOp2C,GAAUoD,EAAO,GAkT3Bo0C,CAAyBx3C,EAAOw1C,EAAO90C,EAAS41C,GAChDoB,EAAa3sD,EAAG4sD,eAAe5sD,EAAGiV,MAAOjV,EAAGiqB,YAAY6R,OAC9DrQ,EAAS/mB,EAAMlG,MAASkG,EAAM8nD,MAAQG,EAAejoD,EAAM8nD,MAAQ,EACnEn0C,EAAOvY,KAAKC,IAAIosD,EAAiBznD,EAAM8nD,MAAQ9nD,EAAMuM,YAErDwa,EAASlS,EAAM42B,iBAAiBnwC,EAAGiiC,UAAUhtB,GAAOsE,EAAMsQ,MAAO5U,GACjEoD,EAAOvY,KAAKC,IAAIosD,EAAiB1B,EAAM1qD,IAAM0qD,EAAMx5C,OAEhD,MAAA,CACHkU,KAAMsG,EAASpT,EAAO,EACtB0yC,KAAMt/B,EAASpT,EAAO,EACtBoT,OAAAA,EACApT,KAAAA,KAnxPK,CAAA,IAAA,OAuxPb,MAAA,WACUrY,IACAZ,EADK,KACMA,MACX6sB,EAFK,KAEKhC,YACV2S,EAAS3Q,EAAK2Q,OACdiwB,EAAQ5gC,EAAK5N,KACbxJ,EAAOg4C,EAAMrsD,OACfC,EAAI,EAEDA,IADPohB,GAASziB,EAAMsZ,IAAKtZ,EAAM0rB,WACnBrqB,EAAIoU,IAAQpU,EACsB,OAT9B,KASAwhC,UAAUxhC,GAAGm8B,EAAO/S,OACvBgjC,EAAMpsD,GAAGE,KAVN,KAUcg9B,MAGzB5b,GAAW3iB,EAAMsZ,SAryPR,EAAA,GAyyPjB0xC,GAAc72C,GAAK,MACnB62C,GAAc7yC,SAAW,CACrBwoB,oBAAoB,EACpB+C,gBAAiB,MACjB4oB,mBAAoB,GACpBC,cAAe,GACfF,SAAS,EACTvxB,WAAY,CACRH,QAAS,CACLx6B,KAAM,SACNu6B,WAAY,CAAC,IAAK,IAAK,OAAQ,QAAS,aAIpDswB,GAActzC,UAAY,CACtBgC,YAAa,CACTC,KAAM,SAEVS,OAAQ,CACJszC,QAAS,CACLvtD,KAAM,WACNinC,QAAQ,EACR6B,KAAM,CACF7B,QAAQ,IAGhBumB,QAAS,CACLxtD,KAAM,SACN4oC,aAAa,KAKnB6kB,IAAAA,GA10PW,SAAA,GAAA,EAAA,EA00PctvB,IA10Pd,IAAA,EAAA,EAAA,GAAA,SAAA,IAAA,OAAA,EAAA,KAAA,GAAA,EAAA,MAAA,KAAA,WAAA,OAAA,EAAA,EAAA,CAAA,CAAA,IAAA,aA20Pb,MAAA,WACSU,KAAAA,qBAAsB,EAC3B,EAAA,EAAA,EAAA,WAAA,aAAA,MAAA,KAAA,QA70PS,CAAA,IAAA,kBAg1Pb,MAAA,SAAgBnS,EAAM5N,EAAM7f,EAAOgiC,GACxBlB,IAGH7+B,EAAGoU,EAAMnU,EAHN4+B,EAAkBrT,EAAlBqT,OAAQE,EAAUvT,EAAVuT,OAC0B,EAAA,KAAKzB,SAAvCmD,EAAAA,EAAAA,SAAAA,OAAW,IAAA,EAAA,IAFoB,EAEfC,EAAAA,EAAAA,SAAAA,OAAW,IAAA,EAAA,IAFI,EAGhCzE,EAAS,GAEVj8B,IAAAA,EAAIjC,EAAOqW,EAAOrW,EAAQgiC,EAAO//B,EAAIoU,IAAQpU,EAC9CC,EAAO2d,EAAK5d,GACZi8B,EAAOj7B,KAAK,CACRgE,EAAG65B,EAAO2B,MAAMzqB,GAAiB9V,EAAMwgC,GAAWzgC,GAClDwb,EAAGujB,EAAOyB,MAAMzqB,GAAiB9V,EAAMygC,GAAW1gC,GAClDupD,QAAStpD,GAAQA,EAAK2C,IAAM3C,EAAK2C,IAGlCq5B,OAAAA,IA71PE,CAAA,IAAA,iBAg2Pb,MAAA,WAGS,IAFmB,IAAA,EAAA,KAAKzS,YAAtB5L,EAAAA,EAAAA,KAAMgf,EAAAA,EAAAA,QACTx7B,EAAM,EACDpB,EAAI4d,EAAK7d,OAAS,EAAGC,GAAK,IAAKA,EACpCoB,EAAM/B,KAAK+B,IAAIA,EAAKwc,EAAK5d,GAAG4X,OAAS,EAAGglB,EAAQ58B,GAAGupD,SAEhDnoD,OAAAA,EAAM,GAAKA,IAt2PT,CAAA,IAAA,mBAy2Pb,MAAA,SAAiBoT,GACPjV,IACAisB,EADK,KACKhC,YACTqV,EAAkBrT,EAAlBqT,OAAQE,EAAUvT,EAAVuT,OACT9C,EAHK,KAGOuF,UAAUhtB,GACtBxP,EAAI65B,EAAO6C,iBAAiBzF,EAAOj3B,GACnCwW,EAAIujB,EAAO2C,iBAAiBzF,EAAOzgB,GACnC5Y,EAAIq5B,EAAOstB,QACV,MAAA,CACH9nB,MAAOjW,EAAKiW,MACZnvB,MAAO,IAAMtN,EAAI,KAAOwW,GAAK5Y,EAAI,KAAOA,EAAI,IAAM,OAn3P7C,CAAA,IAAA,SAu3Pb,MAAA,SAAO0V,GACG/Y,IACA+2C,EADK,KACO9sB,YAAY5L,KADnB,KAER8lB,eAAe4S,EAAQ,EAAGA,EAAOv2C,OAAQuY,KA13PnC,CAAA,IAAA,iBA63Pb,MAAA,SAAeg+B,EAAQv4C,EAAOgiC,EAAOznB,GAO5B,IANC/Y,IAAAA,EAAK,KACLgmD,EAAiB,UAATjtC,EACW/Y,EAAAA,EAAGiqB,YAArBqV,EAAAA,EAAAA,OAAQE,EAAAA,EAAAA,OACTmrB,EAAY3qD,EAAGwiC,0BAA0BhkC,EAAOua,GAChDyqB,EAAgBxjC,EAAG2jC,iBAAiBgnB,GACpCC,EAAiB5qD,EAAG4qD,eAAe7xC,EAAMyqB,GACtC/iC,EAAIjC,EAAOiC,EAAIjC,EAAQgiC,EAAO//B,IAAK,CAClC+gB,IAAAA,EAAQu1B,EAAOt2C,GACfi8B,GAAUspB,GAAShmD,EAAGiiC,UAAUxhC,GAChCgF,EAAIugD,EAAQ1mB,EAAO2tB,mBAAmB,IAAO3tB,EAAO6Q,iBAAiBzT,EAAOj3B,GAC5EwW,EAAI+pC,EAAQxmB,EAAOgrB,eAAiBhrB,EAAO2Q,iBAAiBzT,EAAOzgB,GACnE6d,EAAa,CACfr0B,EAAAA,EACAwW,EAAAA,EACA0O,KAAM5O,MAAMtW,IAAMsW,MAAME,IAExB2uC,IACA9wB,EAAWnkB,QAAU3V,EAAGwiC,0BAA0B/hC,EAAGsY,GACjDitC,IACAlsB,EAAWnkB,QAAQ4K,OAAS,IAGpCvgB,EAAGmrD,cAAc3pC,EAAO/gB,EAAGq5B,EAAY/gB,GAE3C/Y,EAAG6qD,oBAAoBrnB,EAAezqB,EAAM4xC,KAt5PnC,CAAA,IAAA,4BAy5Pb,MAAA,SAA0B11C,EAAO8D,GACvB2jB,IAAAA,EAAS,KAAKuF,UAAUhtB,GAC1BoC,EAAyCpC,EAAAA,EAAAA,EAAAA,WAAAA,4BAAAA,MAAAA,KAAAA,KAAAA,EAAO8D,GAChD1B,EAAO0jB,UACP1jB,EAAS3G,OAAOW,OAAO,GAAIgG,EAAQ,CAAC0jB,SAAS,KAE3Cxa,IAAAA,EAASlJ,EAAOkJ,OAKflJ,MAJM,WAAT0B,IACA1B,EAAOkJ,OAAS,GAEpBlJ,EAAOkJ,QAAUtM,GAAeyoB,GAAUA,EAAOstB,QAASzpC,GACnDlJ,MAp6PE,EAAA,GAw6PjB21C,GAAiBz5C,GAAK,SACtBy5C,GAAiBz1C,SAAW,CACxBwoB,oBAAoB,EACpB+C,gBAAiB,QACjB5I,WAAY,CACRH,QAAS,CACLx6B,KAAM,SACNu6B,WAAY,CAAC,IAAK,IAAK,cAAe,aAIlDkzB,GAAiBl2C,UAAY,CACzB0C,OAAQ,CACJ/T,EAAG,CACClG,KAAM,UAEV0c,EAAG,CACC1c,KAAM,WAGd8Z,QAAS,CACL6zC,QAAS,CACL1tD,UAAW,CACPqpC,MAAQ,WACG,MAAA,QAiCrBskB,IAAAA,GAj+PW,SAAA,GAAA,EAAA,EAi+PgBzvB,IAj+PhB,IAAA,EAAA,EAAA,GAk+PDt+B,SAAAA,EAAAA,EAAO4V,GAAc,IAAA,EAAA,OAAA,EAAA,KAAA,IACvB5V,EAAAA,EAAAA,KAAAA,KAAAA,EAAO4V,IACRopB,qBAAsB,EACtBgvB,EAAAA,iBAAcjuD,EACdkuD,EAAAA,iBAAcluD,EACdqoB,EAAAA,aAAUroB,EACVsoB,EAAAA,aAAUtoB,EANc,EAl+PpB,OAAA,EAAA,EAAA,CAAA,CAAA,IAAA,aA2+Pb,MAAA,cA3+Pa,CAAA,IAAA,QA8+Pb,MAAA,SAAMX,EAAOgiC,GACHniB,IAEF5d,EAAGoU,EAFDwJ,EAAO,KAAKqgB,aAAargB,KACzB4N,EAAO,KAAKhC,YAEbxpB,IAAAA,EAAIjC,EAAOqW,EAAOrW,EAAQgiC,EAAO//B,EAAIoU,IAAQpU,EAC9CwrB,EAAKoR,QAAQ58B,IAAM4d,EAAK5d,KAn/PnB,CAAA,IAAA,eAu/Pb,MAAA,WACWgc,OAAAA,GAAU,KAAK9G,QAAQ2K,SAAW,MAx/PhC,CAAA,IAAA,oBA2/Pb,MAAA,WACW7D,OAAAA,GAAU,KAAK9G,QAAQ23C,iBA5/PrB,CAAA,IAAA,sBA+/Pb,MAAA,WAIS,IAHDvtD,IAAAA,EAAM2a,GACN7Y,GAAO6Y,GAEFja,EAAI,EAAGA,EADL,KACYrB,MAAMif,KAAKzG,SAASpX,SAAUC,EAC7CT,GAFG,KAEAZ,MAAMsmD,iBAAiBjlD,GAAI,CACxBqpB,IAAAA,EAHH,KAGmB1qB,MAAM+sB,eAAe1rB,GAAGqpB,WACxCxJ,EAAWwJ,EAAWyjC,eACtBD,EAAgBxjC,EAAW0jC,oBACjCztD,EAAMD,KAAKC,IAAIA,EAAKugB,GACpBze,EAAM/B,KAAK+B,IAAIA,EAAKye,EAAWgtC,GAGhC,MAAA,CACHhtC,SAAUvgB,EACVutD,cAAezrD,EAAM9B,KA9gQhB,CAAA,IAAA,SAkhQb,MAAA,SAAOgZ,GACG/Y,IAAAA,EAAK,KAEJ8qB,EADO9qB,EAAGZ,MACV0rB,UACDmB,EAAOjsB,EAAGiqB,YACVwjC,EAAOxhC,EAAK5N,KACZmpB,EAAUxnC,EAAG0tD,oBAAsB1tD,EAAG2tD,aAAaF,GACnDG,EAAU9tD,KAAK+B,KAAK/B,KAAKC,IAAI+qB,EAAUnM,MAAOmM,EAAU9K,QAAUwnB,GAAW,EAAG,GAChFqmB,EAAS/tD,KAAKC,IAAImU,GAAalU,EAAG2V,QAAQk4C,OAAQD,GAAU,GAC5DE,EAAc9tD,EAAG+tD,eAAe/tD,EAAGiV,OACPjV,EAAAA,EAAGguD,sBAA9BV,EAAAA,EAAAA,cACoCW,EAtF1CA,SAAkB3tC,EAAUgtC,EAAeO,GAC5CK,IAAAA,EAAS,EACTC,EAAS,EACT3mC,EAAU,EACVC,EAAU,EACV6lC,GAAAA,EAAgB5yC,GAAK,CACf0zC,IAAAA,EAAa9tC,EACb+tC,EAAWD,EAAad,EACxBgB,EAASxuD,KAAKkhB,IAAIotC,GAClBG,EAASzuD,KAAKihB,IAAIqtC,GAClBI,EAAO1uD,KAAKkhB,IAAIqtC,GAChBI,EAAO3uD,KAAKihB,IAAIstC,GAChBK,EAAU,SAACtxC,EAAO5a,EAAGC,GAAMmb,OAAAA,GAAcR,EAAOgxC,EAAYC,GAAY,EAAIvuD,KAAK+B,IAAIW,EAAGA,EAAIqrD,EAAQprD,EAAGA,EAAIorD,IAC3Gc,EAAU,SAACvxC,EAAO5a,EAAGC,GAAMmb,OAAAA,GAAcR,EAAOgxC,EAAYC,IAAa,EAAIvuD,KAAKC,IAAIyC,EAAGA,EAAIqrD,EAAQprD,EAAGA,EAAIorD,IAC5Ge,EAAOF,EAAQ,EAAGJ,EAAQE,GAC1BK,EAAOH,EAAQ3zC,GAASwzC,EAAQE,GAChCK,EAAOH,EAAQl0C,GAAI6zC,EAAQE,GAC3BO,EAAOJ,EAAQl0C,GAAKM,GAASwzC,EAAQE,GAC3CP,GAAUU,EAAOE,GAAQ,EACzBX,GAAUU,EAAOE,GAAQ,EACzBvnC,IAAYonC,EAAOE,GAAQ,EAC3BrnC,IAAYonC,EAAOE,GAAQ,EAExB,MAAA,CAACb,OAAAA,EAAQC,OAAAA,EAAQ3mC,QAAAA,EAASC,QAAAA,GA+DcwmC,CADrB3tC,EAAAA,SACiDgtC,EAAeO,GAA/EK,EAAAA,EAAAA,OAAQC,EAAAA,EAAAA,OAAQ3mC,EAAAA,EAAAA,QAASC,EAAAA,EAAAA,QAC1BjE,GAAYsH,EAAUnM,MAAQ6oB,GAAW0mB,EACzC9lC,GAAa0C,EAAU9K,OAASwnB,GAAW2mB,EAC3Ca,EAAYlvD,KAAK+B,IAAI/B,KAAKC,IAAIyjB,EAAU4E,GAAa,EAAG,GACxDilC,EAAc/4C,GAAYtU,EAAG2V,QAAQ4K,OAAQyuC,GAE7CC,GAAgB5B,EADFvtD,KAAK+B,IAAIwrD,EAAcQ,EAAQ,IACA7tD,EAAGkvD,gCACtDlvD,EAAGwnB,QAAUA,EAAU6lC,EACvBrtD,EAAGynB,QAAUA,EAAU4lC,EACvBphC,EAAKoF,MAAQrxB,EAAGmvD,iBAChBnvD,EAAGqtD,YAAcA,EAAc4B,EAAejvD,EAAGovD,qBAAqBpvD,EAAGiV,OACzEjV,EAAGotD,YAActtD,KAAK+B,IAAI7B,EAAGqtD,YAAc4B,EAAenB,EAAa,GACvE9tD,EAAGmkC,eAAespB,EAAM,EAAGA,EAAKjtD,OAAQuY,KAziQ/B,CAAA,IAAA,iBA4iQb,MAAA,SAAetY,EAAGulD,GACRhmD,IACA4iB,EADK,KACKjN,QACVsW,EAFK,KAEKhC,YACVqjC,EAHK,KAGcE,oBACpBxH,OAAAA,GAASpjC,EAAKnL,UAAU43C,gBAAmB,KAAKjwD,MAAM2sD,kBAAkBtrD,IAA0B,OAApBwrB,EAAKoR,QAAQ58B,GACrF,EALA,KAOD6uD,uBAAuBrjC,EAAKoR,QAAQ58B,GAAK6sD,EAAgB5yC,MApjQ1D,CAAA,IAAA,iBAujQb,MAAA,SAAe+yC,EAAMjvD,EAAOgiC,EAAOznB,GACzB/Y,IAeFS,EAfET,EAAK,KACLgmD,EAAiB,UAATjtC,EACR3Z,EAAQY,EAAGZ,MACX0rB,EAAY1rB,EAAM0rB,UAElBykC,EADOnwD,EAAMuW,QACQ8B,UACrB+3C,GAAW1kC,EAAUnsB,KAAOmsB,EAAUlsB,OAAS,EAC/C6wD,GAAW3kC,EAAUnJ,IAAMmJ,EAAUlJ,QAAU,EAC/C8tC,EAAe1J,GAASuJ,EAAcG,aACtCtC,EAAcsC,EAAe,EAAI1vD,EAAGotD,YACpCC,EAAcqC,EAAe,EAAI1vD,EAAGqtD,YACpC1C,EAAY3qD,EAAGwiC,0BAA0BhkC,EAAOua,GAChDyqB,EAAgBxjC,EAAG2jC,iBAAiBgnB,GACpCC,EAAiB5qD,EAAG4qD,eAAe7xC,EAAMyqB,GAC3C4qB,EAAapuD,EAAGutD,eAEf9sD,IAAAA,EAAI,EAAGA,EAAIjC,IAASiC,EACrB2tD,GAAcpuD,EAAG2vD,eAAelvD,EAAGulD,GAElCvlD,IAAAA,EAAIjC,EAAOiC,EAAIjC,EAAQgiC,IAAS//B,EAAG,CAC9B6sD,IAAAA,EAAgBttD,EAAG2vD,eAAelvD,EAAGulD,GACrCplC,EAAM6sC,EAAKhtD,GACXq5B,EAAa,CACfr0B,EAAG+pD,EAAUxvD,EAAGwnB,QAChBvL,EAAGwzC,EAAUzvD,EAAGynB,QAChB2mC,WAAAA,EACAC,SAAUD,EAAad,EACvBA,cAAAA,EACAD,YAAAA,EACAD,YAAAA,GAEAxC,IACA9wB,EAAWnkB,QAAU6tB,GAAiBxjC,EAAGwiC,0BAA0B/hC,EAAGsY,IAE1Eq1C,GAAcd,EACdttD,EAAGmrD,cAAcvqC,EAAKngB,EAAGq5B,EAAY/gB,GAEzC/Y,EAAG6qD,oBAAoBrnB,EAAezqB,EAAM4xC,KA7lQnC,CAAA,IAAA,iBAgmQb,MAAA,WACU1+B,IAGFxrB,EAHEwrB,EAAO,KAAKhC,YACZ2lC,EAAW3jC,EAAK5N,KAClBgT,EAAQ,EAEP5wB,IAAAA,EAAI,EAAGA,EAAImvD,EAASpvD,OAAQC,IAAK,CAC5BsS,IAAAA,EAAQkZ,EAAKoR,QAAQ58B,GACb,OAAVsS,IAAmBgJ,MAAMhJ,IAAU,KAAK3T,MAAM2sD,kBAAkBtrD,KAChE4wB,GAASvxB,KAAKqc,IAAIpJ,IAGnBse,OAAAA,IA3mQE,CAAA,IAAA,yBA8mQb,MAAA,SAAuBte,GACbse,IAAAA,EAAQ,KAAKpH,YAAYoH,MAC3BA,OAAAA,EAAQ,IAAMtV,MAAMhJ,GACb2H,IAAO5a,KAAKqc,IAAIpJ,GAASse,GAE7B,IAnnQE,CAAA,IAAA,mBAsnQb,MAAA,SAAiBpc,GACPjV,IACAisB,EADK,KACKhC,YACV7qB,EAFK,KAEMA,MACX0hC,EAAS1hC,EAAMif,KAAKyiB,QAAU,GAC9B/tB,EAAQ4xB,GAAa1Y,EAAKoR,QAAQpoB,GAAQ7V,EAAMuW,QAAQkvB,QACvD,MAAA,CACH3C,MAAOpB,EAAO7rB,IAAU,GACxBlC,MAAAA,KA9nQK,CAAA,IAAA,oBAkoQb,MAAA,SAAkB06C,GACRztD,IAGFS,EAAGoU,EAAMoX,EAAMnC,EAAYnU,EAF3B9T,EAAM,EACJzC,EAFK,KAEMA,MAEb,IAACquD,EACIhtD,IAAAA,EAAI,EAAGoU,EAAOzV,EAAMif,KAAKzG,SAASpX,OAAQC,EAAIoU,IAAQpU,EACnDrB,GAAAA,EAAMsmD,iBAAiBjlD,GAAI,CAE3BgtD,GADAxhC,EAAO7sB,EAAM+sB,eAAe1rB,IAChB4d,MACZyL,EAAamC,EAAKnC,cATnB,MAWKA,EAAWoG,YAEf,MAIR,IAACu9B,EACM,OAAA,EAENhtD,IAAAA,EAAI,EAAGoU,EAAO44C,EAAKjtD,OAAQC,EAAIoU,IAAQpU,EAEZ,WAD5BkV,EAAUmU,EAAW0Y,0BAA0B/hC,IACnCovD,cACRhuD,EAAM/B,KAAK+B,IAAIA,EAAK8T,EAAQ0L,aAAe,EAAG1L,EAAQm6C,kBAAoB,IAG3EjuD,OAAAA,IA7pQE,CAAA,IAAA,eAgqQb,MAAA,SAAa4rD,GAEJ,IADD5rD,IAAAA,EAAM,EACDpB,EAAI,EAAGoU,EAAO44C,EAAKjtD,OAAQC,EAAIoU,IAAQpU,EAAG,CACzCkV,IAAAA,EAAU,KAAK6sB,0BAA0B/hC,GAC/CoB,EAAM/B,KAAK+B,IAAIA,EAAK8T,EAAQ6wB,QAAU,EAAG7wB,EAAQo6C,aAAe,GAE7DluD,OAAAA,IAtqQE,CAAA,IAAA,uBAyqQb,MAAA,SAAqBmT,GAEZ,IADDg7C,IAAAA,EAAmB,EACdvvD,EAAI,EAAGA,EAAIuU,IAAgBvU,EAC5B,KAAKrB,MAAMsmD,iBAAiBjlD,KAC5BuvD,GAAoB,KAAKjC,eAAettD,IAGzCuvD,OAAAA,IAhrQE,CAAA,IAAA,iBAmrQb,MAAA,SAAeh7C,GACJlV,OAAAA,KAAK+B,IAAIoS,GAAe,KAAK7U,MAAMif,KAAKzG,SAAS5C,GAAc5C,OAAQ,GAAI,KAprQzE,CAAA,IAAA,gCAurQb,MAAA,WACW,OAAA,KAAKg9C,qBAAqB,KAAKhwD,MAAMif,KAAKzG,SAASpX,SAAW,MAxrQ5D,EAAA,GA4rQjB2sD,GAAmB55C,GAAK,WACxB45C,GAAmB51C,SAAW,CAC1BwoB,oBAAoB,EACpB+C,gBAAiB,MACjBrrB,UAAW,CACP43C,eAAe,EACfK,cAAc,GAElBx1B,WAAY,CACRH,QAAS,CACLx6B,KAAM,SACNu6B,WAAY,CAAC,gBAAiB,WAAY,cAAe,cAAe,aAAc,IAAK,IAAK,SAAU,iBAGlH+zB,OAAQ,MACRvtC,SAAU,EACVgtC,cAAe,IACf/sC,OAAQ,OACR1H,UAAW,KAEfs0C,GAAmBr2C,UAAY,CAC3BoR,YAAa,EACb7O,QAAS,CACL42C,OAAQ,CACJnvB,OAAQ,CACJovB,eAAe9wD,SAAAA,GACLif,IAAAA,EAAOjf,EAAMif,KACfA,OAAAA,EAAKyiB,OAAOtgC,QAAU6d,EAAKzG,SAASpX,OAC7B6d,EAAKyiB,OAAO7+B,IAAI,SAACigC,EAAOzhC,GACrBwrB,IACA3T,EADOlZ,EAAM+sB,eAAe,GACfrC,WAAWxD,SAAS7lB,GAChC,MAAA,CACHkiB,KAAMuf,EACNhf,UAAW5K,EAAMZ,gBACjB2L,YAAa/K,EAAMX,YACnB2L,UAAWhL,EAAM+I,YACjB4lC,QAAS7nD,EAAM2sD,kBAAkBtrD,GACjCwU,MAAOxU,KAIZ,KAGf0Y,QAAQvW,SAAAA,EAAGutD,EAAYF,GACnBA,EAAO7wD,MAAMgxD,qBAAqBD,EAAWl7C,OAC7Cg7C,EAAO7wD,MAAMmwB,WAGrB29B,QAAS,CACL1tD,UAAW,CACPqpC,MAAQ,WACG,MAAA,IAEX3G,MAAMmuB,SAAAA,GACEC,IAAAA,EAAYD,EAAYnuB,MACtBnvB,EAAQ,KAAOs9C,EAAYE,eAO1BD,OANH1rD,GAAQ0rD,IACRA,EAAYA,EAAU3yD,SACZ,IAAMoV,EAEhBu9C,GAAav9C,EAEVu9C,OAOrBE,IAAAA,GAlwQW,SAAA,GAAA,EAAA,EAkwQY9yB,IAlwQZ,IAAA,EAAA,EAAA,GAAA,SAAA,IAAA,OAAA,EAAA,KAAA,GAAA,EAAA,MAAA,KAAA,WAAA,OAAA,EAAA,EAAA,CAAA,CAAA,IAAA,aAmwQb,MAAA,WACSU,KAAAA,qBAAsB,EAC3B,EAAA,EAAA,EAAA,WAAA,aAAA,MAAA,KAAA,QArwQS,CAAA,IAAA,SAwwQb,MAAA,SAAOrlB,GACG/Y,IAAAA,EAAK,KACLisB,EAAOjsB,EAAGiqB,YACApH,EAAqCoJ,EAA9CC,QAA8CD,EAAAA,EAA/B5N,KAAM04B,OAAS,IAAA,EAAA,GAH5B,EAGgCsO,EAAYp5B,EAAZo5B,SACnCoL,EAAqBzwD,EAAGZ,MAAMqkC,oBACfitB,EA0FpBA,SAAgCzkC,EAAM8qB,EAAQ0Z,GAC7CE,IAAAA,EAAa5Z,EAAOv2C,OACtBhC,EAAQ,EACRgiC,EAAQmwB,EACR1kC,GAAAA,EAAKlC,QAAS,CACPC,IAAAA,EAAmBiC,EAAnBjC,OAAQqT,EAAWpR,EAAXoR,QACTxT,EAAOG,EAAOH,KACuBG,EAAAA,EAAO0X,gBAA3C3hC,EAAAA,EAAAA,IAAK8B,EAAAA,EAAAA,IAAK8/B,EAAAA,EAAAA,WAAYC,EAAAA,EAAAA,WACzBD,IACAnjC,EAAQyf,GAAYne,KAAKC,IACrB0kB,GAAa4Y,EAASrT,EAAOH,KAAM9pB,GAAKykB,GACxCisC,EAAqBE,EAAalsC,GAAasyB,EAAQltB,EAAMG,EAAOmmB,iBAAiBpwC,IAAMykB,IAC3F,EAAGmsC,EAAa,IAGpBnwB,EADAoB,EACQ3jB,GAAYne,KAAK+B,IACrB4iB,GAAa4Y,EAASrT,EAAOH,KAAMhoB,GAAKyiB,GAAK,EAC7CmsC,EAAqB,EAAIhsC,GAAasyB,EAAQltB,EAAMG,EAAOmmB,iBAAiBtuC,IAAMyiB,GAAK,GACvF9lB,EAAOmyD,GAAcnyD,EAEjBmyD,EAAanyD,EAGtB,MAAA,CAACA,MAAAA,EAAOgiC,MAAAA,GAjHUkwB,CAAgCzkC,EAAM8qB,EAAQ0Z,GAA9DjyD,EAAAA,EAAAA,MAAOgiC,EAAAA,EAAAA,MASRznB,GARJ/Y,EAAGk+B,WAAa1/B,EAChBwB,EAAGm+B,WAAaqC,EAkHfowB,SAAmB3kC,GACjBqT,IAAAA,EAAgCrT,EAAhCqT,OAAQE,EAAwBvT,EAAxBuT,OAAQqxB,EAAgB5kC,EAAhB4kC,aACjBC,EAAY,CACdC,KAAMzxB,EAAOv/B,IACbixD,KAAM1xB,EAAOz9B,IACbovD,KAAMzxB,EAAOz/B,IACbmxD,KAAM1xB,EAAO39B,KAEb,IAACgvD,EAEM,OADP5kC,EAAK4kC,aAAeC,GACb,EAELxhC,IAAAA,EAAUuhC,EAAaE,OAASzxB,EAAOv/B,KACtC8wD,EAAaG,OAAS1xB,EAAOz9B,KAC7BgvD,EAAaI,OAASzxB,EAAOz/B,KAC7B8wD,EAAaK,OAAS1xB,EAAO39B,IAE7BytB,OADP5e,OAAOW,OAAOw/C,EAAcC,GACrBxhC,EAlICshC,CAAmB3kC,KACnBztB,EAAQ,EACRgiC,EAAQuW,EAAOv2C,QAEnBqiB,EAAKsuC,aAAe9L,EAAS8L,WAC7BtuC,EAAKk0B,OAASA,EACD,WAATh+B,EAAmB,CACbpD,IAAAA,EAAU3V,EAAGuiC,6BAA6BxpB,GAC3C/Y,EAAG2V,QAAQ8D,WACZ9D,EAAQ0L,YAAc,GAE1BrhB,EAAGmrD,cAActoC,OAAM1jB,EAAW,CAC9BiyD,UAAWX,EACX96C,QAAAA,GACDoD,GAEP/Y,EAAGmkC,eAAe4S,EAAQv4C,EAAOgiC,EAAOznB,KAhyQ/B,CAAA,IAAA,iBAmyQb,MAAA,SAAeg+B,EAAQv4C,EAAOgiC,EAAOznB,GAW5B,IAVC/Y,IAAAA,EAAK,KACLgmD,EAAiB,UAATjtC,EACqB/Y,EAAAA,EAAGiqB,YAA/BqV,EAAAA,EAAAA,OAAQE,EAAAA,EAAAA,OAAQhB,EAAAA,EAAAA,SACjBmsB,EAAY3qD,EAAGwiC,0BAA0BhkC,EAAOua,GAChDyqB,EAAgBxjC,EAAG2jC,iBAAiBgnB,GACpCC,EAAiB5qD,EAAG4qD,eAAe7xC,EAAMyqB,GACzCqV,EAAW74C,EAAG2V,QAAQkjC,SACtBwY,EAAev1C,GAAS+8B,GAAYA,EAAWhlC,OAAOgH,kBACtDy2C,EAAetxD,EAAGZ,MAAMqkC,qBAAuBuiB,GAAkB,SAATjtC,EAC1Dw4C,EAAa/yD,EAAQ,GAAKwB,EAAGiiC,UAAUzjC,EAAQ,GAC1CiC,EAAIjC,EAAOiC,EAAIjC,EAAQgiC,IAAS//B,EAAG,CAClC+gB,IAAAA,EAAQu1B,EAAOt2C,GACfi8B,EAAS18B,EAAGiiC,UAAUxhC,GACtBq5B,EAAaw3B,EAAe9vC,EAAQ,GACpC/b,EAAIq0B,EAAWr0B,EAAI65B,EAAO6Q,iBAAiBzT,EAAOj3B,EAAGhF,GACrDwb,EAAI6d,EAAW7d,EAAI+pC,EAAQxmB,EAAOgrB,eAAiBhrB,EAAO2Q,iBAAiB3R,EAAWx+B,EAAG67B,WAAW2D,EAAQ9C,EAAQ8B,GAAY9B,EAAOzgB,EAAGxb,GAChJq5B,EAAWnP,KAAO5O,MAAMtW,IAAMsW,MAAME,GACpC6d,EAAWiiB,KAAOt7C,EAAI,GAAMi8B,EAAOj3B,EAAI8rD,EAAW9rD,EAAK4rD,EACnDzG,IACA9wB,EAAWnkB,QAAU6tB,GAAiBxjC,EAAGwiC,0BAA0B/hC,EAAGsY,IAErEu4C,GACDtxD,EAAGmrD,cAAc3pC,EAAO/gB,EAAGq5B,EAAY/gB,GAE3Cw4C,EAAa70B,EAEjB18B,EAAG6qD,oBAAoBrnB,EAAezqB,EAAM4xC,KA9zQnC,CAAA,IAAA,iBAi0Qb,MAAA,WACU3qD,IACAisB,EADK,KACKhC,YACViC,EAAUD,EAAKC,QACfslC,EAAStlC,EAAQvW,SAAWuW,EAAQvW,QAAQ0L,aAAe,EAC3DhD,EAAO4N,EAAK5N,MAAQ,GACtB,IAACA,EAAK7d,OACCgxD,OAAAA,EAELva,IAAAA,EAAa54B,EAAK,GAAGhG,KARhB,KAQwBmqB,0BAA0B,IACvDivB,EAAYpzC,EAAKA,EAAK7d,OAAS,GAAG6X,KAT7B,KASqCmqB,0BAA0BnkB,EAAK7d,OAAS,IACjFV,OAAAA,KAAK+B,IAAI2vD,EAAQva,EAAYwa,GAAa,IA50QxC,CAAA,IAAA,OA+0Qb,MAAA,WACSxnC,KAAAA,YAAYiC,QAAQwlC,oBAAoB,KAAKtyD,MAAM0rB,WACxD,EAAA,EAAA,EAAA,WAAA,OAAA,MAAA,KAAA,UAj1QS,EAAA,GAq1QjB0lC,GAAej9C,GAAK,OACpBi9C,GAAej5C,SAAW,CACtBwoB,mBAAoB,OACpB+C,gBAAiB,QACjBrpB,UAAU,EACVo/B,UAAU,GAEd2X,GAAe15C,UAAY,CACvB0C,OAAQ,CACJszC,QAAS,CACLvtD,KAAM,YAEVwtD,QAAS,CACLxtD,KAAM,YAmDZoyD,IAAAA,GAr5QW,SAAA,GAAA,EAAA,EAq5QiBj0B,IAr5QjB,IAAA,EAAA,EAAA,GAs5QDt+B,SAAAA,EAAAA,EAAO4V,GAAc,IAAA,EAAA,OAAA,EAAA,KAAA,IACvB5V,EAAAA,EAAAA,KAAAA,KAAAA,EAAO4V,IACRo4C,iBAAcjuD,EACdkuD,EAAAA,iBAAcluD,EAHU,EAt5QpB,OAAA,EAAA,EAAA,CAAA,CAAA,IAAA,SA45Qb,MAAA,SAAO4Z,GACG00C,IAAAA,EAAO,KAAKxjC,YAAY5L,KACzBuzC,KAAAA,gBACAztB,KAAAA,eAAespB,EAAM,EAAGA,EAAKjtD,OAAQuY,KA/5QjC,CAAA,IAAA,gBAk6Qb,MAAA,WACU/Y,IAAAA,EAAK,KACLZ,EAAQY,EAAGZ,MACX0rB,EAAY1rB,EAAM0rB,UAClBlI,EAAOxjB,EAAMuW,QACb84B,EAAU3uC,KAAKC,IAAI+qB,EAAUlsB,MAAQksB,EAAUnsB,KAAMmsB,EAAUlJ,OAASkJ,EAAUnJ,KAClF0rC,EAAcvtD,KAAK+B,IAAI4sC,EAAU,EAAG,GAEpCwgB,GAAgB5B,EADFvtD,KAAK+B,IAAI+gB,EAAKivC,iBAAoBxE,EAAc,IAAQzqC,EAAKivC,iBAAoB,EAAG,IACrDzyD,EAAM0yD,yBACzD9xD,EAAGqtD,YAAcA,EAAe4B,EAAejvD,EAAGiV,MAClDjV,EAAGotD,YAAcptD,EAAGqtD,YAAc4B,IA56QzB,CAAA,IAAA,iBA+6Qb,MAAA,SAAexB,EAAMjvD,EAAOgiC,EAAOznB,GACzB/Y,IAWFS,EAXET,EAAK,KACLgmD,EAAiB,UAATjtC,EACR3Z,EAAQY,EAAGZ,MACX8sB,EAAUlsB,EAAG0+B,aAEb6wB,EADOnwD,EAAMuW,QACQ8B,UACrB8B,EAAQvZ,EAAGiqB,YAAYwV,OACvB+vB,EAAUj2C,EAAMw4C,QAChBtC,EAAUl2C,EAAMy4C,QAChBC,EAAoB14C,EAAM24C,cAAc,GAAK,GAAMz3C,GACrD2C,EAAQ60C,EAENE,EAAe,IAAMnyD,EAAGoyD,uBACzB3xD,IAAAA,EAAI,EAAGA,EAAIjC,IAASiC,EACrB2c,GAASpd,EAAGqyD,cAAc5xD,EAAGsY,EAAMo5C,GAElC1xD,IAAAA,EAAIjC,EAAOiC,EAAIjC,EAAQgiC,EAAO//B,IAAK,CAC9BmgB,IAAAA,EAAM6sC,EAAKhtD,GACb2tD,EAAahxC,EACbixC,EAAWjxC,EAAQpd,EAAGqyD,cAAc5xD,EAAGsY,EAAMo5C,GAC7C9E,EAAcjuD,EAAM2sD,kBAAkBtrD,GAAK8Y,EAAM+4C,8BAA8BpmC,EAAQ7N,KAAK5d,IAAM,EACtG2c,EAAQixC,EACJrI,IACIuJ,EAAcG,eACdrC,EAAc,GAEdkC,EAAcF,gBACdjB,EAAaC,EAAW4D,IAG1Bn4B,IAAAA,EAAa,CACfr0B,EAAG+pD,EACHvzC,EAAGwzC,EACHrC,YAAa,EACbC,YAAAA,EACAe,WAAAA,EACAC,SAAAA,EACA14C,QAAS3V,EAAGwiC,0BAA0B/hC,EAAGsY,IAE7C/Y,EAAGmrD,cAAcvqC,EAAKngB,EAAGq5B,EAAY/gB,MAv9QhC,CAAA,IAAA,uBA29Qb,MAAA,WAAuB,IAAA,EAAA,KACbmT,EAAU,KAAKwS,aACfzS,EAAO,KAAKhC,YACduW,EAAQ,EAMLA,OALPvU,EAAK5N,KAAKze,QAAQ,SAACymB,EAASpR,IACnB8G,MAAMmQ,EAAQ7N,KAAKpJ,KAAW,EAAK7V,MAAM2sD,kBAAkB92C,IAC5DurB,MAGDA,IAp+QE,CAAA,IAAA,gBAu+Qb,MAAA,SAAcvrB,EAAO8D,EAAMo5C,GAChB,OAAA,KAAK/yD,MAAM2sD,kBAAkB92C,GAC9BwH,GAAU,KAAK+lB,0BAA0BvtB,EAAO8D,GAAMqE,OAAS+0C,GAC/D,MA1+QG,EAAA,GA8+QjBR,GAAoBp+C,GAAK,YACzBo+C,GAAoBp6C,SAAW,CAC3BurB,gBAAiB,MACjBrrB,UAAW,CACP43C,eAAe,EACfK,cAAc,GAElBx1B,WAAY,CACRH,QAAS,CACLx6B,KAAM,SACNu6B,WAAY,CAAC,IAAK,IAAK,aAAc,WAAY,cAAe,iBAGxEjhB,UAAW,IACXu1C,WAAY,GAEhBuD,GAAoB76C,UAAY,CAC5BoR,YAAa,EACb7O,QAAS,CACL42C,OAAQ,CACJnvB,OAAQ,CACJovB,eAAe9wD,SAAAA,GACLif,IAAAA,EAAOjf,EAAMif,KACfA,OAAAA,EAAKyiB,OAAOtgC,QAAU6d,EAAKzG,SAASpX,OAC7B6d,EAAKyiB,OAAO7+B,IAAI,SAACigC,EAAOzhC,GACrBwrB,IACA3T,EADOlZ,EAAM+sB,eAAe,GACfrC,WAAWxD,SAAS7lB,GAChC,MAAA,CACHkiB,KAAMuf,EACNhf,UAAW5K,EAAMZ,gBACjB2L,YAAa/K,EAAMX,YACnB2L,UAAWhL,EAAM+I,YACjB4lC,QAAS7nD,EAAM2sD,kBAAkBtrD,GACjCwU,MAAOxU,KAIZ,KAGf0Y,QAAQvW,SAAAA,EAAGutD,EAAYF,GACnBA,EAAO7wD,MAAMgxD,qBAAqBD,EAAWl7C,OAC7Cg7C,EAAO7wD,MAAMmwB,WAGrB29B,QAAS,CACL1tD,UAAW,CACPqpC,MAAQ,WACG,MAAA,IAEX3G,MAAMpqB,SAAAA,GACKA,OAAAA,EAAQ1Y,MAAMif,KAAKyiB,OAAOhpB,EAAQ4qB,WAAa,KAAO5qB,EAAQy4C,mBAKrF/2C,OAAQ,CACJnW,EAAG,CACC9D,KAAM,eACNgzD,WAAY,CACRjhC,SAAS,GAEb6W,aAAa,EACbE,KAAM,CACFmqB,UAAU,GAEdC,YAAa,CACTnhC,SAAS,GAEb88B,WAAY,KAKlBsE,IAAAA,GAxjRW,SAAA,GAAA,EAAA,EAwjRWvF,IAxjRX,IAAA,EAAA,EAAA,GAAA,SAAA,IAAA,OAAA,EAAA,KAAA,GAAA,EAAA,MAAA,KAAA,WAAA,OAAA,EAAA,GA2jRjBuF,GAAcn/C,GAAK,MACnBm/C,GAAcn7C,SAAW,CACrBs2C,OAAQ,EACRvtC,SAAU,EACVgtC,cAAe,IACf/sC,OAAQ,QAGNoyC,IAAAA,GAnkRW,SAAA,GAAA,EAAA,EAmkRaj1B,IAnkRb,IAAA,EAAA,EAAA,GAAA,SAAA,IAAA,OAAA,EAAA,KAAA,GAAA,EAAA,MAAA,KAAA,WAAA,OAAA,EAAA,EAAA,CAAA,CAAA,IAAA,mBAokRb,MAAA,SAAiBzoB,GACPjV,IACA48B,EADK,KACO3S,YAAY2S,OACxBF,EAFK,KAEOuF,UAAUhtB,GACrB,MAAA,CACHitB,MAAOtF,EAAOmE,YAAY9rB,GAC1BlC,MAAO,GAAK6pB,EAAOuF,iBAAiBzF,EAAOE,EAAO/S,UA1kR7C,CAAA,IAAA,SA8kRb,MAAA,SAAO9Q,GACG/Y,IAAAA,EAAK,KACLisB,EAAOjsB,EAAGiqB,YACVpH,EAAOoJ,EAAKC,QACZ6qB,EAAS9qB,EAAK5N,MAAQ,GACtByiB,EAAS7U,EAAKjC,OAAO+W,YAEvBhoB,GADJ8J,EAAKk0B,OAASA,EACD,WAATh+B,EAAmB,CACbpD,IAAAA,EAAU3V,EAAGuiC,6BAA6BxpB,GAC3C/Y,EAAG2V,QAAQ8D,WACZ9D,EAAQ0L,YAAc,GAEpByY,IAAAA,EAAa,CACff,OAAO,EACPijB,UAAWlb,EAAOtgC,SAAWu2C,EAAOv2C,OACpCmV,QAAAA,GAEJ3V,EAAGmrD,cAActoC,OAAM1jB,EAAW26B,EAAY/gB,GAElD/Y,EAAGmkC,eAAe4S,EAAQ,EAAGA,EAAOv2C,OAAQuY,KAjmRnC,CAAA,IAAA,iBAomRb,MAAA,SAAeg+B,EAAQv4C,EAAOgiC,EAAOznB,GAK5B,IAJC/Y,IACAksB,EADK,KACQwS,aACbnlB,EAFK,KAEM0Q,YAAYwV,OACvBumB,EAAiB,UAATjtC,EACLtY,EAAIjC,EAAOiC,EAAIjC,EAAQgiC,EAAO//B,IAAK,CAClC+gB,IAAAA,EAAQu1B,EAAOt2C,GACfkV,EANC,KAMY6sB,0BAA0B/hC,EAAGsY,GAC1C65C,EAAgBr5C,EAAMs5C,yBAAyBpyD,EAAGyrB,EAAQ7N,KAAK5d,IAC/DgF,EAAIugD,EAAQzsC,EAAMw4C,QAAUa,EAAcntD,EAC1CwW,EAAI+pC,EAAQzsC,EAAMy4C,QAAUY,EAAc32C,EAC1C6d,EAAa,CACfr0B,EAAAA,EACAwW,EAAAA,EACAmB,MAAOw1C,EAAcx1C,MACrBuN,KAAM5O,MAAMtW,IAAMsW,MAAME,GACxBtG,QAAAA,GAfG,KAiBJw1C,cAAc3pC,EAAO/gB,EAAGq5B,EAAY/gB,QAtnRlC,EAAA,GA2nRjB45C,GAAgBp/C,GAAK,QACrBo/C,GAAgBp7C,SAAW,CACvBwoB,mBAAoB,OACpB+C,gBAAiB,QACjBjqB,UAAW,IACXY,UAAU,EACVxB,SAAU,CACN4K,KAAM,CACFzB,KAAM,WAIlBuxC,GAAgB77C,UAAY,CACxBoR,YAAa,EACb1O,OAAQ,CACJnW,EAAG,CACC9D,KAAM,kBAKZuzD,IAAAA,GAhpRW,SAAA,GAAA,EAAA,EAgpRetC,IAhpRf,IAAA,EAAA,EAAA,GAAA,SAAA,IAAA,OAAA,EAAA,KAAA,GAAA,EAAA,MAAA,KAAA,WAAA,OAAA,EAAA,GAmpRjBsC,GAAkBv/C,GAAK,UACvBu/C,GAAkBv7C,SAAW,CACzBkC,UAAU,EACV2H,MAAM,GAEV0xC,GAAkBh8C,UAAY,CAC1BgC,YAAa,CACTC,KAAM,SAEVM,QAAS,CACL6zC,QAAS,CACL1tD,UAAW,CACPqpC,MAAQ,WACG,MAAA,IAEX3G,MAAMxhC,SAAAA,GACK,MAAA,IAAMA,EAAKwhC,MAAQ,KAAOxhC,EAAK6vD,eAAiB,QAKvE/2C,OAAQ,CACJ/T,EAAG,CACClG,KAAM,UAEV0c,EAAG,CACC1c,KAAM,YAKdi+C,IAAAA,GAA2B9sC,OAAO6gB,OAAO,CACzCmE,UAAW,KACX00B,cAAeA,GACf4C,iBAAkBA,GAClBG,mBAAoBA,GACpBqD,eAAgBA,GAChBmB,oBAAqBA,GACrBe,cAAeA,GACfC,gBAAiBA,GACjBG,kBAAmBA,KAGdC,SAAAA,GAAQr6C,EAAK2N,GACX+nC,IAAAA,EAAqE/nC,EAArE+nC,WAAYC,EAAyDhoC,EAAzDgoC,SAAU2E,EAA+C3sC,EAA/C2sC,YAAavtD,EAAkC4gB,EAAlC5gB,EAAGwW,EAA+BoK,EAA/BpK,EAAGoxC,EAA4BhnC,EAA5BgnC,YAAaD,EAAe/mC,EAAf+mC,YACzD6F,EAAcD,EAAc3F,EAChC30C,EAAIiI,YACJjI,EAAIkI,IAAInb,EAAGwW,EAAGoxC,EAAae,EAAa6E,EAAa5E,EAAW4E,GAC5D7F,EAAc4F,GACdC,EAAcD,EAAc5F,EAC5B10C,EAAIkI,IAAInb,EAAGwW,EAAGmxC,EAAaiB,EAAW4E,EAAa7E,EAAa6E,GAAa,IAE7Ev6C,EAAIkI,IAAInb,EAAGwW,EAAG+2C,EAAa3E,EAAWtzC,GAASqzC,EAAarzC,IAEhErC,EAAImI,YACJnI,EAAIoJ,OAGCoxC,SAAAA,GAAQx6C,EAAK2N,GACX5gB,IAAAA,EAA2C4gB,EAA3C5gB,EAAGwW,EAAwCoK,EAAxCpK,EAAGmyC,EAAqC/nC,EAArC+nC,WAAYC,EAAyBhoC,EAAzBgoC,SAAU2E,EAAe3sC,EAAf2sC,YAC7B3F,EAAcvtD,KAAK+B,IAAIwkB,EAAQgnC,YAAc2F,EAAa,GAC1D5F,EAAc/mC,EAAQ+mC,YAAc4F,EAC1Ct6C,EAAIiI,YACJjI,EAAIkI,IAAInb,EAAGwW,EAAGoxC,EAAae,EAAYC,GACvC31C,EAAIkI,IAAInb,EAAGwW,EAAGmxC,EAAaiB,EAAUD,GAAY,GACjD11C,EAAImI,YA4CCynB,SAAAA,GAAW5vB,EAAK2N,GACd5gB,IAAAA,EAAoD4gB,EAApD5gB,EAAGwW,EAAiDoK,EAAjDpK,EAAGmyC,EAA8C/nC,EAA9C+nC,WAAYC,EAAkChoC,EAAlCgoC,SAAU2E,EAAwB3sC,EAAxB2sC,YAAar9C,EAAW0Q,EAAX1Q,QAC1C03C,EAAchnC,EAAQgnC,YACtBD,EAAc/mC,EAAQ+mC,YAAc4F,EACpCG,EAAgC,UAAxBx9C,EAAQk6C,YACjBl6C,EAAQ0L,cAGT8xC,GACAz6C,EAAI4K,UAAkC,EAAtB3N,EAAQ0L,YACxB3I,EAAI06C,SAAW,UAEf16C,EAAI4K,UAAY3N,EAAQ0L,YACxB3I,EAAI06C,SAAW,SAEf/sC,EAAQgtC,aAzCPC,SAAsB56C,EAAK2N,EAAS8sC,GAClC1tD,IAGHhF,EAHGgF,EAA2C4gB,EAA3C5gB,EAAGwW,EAAwCoK,EAAxCpK,EAAGmyC,EAAqC/nC,EAArC+nC,WAAYC,EAAyBhoC,EAAzBgoC,SAAU2E,EAAe3sC,EAAf2sC,YAC7B3F,EAAcvtD,KAAK+B,IAAIwkB,EAAQgnC,YAAc2F,EAAa,GAC1D5F,EAAc/mC,EAAQ+mC,YAAc4F,EAarCvyD,IAXD0yD,IACA9sC,EAAQgoC,SAAWhoC,EAAQ+nC,WAAa1zC,GACxCq4C,GAAQr6C,EAAK2N,GACbA,EAAQgoC,SAAWA,EACfhoC,EAAQgoC,WAAahoC,EAAQ+nC,aAC7B/nC,EAAQgoC,UAAY3zC,GACpB2L,EAAQgtC,gBAGhB36C,EAAIiI,YACJjI,EAAIkI,IAAInb,EAAGwW,EAAGmxC,EAAagB,EAAa1zC,GAAK0zC,GAAY,GACpD3tD,EAAI,EAAGA,EAAI4lB,EAAQgtC,cAAe5yD,EACnCiY,EAAI4I,SAIH7gB,IAFLiY,EAAIiI,YACJjI,EAAIkI,IAAInb,EAAGwW,EAAGoxC,EAAae,EAAYA,EAAa1zC,IAC/Cja,EAAI,EAAGA,EAAI4lB,EAAQgtC,cAAe5yD,EACnCiY,EAAI4I,SAoBJgyC,CAAsB56C,EAAK2N,EAAS8sC,GAEpCA,GACAJ,GAAQr6C,EAAK2N,GAEjB3N,EAAIiI,YACJjI,EAAIkI,IAAInb,EAAGwW,EAAGoxC,EAAae,EAAYC,GACvC31C,EAAIkI,IAAInb,EAAGwW,EAAGmxC,EAAaiB,EAAUD,GAAY,GACjD11C,EAAImI,YACJnI,EAAI4I,UAGFiyC,IAAAA,GA5xRW,SAAA,GAAA,EAAA,EA4xRQjvB,IA5xRR,IAAA,EAAA,EAAA,GA6xRD7L,SAAAA,EAAAA,GAAK,IAAA,EAAA,OAAA,EAAA,KAAA,IACb,EAAA,EAAA,KAAA,OACK9iB,aAAUxW,EACVmuD,EAAAA,mBAAgBnuD,EAChBivD,EAAAA,gBAAajvD,EACbkvD,EAAAA,cAAWlvD,EACXiuD,EAAAA,iBAAcjuD,EACdkuD,EAAAA,iBAAcluD,EACd6zD,EAAAA,YAAc,EACdK,EAAAA,YAAc,EACf56B,GACA/nB,OAAOW,OAAaonB,EAAAA,GAAAA,GAXX,EA7xRJ,OAAA,EAAA,EAAA,CAAA,CAAA,IAAA,UA4yRb,MAAA,SAAQ+6B,EAAQC,EAAQ5oC,GACdrJ,IACoB1E,EAAAA,GADZ,KAAKynB,SAAS,CAAC,IAAK,KAAM1Z,GACW,CAACplB,EAAG+tD,EAAQv3C,EAAGw3C,IAA3Dr2C,EAAAA,EAAAA,MAAOE,EAAAA,EAAAA,SAC0D,EAAA,KAAKinB,SAAS,CAClF,aACA,WACA,cACA,cACA,iBACD1Z,GANIujC,EAAAA,EAAAA,WAAYC,EAAAA,EAAAA,SAAUjB,EAAAA,EAAAA,YAAaC,EAAAA,EAAAA,YASlCqG,OAT+CpG,EAAAA,eAOhB5yC,IAAOkD,GAAcR,EAAOgxC,EAAYC,MACzD/wC,GAAY8vC,GAAe9vC,GAAY+vC,KAvzRpD,CAAA,IAAA,iBA2zRb,MAAA,SAAexiC,GACoD,IAAA,EAAA,KAAK0Z,SAAS,CACzE,IACA,IACA,aACA,WACA,cACA,eACD1Z,GAPIplB,EAAAA,EAAAA,EAAGwW,EAAAA,EAAAA,EAQJ03C,GAROvF,EAAAA,WAAYC,EAAAA,UAQmB,EACtCuF,GAT6BxG,EAAAA,YAAaC,EAAAA,aASC,EAC1C,MAAA,CACH5nD,EAAGA,EAAI3F,KAAKkhB,IAAI2yC,GAAaC,EAC7B33C,EAAGA,EAAInc,KAAKihB,IAAI4yC,GAAaC,KAx0RxB,CAAA,IAAA,kBA40Rb,MAAA,SAAgB/oC,GACL,OAAA,KAAKa,eAAeb,KA70RlB,CAAA,IAAA,OAg1Rb,MAAA,SAAKnS,GACK1Y,IAAAA,EAAK,KACL2V,EAAU3V,EAAG2V,QACb6wB,EAAS7wB,EAAQ6wB,QAAU,EAG7BxmC,GAFJA,EAAGgzD,YAAuC,UAAxBr9C,EAAQk6C,YAA2B,IAAO,EAC5D7vD,EAAGqzD,YAAcvzD,KAAKyb,MAAMvb,EAAGstD,cAAgB5yC,MACtB,IAArB1a,EAAGstD,eAAuBttD,EAAGotD,YAAc,GAAKptD,EAAGqtD,YAAc,GAAjErtD,CAIAwmC,GADJ9tB,EAAIsG,OACAwnB,GAAUxmC,EAAGstD,cAAgB5yC,GAAK,CAC5Bi5C,IAAAA,GAAa3zD,EAAGouD,WAAapuD,EAAGquD,UAAY,EAClD31C,EAAI+H,UAAU3gB,KAAKkhB,IAAI2yC,GAAantB,EAAQ1mC,KAAKihB,IAAI4yC,GAAantB,GAEtE9tB,EAAIwK,UAAYvN,EAAQ+B,gBACxBgB,EAAI2K,YAAc1N,EAAQgC,YAxIzBk8C,SAAQn7C,EAAK2N,GACdA,GAAAA,EAAQgtC,YAAa,CACrBhtC,EAAQgoC,SAAWhoC,EAAQ+nC,WAAa1zC,GACxCw4C,GAAQx6C,EAAK2N,GACR,IAAA,IAAI5lB,EAAI,EAAGA,EAAI4lB,EAAQgtC,cAAe5yD,EACvCiY,EAAI0I,OAGPrF,MAAMsK,EAAQinC,iBACfjnC,EAAQgoC,SAAWhoC,EAAQ+nC,WAAa/nC,EAAQinC,cAAgB5yC,IAEpEw4C,GAAQx6C,EAAK2N,GACb3N,EAAI0I,OA6HAyyC,CAAQn7C,EAAK1Y,GACbsoC,GAAW5vB,EAAK1Y,GAChB0Y,EAAI0G,eAl2RK,EAAA,GA23RR6B,SAAAA,GAAOvI,EAAKuJ,EAAU7M,GAC3BsD,EAAIuI,OAAO7L,EAAO3P,EAAG2P,EAAO6G,GAavB63C,SAAAA,GAAS/c,EAAQiE,EAAS5sB,GAC/BA,EAASA,GAAU,GACboS,IAAAA,EAAQuW,EAAOv2C,OACfhC,EAAQsB,KAAK+B,IAAIusB,EAAO5vB,OAAS,EAAGw8C,EAAQx8C,OAC5CC,EAAMqB,KAAKC,IAAIquB,EAAO3vB,KAAO+hC,EAAQ,EAAGwa,EAAQv8C,KAC/C,MAAA,CACH+hC,MAAAA,EACAhiC,MAAAA,EACAw6B,KAAMgiB,EAAQhiB,KACdnkB,KAAMpW,EAAMD,EAAQgiC,EAAQ/hC,EAAMD,EAAQC,EAAMD,GAI/Cu1D,SAAAA,GAAYr7C,EAAKmK,EAAMm4B,EAAS5sB,GAC9B2oB,IAIHt2C,EAAG+gB,EAAOkf,EAJPqW,EAAmBl0B,EAAnBk0B,OAAQphC,EAAWkN,EAAXlN,QACoBm+C,EAAAA,GAAS/c,EAAQiE,EAAS5sB,GAAtDoS,EAAAA,EAAAA,MAAOhiC,EAAAA,EAAAA,MAAOw6B,EAAAA,EAAAA,KAAMnkB,EAAAA,EAAAA,KACrBm/C,EA1BDC,SAAct+C,GACfA,OAAAA,EAAQu+C,QACDlyC,GAEPrM,EAAQojC,QACD32B,GAEJnB,GAmBYgzC,CAAct+C,GACJyY,EAAAA,GAAU,GAAlC6V,EAAAA,EAAAA,KAAAA,OAAO,IAAA,GAJiC,EAI3BxvB,EAAAA,EAAAA,QAEbhU,IAAAA,EAAI,EAAGA,GAAKoU,IAAQpU,GACrB+gB,EAAQu1B,GAAQv4C,GAASiW,EAAUI,EAAOpU,EAAIA,IAAM+/B,IAC1C7V,OAECsZ,GACPvrB,EAAIoI,OAAOU,EAAM/b,EAAG+b,EAAMvF,GAC1BgoB,GAAO,GAEP+vB,EAAWt7C,EAAKgoB,EAAMlf,EAAO/M,EAASkB,EAAQu+C,SAElDxzB,EAAOlf,GAMJ,OAJHwX,GAEAg7B,EAAWt7C,EAAKgoB,EADhBlf,EAAQu1B,GAAQv4C,GAASiW,EAAUI,EAAO,IAAM2rB,GACnB/rB,EAASkB,EAAQu+C,WAEzCl7B,EAGJm7B,SAAAA,GAAgBz7C,EAAKmK,EAAMm4B,EAAS5sB,GACnC2oB,IAKFt2C,EAAG+gB,EAAO4yC,EAAOrF,EAAMF,EAAMwF,EAL3Btd,EAASl0B,EAAKk0B,OACS+c,EAAAA,GAAS/c,EAAQiE,EAAS5sB,GAAhDoS,EAAAA,EAAAA,MAAOhiC,EAAAA,EAAAA,MAAOqW,EAAAA,EAAAA,KACUuZ,EAAAA,GAAU,GAAlC6V,EAAAA,EAAAA,KAAAA,OAAO,IAAA,GAHmC,EAG7BxvB,EAAAA,EAAAA,QAChB6/C,EAAO,EACPC,EAAS,EAEPC,EAAa,SAACv/C,GAAU,OAACzW,GAASiW,EAAUI,EAAOI,EAAQA,IAAUurB,GACrEi0B,EAAQ,WACN1F,IAASF,IACTn2C,EAAIuI,OAAOqzC,EAAMzF,GACjBn2C,EAAIuI,OAAOqzC,EAAMvF,GACjBr2C,EAAIuI,OAAOqzC,EAAMD,KAOpB5zD,IAJDwjC,IACAziB,EAAQu1B,EAAOyd,EAAW,IAC1B97C,EAAIoI,OAAOU,EAAM/b,EAAG+b,EAAMvF,IAEzBxb,EAAI,EAAGA,GAAKoU,IAAQpU,EAEjB+gB,KADJA,EAAQu1B,EAAOyd,EAAW/zD,KAChBkqB,KAANnJ,CAGE/b,IAAAA,EAAI+b,EAAM/b,EACVwW,EAAIuF,EAAMvF,EACVy4C,EAAa,EAAJjvD,EACXivD,IAAWN,GACPn4C,EAAI8yC,EACJA,EAAO9yC,EACAA,EAAI4yC,IACXA,EAAO5yC,GAEXq4C,GAAQC,EAASD,EAAO7uD,KAAO8uD,IAE/BE,IACA/7C,EAAIuI,OAAOxb,EAAGwW,GACdm4C,EAAQM,EACRH,EAAS,EACTxF,EAAOF,EAAO5yC,GAElBo4C,EAAQp4C,EAEZw4C,IAGKE,SAAAA,GAAkB9xC,GACjBD,IAAAA,EAAOC,EAAKlN,QACZgzB,EAAa/lB,EAAK+lB,YAAc/lB,EAAK+lB,WAAWnoC,OAE/Co0D,QADc/xC,EAAKsuC,YAAetuC,EAAKkW,OAAUnW,EAAKm2B,SAAYn2B,EAAKsxC,SAAYvrB,GACrEwrB,GAAkBJ,GA3H3CR,GAAWhgD,GAAK,MAChBggD,GAAWh8C,SAAW,CAClBs4C,YAAa,SACbl4C,YAAa,OACb0J,YAAa,EACbmlB,OAAQ,EACRppB,WAAOje,GAEXo0D,GAAW9uB,cAAgB,CACvB/sB,gBAAiB,mBAkJfm9C,IACAC,GAD8B,mBAAXC,OAnBhBC,SAAoBt8C,EAAKmK,EAAMrkB,EAAOgiC,GACvCy0B,IAAAA,EAAOpyC,EAAKqyC,MACXD,IACDA,EAAOpyC,EAAKqyC,MAAQ,IAAIH,OACpBlyC,EAAKoyC,KAAKA,EAAMz2D,EAAOgiC,IACvBy0B,EAAKp0C,aAGbnI,EAAI4I,OAAO2zC,IAGNE,SAAiBz8C,EAAKmK,EAAMrkB,EAAOgiC,GACxC9nB,EAAIiI,YACAkC,EAAKoyC,KAAKv8C,EAAKla,EAAOgiC,IACtB9nB,EAAImI,YAERnI,EAAI4I,UAMF8zC,GApgSW,SAAA,GAAA,EAAA,EAogSS9wB,IApgST,IAAA,EAAA,EAAA,GAqgSD7L,SAAAA,EAAAA,GAAK,IAAA,EAAA,OAAA,EAAA,KAAA,IACb,EAAA,EAAA,KAAA,OACK24B,UAAW,EACXz7C,EAAAA,aAAUxW,EACV45B,EAAAA,WAAQ55B,EACR68C,EAAAA,eAAY78C,EACZ+1D,EAAAA,WAAQ/1D,EACRk2D,EAAAA,aAAUl2D,EACVm2D,EAAAA,eAAYn2D,EACZgyD,EAAAA,YAAa,EACboE,EAAAA,gBAAiB,EAClB98B,GACA/nB,OAAOW,OAAaonB,EAAAA,GAAAA,GAZX,EArgSJ,OAAA,EAAA,EAAA,CAAA,CAAA,IAAA,sBAqhSb,MAAA,SAAoB3N,GACV9qB,IAAAA,EAAK,KACL2V,EAAU3V,EAAG2V,QACfA,GAAAA,EAAQojC,UAAYpjC,EAAQu+C,UAAYl0D,EAAGu1D,eAAgB,CACrDv8B,IAAAA,EAAOrjB,EAAQkjC,SAAW74C,EAAG+4B,MAAQ/4B,EAAGg8C,UAC9CrD,GAA2B34C,EAAGq1D,QAAS1/C,EAASmV,EAAWkO,GAC3Dh5B,EAAGu1D,gBAAiB,KA3hSf,CAAA,IAAA,SAuiSb,IAAA,WACW,OAAA,KAAKF,SAThB,IAAA,SAAWte,GACI,KACRse,QAAUte,SADF,KAEDue,iBAFC,KAGDJ,MAHC,KAIRK,gBAAiB,IApiSX,CAAA,IAAA,WA2iSb,IAAA,WACW,OAAA,KAAKD,YAAc,KAAKA,UAAY1Z,GAAiB,SA5iSnD,CAAA,IAAA,QA+iSb,MAAA,WACUF,IAAAA,EAAW,KAAKA,SAChB3E,EAAS,KAAKA,OACb2E,OAAAA,EAASl7C,QAAUu2C,EAAO2E,EAAS,GAAGl9C,SAljSpC,CAAA,IAAA,OAqjSb,MAAA,WACUk9C,IAAAA,EAAW,KAAKA,SAChB3E,EAAS,KAAKA,OACdvW,EAAQkb,EAASl7C,OAChBggC,OAAAA,GAASuW,EAAO2E,EAASlb,EAAQ,GAAG/hC,OAzjSlC,CAAA,IAAA,cA4jSb,MAAA,SAAY+iB,EAAOhF,GACTxc,IACA2V,EADK,KACQA,QACb5C,EAAQyO,EAAMhF,GACdu6B,EAHK,KAGOA,OACZ2E,EAAWD,GAJN,KAIyB,CAACj/B,SAAAA,EAAUhe,MAAOuU,EAAOtU,IAAKsU,IAC9D,GAAC2oC,EAASl7C,OAAV,CAGEmb,IAEFlb,EAAGoU,EAFD8G,EAAS,GACT65C,EAlGLC,SAAwB9/C,GACzBA,OAAAA,EAAQu+C,QACD7a,GAEP1jC,EAAQojC,QACDO,GAEJF,GA2FkBqc,CAAwB9/C,GAExClV,IAAAA,EAAI,EAAGoU,EAAO6mC,EAASl7C,OAAQC,EAAIoU,IAAQpU,EAAG,CAC1Bi7C,IAAAA,EAAAA,EAASj7C,GAAvBjC,EAAAA,EAAAA,MAAOC,EAAAA,EAAAA,IACR0G,EAAK4xC,EAAOv4C,GACZ4G,EAAK2xC,EAAOt4C,GACd0G,GAAAA,IAAOC,EAAPD,CAIEywB,IACA8/B,EAAeF,EAAarwD,EAAIC,EAD5BtF,KAAKqc,KAAKpJ,EAAQ5N,EAAGqX,KAAcpX,EAAGoX,GAAYrX,EAAGqX,KAClB7G,EAAQu+C,SACrDwB,EAAal5C,GAAYgF,EAAMhF,GAC/Bb,EAAOla,KAAKi0D,QANR/5C,EAAOla,KAAK0D,GAQbwW,OAAkB,IAAlBA,EAAOnb,OAAemb,EAAO,GAAKA,KArlShC,CAAA,IAAA,cAwlSb,MAAA,SAAYjD,EAAKsiC,EAAS5sB,GAEfunC,OADehB,GAAkB,KACjCgB,CAAcj9C,EAAK,KAAMsiC,EAAS5sB,KA1lShC,CAAA,IAAA,OA6lSb,MAAA,SAAK1V,EAAKla,EAAOgiC,GACPxgC,IAAAA,EAAK,KACL07C,EAAW17C,EAAG07C,SACd7mC,EAAO6mC,EAASl7C,OAChBm1D,EAAgBhB,GAAkB30D,GACpCg5B,EAAOh5B,EAAG+4B,MACdv6B,EAAQA,GAAS,EACjBgiC,EAAQA,GAAUxgC,EAAG+2C,OAAOv2C,OAAShC,EAChC,IAAA,IAAIiC,EAAI,EAAGA,EAAIoU,IAAQpU,EACxBu4B,GAAQ28B,EAAcj9C,EAAK1Y,EAAI07C,EAASj7C,GAAI,CAACjC,MAAAA,EAAOC,IAAKD,EAAQgiC,EAAQ,IAEtE,QAAExH,IAxmSA,CAAA,IAAA,OA2mSb,MAAA,SAAKtgB,EAAKoS,EAAWtsB,EAAOgiC,GAClBxgC,IAAAA,EAAK,KACL2V,EAAU3V,EAAG2V,SAAW,IACf3V,EAAG+2C,QAAU,IAChBv2C,QAAWmV,EAAQ0L,cAG/B3I,EAAIsG,OAhQH42C,SAASl9C,EAAKm9C,GACnBn9C,EAAIo9C,QAAUD,EAAGE,eACjBr9C,EAAI+5B,YAAYojB,EAAGltB,YACnBjwB,EAAIg6B,eAAiBmjB,EAAGjtB,iBACxBlwB,EAAI06C,SAAWyC,EAAGG,gBAClBt9C,EAAI4K,UAAYuyC,EAAGx0C,YACnB3I,EAAI2K,YAAcwyC,EAAGl+C,YA2PjBi+C,CAASl9C,EAAK/C,GACdm/C,GAAWp8C,EAAK1Y,EAAIxB,EAAOgiC,GAC3B9nB,EAAI0G,UACApf,EAAGoxD,WACHpxD,EAAGu1D,gBAAiB,EACpBv1D,EAAGk1D,WAAQ/1D,QAxnSN,EAAA,GAopSR82D,SAAAA,GAAU1vC,EAAI9P,EAAKoT,EAAMgB,GACxBlV,IAAAA,EAAU4Q,EAAG5Q,QACJ5C,EAASwT,EAAGge,SAAS,CAAC1a,GAAOgB,GAApChB,GACA/pB,OAAAA,KAAKqc,IAAI1F,EAAM1D,GAAS4C,EAAQ4K,OAAS5K,EAAQugD,UA1B7Dd,GAAY7hD,GAAK,OACjB6hD,GAAY79C,SAAW,CACnBw+C,eAAgB,OAChBptB,WAAY,GACZC,iBAAkB,EAClBotB,gBAAiB,QACjB30C,YAAa,EACb23B,iBAAiB,EACjBF,uBAAwB,UACxB13B,MAAM,EACNy3B,UAAU,EACVqb,SAAS,EACTnb,QAAS,GAEbqc,GAAY3wB,cAAgB,CACxB/sB,gBAAiB,kBACjBC,YAAa,eAEjBy9C,GAAYr+C,YAAc,CACtBsD,aAAa,EACbE,WAAY,SAACZ,GAASA,MAAS,eAATA,GAAkC,SAATA,IAS7Cw8C,IAAAA,GA1pSW,SAAA,GAAA,EAAA,EA0pSU7xB,IA1pSV,IAAA,EAAA,EAAA,GA2pSD7L,SAAAA,EAAAA,GAAK,IAAA,EAAA,OAAA,EAAA,KAAA,IACb,EAAA,EAAA,KAAA,OACK9iB,aAAUxW,EACVwrB,EAAAA,UAAOxrB,EACP48C,EAAAA,UAAO58C,EACRs5B,GACA/nB,OAAOW,OAAaonB,EAAAA,GAAAA,GANX,EA3pSJ,OAAA,EAAA,EAAA,CAAA,CAAA,IAAA,UAqqSb,MAAA,SAAQ29B,EAAQC,EAAQxrC,GACdlV,IAAAA,EAAU,KAAKA,QACN,EAAA,KAAK4uB,SAAS,CAAC,IAAK,KAAM1Z,GAAlCplB,EAAAA,EAAAA,EAAGwW,EAAAA,EAAAA,EACDnc,OAAAA,KAAKwb,IAAI86C,EAAS3wD,EAAG,GAAK3F,KAAKwb,IAAI+6C,EAASp6C,EAAG,GAAMnc,KAAKwb,IAAI3F,EAAQugD,UAAYvgD,EAAQ4K,OAAQ,KAxqSlG,CAAA,IAAA,WA2qSb,MAAA,SAAS61C,EAAQvrC,GACNorC,OAAAA,GAAU,KAAMG,EAAQ,IAAKvrC,KA5qS3B,CAAA,IAAA,WA+qSb,MAAA,SAASwrC,EAAQxrC,GACNorC,OAAAA,GAAU,KAAMI,EAAQ,IAAKxrC,KAhrS3B,CAAA,IAAA,iBAmrSb,MAAA,SAAeA,GACI,IAAA,EAAA,KAAK0Z,SAAS,CAAC,IAAK,KAAM1Z,GAClC,MAAA,CAACplB,EADDA,EAAAA,EACIwW,EADDA,EAAAA,KAprSD,CAAA,IAAA,OAwrSb,MAAA,SAAKtG,GAEG4K,IAAAA,GADJ5K,EAAUA,GAAW,KAAKA,SAAW,IAChB4K,QAAU,EAGxB,OAAyB,IAFhCA,EAASzgB,KAAK+B,IAAI0e,EAAQA,GAAU5K,EAAQ2gD,aAAe,KACvC/1C,GAAU5K,EAAQ0L,aAAe,MA5rS5C,CAAA,IAAA,OAgsSb,MAAA,SAAK3I,GACK1Y,IACA2V,EADK,KACQA,QADR,KAEJgV,MAAQhV,EAAQ4K,OAAS,KAGhC7H,EAAI2K,YAAc1N,EAAQgC,YAC1Be,EAAI4K,UAAY3N,EAAQ0L,YACxB3I,EAAIwK,UAAYvN,EAAQ+B,gBACxBuI,GAAUvH,EAAK/C,EARJ,KAQgBlQ,EARhB,KAQsBwW,MAzsSxB,CAAA,IAAA,WA4sSb,MAAA,WACUtG,IAAAA,EAAU,KAAKA,SAAW,GACzBA,OAAAA,EAAQ4K,OAAS5K,EAAQugD,cA9sSvB,EAAA,GAiuSRK,SAAAA,GAAaC,EAAK3rC,GACa2rC,IAChC73D,EAAMC,EAAO+iB,EAAKC,EAAQ60C,EADMD,EAAAA,EAAIjyB,SAAS,CAAC,IAAK,IAAK,OAAQ,QAAS,UAAW1Z,GAAjFplB,EAAAA,EAAAA,EAAGwW,EAAAA,EAAAA,EAAGkJ,EAAAA,EAAAA,KAAMxG,EAAAA,EAAAA,MAAOqB,EAAAA,EAAAA,OAenB,OAbHw2C,EAAIhoC,YACJioC,EAAOz2C,EAAS,EAChBrhB,EAAOmB,KAAKC,IAAI0F,EAAG0f,GACnBvmB,EAAQkB,KAAK+B,IAAI4D,EAAG0f,GACpBxD,EAAM1F,EAAIw6C,EACV70C,EAAS3F,EAAIw6C,IAGb93D,EAAO8G,GADPgxD,EAAO93C,EAAQ,GAEf/f,EAAQ6G,EAAIgxD,EACZ90C,EAAM7hB,KAAKC,IAAIkc,EAAGkJ,GAClBvD,EAAS9hB,KAAK+B,IAAIoa,EAAGkJ,IAElB,CAACxmB,KAAAA,EAAMgjB,IAAAA,EAAK/iB,MAAAA,EAAOgjB,OAAAA,GAGrB80C,SAAAA,GAAmBF,GACpB9sB,IAAAA,EAAO8sB,EAAI7gD,QAAQghD,cACjBvxC,EAAM,GACR,OAACskB,GAMLtkB,EAHAskB,EAAO8sB,EAAIhoC,WACLooC,GAAUltB,EAAM,OAAQ,QAAS8sB,EAAIrxC,KAAOqxC,EAAI/wD,GAChDmxD,GAAUltB,EAAM,SAAU,MAAO8sB,EAAIrxC,KAAOqxC,EAAIv6C,KAC1C,EACLmJ,GANIA,EASNwxC,SAAAA,GAAUltB,EAAMlnC,EAAGC,EAAGgS,GAUtBoiD,IAAKC,EAAM/hD,EAAIgiD,EAHbrtB,OANHj1B,GASgBsiD,EARKt0D,EACrBinC,EAAOstB,GADPttB,GAQMotB,EARMptB,MAQA30B,EARMvS,GASDu0D,EAAKD,IAASC,EAAKhiD,EAAK+hD,EARnBr0D,EAAGD,IAEzBknC,EAAOstB,GAASttB,EAAMlnC,EAAGC,GAEtBinC,EAOFstB,SAAAA,GAAS7zD,EAAG3E,EAAOC,GACjB0E,MAAM,UAANA,EAAgB3E,EAAc,QAAN2E,EAAc1E,EAAM0E,EAG9C8zD,SAAAA,GAAYtsC,EAAM5X,EAAOhT,EAAK8B,GAC5B8oB,OAAAA,EAAO,EAAI7qB,KAAK+B,IAAI/B,KAAKC,IAAIgT,EAAOlR,GAAM9B,GA4B5Cm3D,SAAAA,GAAcV,GACbpuB,IAAAA,EAASmuB,GAAaC,GACtB73C,EAAQypB,EAAOxpC,MAAQwpC,EAAOzpC,KAC9BqhB,EAASooB,EAAOxmB,OAASwmB,EAAOzmB,IAChC6vC,EA7BD2F,SAAiBX,EAAKY,EAAMC,GAC3BtkD,IAAAA,EAAQyjD,EAAI7gD,QAAQ0L,YACpBsJ,EAAO+rC,GAAmBF,GAC1Bc,EAAIxqC,GAAO/Z,GACV,MAAA,CACH6iB,EAAGqhC,GAAYtsC,EAAKhJ,IAAK21C,EAAE31C,IAAK,EAAG01C,GACnCh0D,EAAG4zD,GAAYtsC,EAAK/rB,MAAO04D,EAAE14D,MAAO,EAAGw4D,GACvC30D,EAAGw0D,GAAYtsC,EAAK/I,OAAQ01C,EAAE11C,OAAQ,EAAGy1C,GACzC5zD,EAAGwzD,GAAYtsC,EAAKhsB,KAAM24D,EAAE34D,KAAM,EAAGy4D,IAqB1BD,CAAiBX,EAAK73C,EAAQ,EAAGqB,EAAS,GACnDO,EAlBDg3C,SAAkBf,EAAKY,EAAMC,GAC5BtkD,IACAukD,EAAIvqC,GADIypC,EAAI7gD,QAAQ6hD,cAEpBC,EAAO33D,KAAKC,IAAIq3D,EAAMC,GACtB1sC,EAAO+rC,GAAmBF,GACzB,MAAA,CACHkB,QAAST,GAAYtsC,EAAKhJ,KAAOgJ,EAAKhsB,KAAM24D,EAAEI,QAAS,EAAGD,GAC1DE,SAAUV,GAAYtsC,EAAKhJ,KAAOgJ,EAAK/rB,MAAO04D,EAAEK,SAAU,EAAGF,GAC7DG,WAAYX,GAAYtsC,EAAK/I,QAAU+I,EAAKhsB,KAAM24D,EAAEM,WAAY,EAAGH,GACnEI,YAAaZ,GAAYtsC,EAAK/I,QAAU+I,EAAK/rB,MAAO04D,EAAEO,YAAa,EAAGJ,IAS3DF,CAAkBf,EAAK73C,EAAQ,EAAGqB,EAAS,GACnD,MAAA,CACH83C,MAAO,CACHryD,EAAG2iC,EAAOzpC,KACVsd,EAAGmsB,EAAOzmB,IACVpd,EAAGoa,EACHjb,EAAGsc,EACHO,OAAAA,GAEJ4yC,MAAO,CACH1tD,EAAG2iC,EAAOzpC,KAAO6yD,EAAO/tD,EACxBwY,EAAGmsB,EAAOzmB,IAAM6vC,EAAO57B,EACvBrxB,EAAGoa,EAAQ6yC,EAAO/tD,EAAI+tD,EAAOnuD,EAC7BK,EAAGsc,EAASwxC,EAAO57B,EAAI47B,EAAO/uD,EAC9B8d,OAAQ,CACJm3C,QAAS53D,KAAK+B,IAAI,EAAG0e,EAAOm3C,QAAU53D,KAAK+B,IAAI2vD,EAAO57B,EAAG47B,EAAO/tD,IAChEk0D,SAAU73D,KAAK+B,IAAI,EAAG0e,EAAOo3C,SAAW73D,KAAK+B,IAAI2vD,EAAO57B,EAAG47B,EAAOnuD,IAClEu0D,WAAY93D,KAAK+B,IAAI,EAAG0e,EAAOq3C,WAAa93D,KAAK+B,IAAI2vD,EAAO/uD,EAAG+uD,EAAO/tD,IACtEo0D,YAAa/3D,KAAK+B,IAAI,EAAG0e,EAAOs3C,YAAc/3D,KAAK+B,IAAI2vD,EAAO/uD,EAAG+uD,EAAOnuD,OAM/E2nB,SAAAA,GAAQwrC,EAAK/wD,EAAGwW,EAAG4O,GAClBktC,IAAAA,EAAc,OAANtyD,EACRuyD,EAAc,OAAN/7C,EAERmsB,EAASouB,KADEuB,GAASC,IACSzB,GAAaC,EAAK3rC,GAC9Cud,OAAAA,IACC2vB,GAAStyD,GAAK2iC,EAAOzpC,MAAQ8G,GAAK2iC,EAAOxpC,SACzCo5D,GAAS/7C,GAAKmsB,EAAOzmB,KAAO1F,GAAKmsB,EAAOxmB,QAO3Cq2C,SAAAA,GAAmBv/C,EAAKyI,GACtB1b,IAAAA,EAAsB0b,EAAtB1b,EAAGwW,EAAmBkF,EAAnBlF,EAAG1X,EAAgB4c,EAAhB5c,EAAGb,EAAayd,EAAbzd,EAAG6c,EAAUY,EAAVZ,OACnB7H,EAAIkI,IAAInb,EAAI8a,EAAOm3C,QAASz7C,EAAIsE,EAAOm3C,QAASn3C,EAAOm3C,SAAU38C,GAASN,IAAI,GAC9E/B,EAAIuI,OAAOxb,EAAGwW,EAAIvY,EAAI6c,EAAOq3C,YAC7Bl/C,EAAIkI,IAAInb,EAAI8a,EAAOq3C,WAAY37C,EAAIvY,EAAI6c,EAAOq3C,WAAYr3C,EAAOq3C,WAAYn9C,GAAIM,IAAS,GAC1FrC,EAAIuI,OAAOxb,EAAIlB,EAAIgc,EAAOs3C,YAAa57C,EAAIvY,GAC3CgV,EAAIkI,IAAInb,EAAIlB,EAAIgc,EAAOs3C,YAAa57C,EAAIvY,EAAI6c,EAAOs3C,YAAat3C,EAAOs3C,YAAa98C,GAAS,GAAG,GAChGrC,EAAIuI,OAAOxb,EAAIlB,EAAG0X,EAAIsE,EAAOo3C,UAC7Bj/C,EAAIkI,IAAInb,EAAIlB,EAAIgc,EAAOo3C,SAAU17C,EAAIsE,EAAOo3C,SAAUp3C,EAAOo3C,SAAU,GAAI58C,IAAS,GACpFrC,EAAIuI,OAAOxb,EAAI8a,EAAOm3C,QAASz7C,GAG1Bi8C,SAAAA,GAAkBx/C,EAAKyI,GAC5BzI,EAAIyI,KAAKA,EAAK1b,EAAG0b,EAAKlF,EAAGkF,EAAK5c,EAAG4c,EAAKzd,GAtJ1CyyD,GAAa5iD,GAAK,QAClB4iD,GAAa5+C,SAAW,CACpB8J,YAAa,EACb60C,UAAW,EACXpG,iBAAkB,EAClBwG,YAAa,EACbj2C,WAAY,SACZE,OAAQ,EACRD,SAAU,GAEd61C,GAAa1xB,cAAgB,CACzB/sB,gBAAiB,kBACjBC,YAAa,eA6IXwgD,IAAAA,GA32SW,SAAA,GAAA,EAAA,EA22SQ7zB,IA32SR,IAAA,EAAA,EAAA,GA42SD7L,SAAAA,EAAAA,GAAK,IAAA,EAAA,OAAA,EAAA,KAAA,IACb,EAAA,EAAA,KAAA,OACK9iB,aAAUxW,EACVqvB,EAAAA,gBAAarvB,EACbgmB,EAAAA,UAAOhmB,EACPwf,EAAAA,WAAQxf,EACR6gB,EAAAA,YAAS7gB,EACVs5B,GACA/nB,OAAOW,OAAaonB,EAAAA,GAAAA,GARX,EA52SJ,OAAA,EAAA,EAAA,CAAA,CAAA,IAAA,OAw3Sb,MAAA,SAAK/f,GACK/C,IAlCK4K,EAkCL5K,EAAU,KAAKA,QACEuhD,EAAAA,GAAc,MAA9B/D,EAAAA,EAAAA,MAAO2E,EAAAA,EAAAA,MACRM,GApCK73C,EAoCmBu3C,EAAMv3C,QAnC1Bm3C,SAAWn3C,EAAOo3C,UAAYp3C,EAAOq3C,YAAcr3C,EAAOs3C,YAmCtBI,GAAqBC,GACnEx/C,EAAIsG,OACA84C,EAAMvzD,IAAM4uD,EAAM5uD,GAAKuzD,EAAMp0D,IAAMyvD,EAAMzvD,IACzCgV,EAAIiI,YACJy3C,EAAY1/C,EAAKo/C,GACjBp/C,EAAIoJ,OACJs2C,EAAY1/C,EAAKy6C,GACjBz6C,EAAIwK,UAAYvN,EAAQgC,YACxBe,EAAI0I,KAAK,YAEb1I,EAAIiI,YACJy3C,EAAY1/C,EAAKy6C,GACjBz6C,EAAIwK,UAAYvN,EAAQ+B,gBACxBgB,EAAI0I,OACJ1I,EAAI0G,YAz4SK,CAAA,IAAA,UA44Sb,MAAA,SAAQg3C,EAAQC,EAAQxrC,GACbG,OAAAA,GAAQ,KAAMorC,EAAQC,EAAQxrC,KA74S5B,CAAA,IAAA,WAg5Sb,MAAA,SAASurC,EAAQvrC,GACNG,OAAAA,GAAQ,KAAMorC,EAAQ,KAAMvrC,KAj5S1B,CAAA,IAAA,WAo5Sb,MAAA,SAASwrC,EAAQxrC,GACNG,OAAAA,GAAQ,KAAM,KAAMqrC,EAAQxrC,KAr5S1B,CAAA,IAAA,iBAw5Sb,MAAA,SAAeA,GACsB,IAAA,EAAA,KAAK0Z,SAAS,CAAC,IAAK,IAAK,OAAQ,cAAe1Z,GAA1EplB,EAAAA,EAAAA,EAAGwW,EAAAA,EAAAA,EAAGkJ,EAAAA,EAAAA,KAAMqJ,EAAAA,EAAAA,WACZ,MAAA,CACH/oB,EAAG+oB,GAAc/oB,EAAI0f,GAAQ,EAAI1f,EACjCwW,EAAGuS,EAAavS,GAAKA,EAAIkJ,GAAQ,KA55S5B,CAAA,IAAA,WAg6Sb,MAAA,SAAS0E,GACEA,MAAS,MAATA,EAAe,KAAKlL,MAAQ,EAAI,KAAKqB,OAAS,MAj6S5C,EAAA,GAq6SjBm4C,GAAW5kD,GAAK,MAChB4kD,GAAW5gD,SAAW,CAClBo/C,cAAe,QACft1C,YAAa,EACbm2C,aAAc,EACdn3C,gBAAYlhB,GAEhBg5D,GAAW1zB,cAAgB,CACvB/sB,gBAAiB,kBACjBC,YAAa,eAGbM,IAAAA,GAAwBvH,OAAO6gB,OAAO,CACtCmE,UAAW,KACX69B,WAAYA,GACZ6B,YAAaA,GACbe,aAAcA,GACdgC,WAAYA,KAmGZE,IAAAA,GAAoB,CACpB9kD,GAAI,aACJgE,SAAU,CACN+gD,UAAW,UACXrxB,SAAS,GAEbsxB,qBAAsB,SAACn5D,EAAO5B,EAAMmY,GAC5B,GAACA,EAAQsxB,QAAT,CAGE7W,IAAAA,EAAiBhxB,EAAMuf,MAC7Bvf,EAAMif,KAAKzG,SAAShY,QAAQ,SAACssB,EAASlX,GAC3BgpB,IAAAA,EAAoB9R,EAApB8R,MAAOnlB,EAAaqT,EAAbrT,UACRoT,EAAO7sB,EAAM+sB,eAAenX,GAC5BqJ,EAAO2f,GAAS9R,EAAQ7N,KAC1B8O,GAAkD,MAAlDA,GAAQ,CAACtU,EAAWzZ,EAAMuW,QAAQkD,aAGpB,SAAdoT,EAAK1sB,KAAL0sB,CAGEusC,IAAAA,EAAQp5D,EAAMoa,OAAOyS,EAAK4S,SAC5B25B,IAAe,WAAfA,EAAMj5D,MAAoC,SAAfi5D,EAAMj5D,SAGjCH,EAAMuW,QAAQyD,SAGdiF,EAAK7d,QAAU,EAAI4vB,GAAnB/R,CAiBAo6C,IAAAA,EACI9iD,OAfJnC,GAAcwqB,KACd9R,EAAQ8R,MAAQ3f,SACT6N,EAAQ7N,KACf3N,OAAOsU,eAAekH,EAAS,OAAQ,CACnCjH,cAAc,EACd9K,YAAY,EACZjZ,IAAK,WACM,OAAA,KAAKiwD,YAEhB9vD,IAAK,SAAUsB,GACNq7B,KAAAA,MAAQr7B,MAKjBgT,EAAQ2iD,WACP,IAAA,OACDG,EAhJXC,SAAer6C,EAAM+R,EAAgBza,GACpCgjD,IAKFl4D,EAAGm4D,EAAcC,EAASp3C,EAAMq3C,EAL9BH,EAAUhjD,EAAQgjD,SAAWvoC,EAC7BqoC,EAAY,GACZM,GAAe16C,EAAK7d,OAAS,IAAMm4D,EAAU,GAC/CK,EAAe,EACfx2D,EAAI,EAGH/B,IADLg4D,EAAUO,KAAkB36C,EAAK7b,GAC5B/B,EAAI,EAAGA,EAAIk4D,EAAU,EAAGl4D,IAAK,CAC1B6zD,IAAAA,EAAO,EACP2E,EAAO,EACP3oD,OAAJ,EACM4oD,EAAgBp5D,KAAKyb,OAAO9a,EAAI,GAAKs4D,GAAe,EACpDI,EAAcr5D,KAAKC,IAAID,KAAKyb,OAAO9a,EAAI,GAAKs4D,GAAe,EAAG16C,EAAK7d,QACnE44D,EAAiBD,EAAcD,EAChC5oD,IAAAA,EAAI4oD,EAAe5oD,EAAI6oD,EAAa7oD,IACrCgkD,EAAOj2C,EAAK/N,GAAG7K,EACfwzD,EAAO56C,EAAK/N,GAAG2L,EAEnBq4C,GAAQ8E,EACRH,GAAQG,EACFC,IAAAA,EAAYv5D,KAAKyb,MAAM9a,EAAIs4D,GAAe,EAC1CO,EAAUx5D,KAAKyb,OAAO9a,EAAI,GAAKs4D,GAAe,EACnB16C,EAAAA,EAAK7b,GAA5B+2D,EAAH9zD,EAAAA,EAAe+zD,EAAHv9C,EAAAA,EAEd3L,IADLuoD,EAAUp3C,GAAQ,EACbnR,EAAI+oD,EAAW/oD,EAAIgpD,EAAShpD,KAC7BmR,EAAO,GAAM3hB,KAAKqc,KACbo9C,EAAUjF,IAASj2C,EAAK/N,GAAG2L,EAAIu9C,IAC/BD,EAAUl7C,EAAK/N,GAAG7K,IAAMwzD,EAAOO,KAEzBX,IACPA,EAAUp3C,EACVm3C,EAAev6C,EAAK/N,GACpBwoD,EAAQxoD,GAGhBmoD,EAAUO,KAAkBJ,EAC5Bp2D,EAAIs2D,EAGDL,OADPA,EAAUO,KAAkB36C,EAAKA,EAAK7d,OAAS,GACxCi4D,EAwGqBC,CAAer6C,EAAM+R,EAAgBza,GACjD,MACC,IAAA,UACD8iD,EAxGXgB,SAAiBp7C,EAAM+R,GACxBkkC,IAEA7zD,EAAG+gB,EAAO/b,EAAGwW,EAAGm4C,EAAOsF,EAAUC,EAAUC,EAAY7K,EAAMF,EAF7DyF,EAAO,EACPC,EAAS,EAEPkE,EAAY,GACZoB,EAAOx7C,EAAK,GAAG5Y,EAEfq0D,EADOz7C,EAAKA,EAAK7d,OAAS,GAAGiF,EACjBo0D,EACbp5D,IAAAA,EAAI,EAAGA,EAAI4d,EAAK7d,SAAUC,EAAG,CAE9BgF,IADA+b,EAAQnD,EAAK5d,IACFgF,EAAIo0D,GAAQC,EAAK1pC,EAC5BnU,EAAIuF,EAAMvF,EACJy4C,IAAAA,EAAa,EAAJjvD,EACXivD,GAAAA,IAAWN,EACPn4C,EAAI8yC,GACJA,EAAO9yC,EACPy9C,EAAWj5D,GACJwb,EAAI4yC,IACXA,EAAO5yC,EACP09C,EAAWl5D,GAEf6zD,GAAQC,EAASD,EAAO9yC,EAAM/b,KAAO8uD,MAClC,CACGwF,IAAAA,EAAYt5D,EAAI,EAClB,IAAC+S,GAAckmD,KAAclmD,GAAcmmD,GAAW,CAChDK,IAAAA,EAAqBl6D,KAAKC,IAAI25D,EAAUC,GACxCM,EAAqBn6D,KAAK+B,IAAI63D,EAAUC,GAC1CK,IAAuBJ,GAAcI,IAAuBD,GAC5DtB,EAAUh3D,KACH4c,EAAAA,EAAAA,GAAAA,EAAK27C,IADZ,GAAA,CAEIv0D,EAAG6uD,KAGP2F,IAAuBL,GAAcK,IAAuBF,GAC5DtB,EAAUh3D,KACH4c,EAAAA,EAAAA,GAAAA,EAAK47C,IADZ,GAAA,CAEIx0D,EAAG6uD,KAIX7zD,EAAI,GAAKs5D,IAAcH,GACvBnB,EAAUh3D,KAAK4c,EAAK07C,IAExBtB,EAAUh3D,KAAK+f,GACf4yC,EAAQM,EACRH,EAAS,EACTxF,EAAOF,EAAO5yC,EACdy9C,EAAWC,EAAWC,EAAan5D,GAGpCg4D,OAAAA,EAsDqBgB,CAAiBp7C,EAAM+R,GACnC,MACJ,QACU,MAAA,IAAIslB,MAA2C//B,qCAAAA,OAAAA,EAAQ2iD,UAA7D,MAERpsC,EAAQilC,WAAasH,QAG7ByB,QAAQ96D,SAAAA,GACJA,EAAMif,KAAKzG,SAAShY,QAAQ,SAACssB,GACrBA,GAAAA,EAAQilC,WAAY,CACd9yC,IAAAA,EAAO6N,EAAQ8R,aACd9R,EAAQilC,kBACRjlC,EAAQ8R,MACfttB,OAAOsU,eAAekH,EAAS,OAAQ,CAACnZ,MAAOsL,SA4BtD87C,SAAAA,GAAWt3C,EAAM5N,EAAOurB,GACvBpf,IAAAA,EAjBDg5C,SAAgBv3C,GACflN,IAAAA,EAAUkN,EAAKlN,QACf0kD,EAAa1kD,EAAQyL,KACvBA,EAAOnN,GAAeomD,GAAcA,EAAWjlD,OAAQilD,GAIvDj5C,YAHSjiB,IAATiiB,IACAA,IAASzL,EAAQ+B,kBAER,IAAT0J,GAA2B,OAATA,KAGT,IAATA,EACO,SAEJA,GAIMg5C,CAAgBv3C,GACzBlP,GAAAA,GAASyN,GACFrF,OAAAA,MAAMqF,EAAKrO,QAAiBqO,EAEnChM,IAAAA,EAASf,WAAW+M,GACpBxN,OAAAA,GAAewB,IAAWtV,KAAKyb,MAAMnG,KAAYA,GACjC,MAAZgM,EAAK,IAA0B,MAAZA,EAAK,KACxBhM,EAASH,EAAQG,KAEjBA,IAAWH,GAASG,EAAS,GAAKA,GAAUorB,IAGzCprB,GAEJ,CAAC,SAAU,QAAS,MAAO,SAASK,QAAQ2L,IAAS,GAAKA,EA0B/Dk5C,IAAAA,GA/pTW,WAgqTD13C,SAAAA,EAAAA,GAAM,EAAA,KAAA,GACTnd,KAAAA,EAAImd,EAAKnd,EACTwW,KAAAA,EAAI2G,EAAK3G,EACTsE,KAAAA,OAASqC,EAAKrC,OAnqTV,OAAA,EAAA,EAAA,CAAA,CAAA,IAAA,cAsqTb,MAAA,SAAY7H,EAAK0vB,EAAQxlB,GACdnd,IAAAA,EAAgB,KAAhBA,EAAGwW,EAAa,KAAbA,EAAGsE,EAAU,KAAVA,OAGN,OAFP6nB,EAASA,GAAU,CAAC5pC,MAAO,EAAGC,IAAKic,IACnChC,EAAIkI,IAAInb,EAAGwW,EAAGsE,EAAQ6nB,EAAO3pC,IAAK2pC,EAAO5pC,OAAO,IACxCokB,EAAKwlB,SA1qTJ,CAAA,IAAA,cA6qTb,MAAA,SAAY5mB,GACD/b,IAAAA,EAAgB,KAAhBA,EAAGwW,EAAa,KAAbA,EAAGsE,EAAU,KAAVA,OACPnD,EAAQoE,EAAMpE,MACb,MAAA,CACH3X,EAAGA,EAAI3F,KAAKkhB,IAAI5D,GAASmD,EACzBtE,EAAGA,EAAInc,KAAKihB,IAAI3D,GAASmD,EACzBnD,MAAAA,OAnrTK,EAAA,GAutTRm9C,SAAAA,GAAgBplD,GAEjBoE,OADUpE,EAAOoE,OAAS,IACpBs5C,yBAjCL2H,SAAwBrlD,GACtBoE,IAMH9Y,EAAGgrB,EAAQ1Y,EANRwG,EAAepE,EAAfoE,MAAO6H,EAAQjM,EAARiM,KACRzL,EAAU4D,EAAM5D,QAChBnV,EAAS+Y,EAAMwnB,YAAYvgC,OAC3B4U,EAAS,GACT5W,EAAQmX,EAAQlB,QAAU8E,EAAM1X,IAAM0X,EAAMxZ,IAC5CtB,EAAMkX,EAAQlB,QAAU8E,EAAMxZ,IAAMwZ,EAAM1X,IAW5C8T,GARA5C,EADS,UAATqO,EACQ5iB,EACQ,QAAT4iB,EACC3iB,EACDkV,GAASyN,GACRA,EAAKrO,MAELwG,EAAM82B,eAEd16B,EAAQ0yB,KAAKmqB,SAEN,OADP/mC,EAASlS,EAAMs5C,yBAAyB,EAAGr0D,GACpC,IAAI87D,GAAU,CACjB70D,EAAGgmB,EAAOhmB,EACVwW,EAAGwP,EAAOxP,EACVsE,OAAQhH,EAAM+4C,8BAA8Bv/C,KAG/CtS,IAAAA,EAAI,EAAGA,EAAID,IAAUC,EACtB2U,EAAO3T,KAAK8X,EAAMs5C,yBAAyBpyD,EAAGsS,IAE3CqC,OAAAA,EAMIolD,CAAwBrlD,GAlF9BslD,SAAsBtlD,GACAA,IAEvBqZ,EAFuBrZ,EAAAA,EAApBoE,MAAAA,OAAQ,IAAA,EAAA,GADoB,EAChB6H,EAAQjM,EAARiM,KACfhM,EAAS,KAWTxB,MATS,UAATwN,EACAhM,EAASmE,EAAMqI,OACC,QAATR,EACPhM,EAASmE,EAAMoI,IACRhO,GAASyN,GAChBhM,EAASmE,EAAM42B,iBAAiB/uB,EAAKrO,OAC9BwG,EAAMixC,eACbp1C,EAASmE,EAAMixC,gBAEf52C,GAAewB,GAER,CACH3P,GAFJ+oB,EAAajV,EAAMkX,gBAECrb,EAAS,KACzB6G,EAAGuS,EAAa,KAAOpZ,GAGxB,KAgEAqlD,CAAsBtlD,GAqBxBulD,SAAAA,GAAevlD,GACb/V,IAAAA,EAA6B+V,EAA7B/V,MAAOma,EAAsBpE,EAAtBoE,MAAOtE,EAAeE,EAAfF,MAAO4N,EAAQ1N,EAAR0N,KACtBk0B,EAAS,GACT2E,EAAW74B,EAAK64B,SAChBif,EAAe93C,EAAKk0B,OACpB6jB,EAaDC,SAAcz7D,EAAO6V,GAGrB,IAFC6lD,IAAAA,EAAQ,GACRjvB,EAAQzsC,EAAMsrB,+BACXjqB,EAAI,EAAGA,EAAIorC,EAAMrrC,OAAQC,IAAK,CAC7BwrB,IAAAA,EAAO4f,EAAMprC,GACfwrB,GAAAA,EAAKhX,QAAUA,EACf,MAEA8lD,GAA4B9uC,IAC5B6uC,EAAME,QAAQ/uC,EAAKC,SAGpB4uC,OAAAA,EAzBYD,CAAcz7D,EAAO6V,GACxC2lD,EAAWn5D,KAAKw5D,GAAmB,CAACx1D,EAAG,KAAMwW,EAAG1C,EAAMqI,QAASiB,IAC1D,IAAA,IAAIpiB,EAAI,EAAGA,EAAIi7C,EAASl7C,OAAQC,IAE5B,IADCu6C,IAAAA,EAAUU,EAASj7C,GAChB6P,EAAI0qC,EAAQx8C,MAAO8R,GAAK0qC,EAAQv8C,IAAK6R,IAC1C4qD,GAAenkB,EAAQ4jB,EAAarqD,GAAIsqD,GAGzC,OAAA,IAAIxF,GAAY,CAACre,OAAAA,EAAQphC,QAAS,KAGvColD,IAAAA,GAA8B,SAAC9uC,GAASA,MAAc,SAAdA,EAAK1sB,OAAoB0sB,EAAKg7B,QAiBnEiU,SAAAA,GAAenkB,EAAQokB,EAAaP,GAEpC,IADCQ,IAAAA,EAAY,GACT9qD,EAAI,EAAGA,EAAIsqD,EAAWp6D,OAAQ8P,IAAK,CAClCuS,IACuBw4C,EAAAA,GADhBT,EAAWtqD,GACqB6qD,EAAa,KAAnD/zB,EAAAA,EAAAA,MAAOC,EAAAA,EAAAA,KAAM7lB,EAAAA,EAAAA,MAChB,MAACA,GAAU4lB,GAASC,GAGpBD,GAAAA,EACAg0B,EAAUJ,QAAQx5C,QAGd,GADJu1B,EAAOt1C,KAAK+f,IACP6lB,EACD,MAIZ0P,EAAOt1C,KAAPs1C,MAAAA,EAAeqkB,GAGVC,SAAAA,GAAUx4C,EAAMs4C,EAAa3+C,GAC5BgF,IAAAA,EAAQqB,EAAKy4C,YAAYH,EAAa3+C,GACxC,IAACgF,EACM,MAAA,GAON,IALC+5C,IAAAA,EAAa/5C,EAAMhF,GACnBk/B,EAAW74B,EAAK64B,SAChB8f,EAAa34C,EAAKk0B,OACpB3P,GAAQ,EACRC,GAAO,EACF5mC,EAAI,EAAGA,EAAIi7C,EAASl7C,OAAQC,IAAK,CAChCu6C,IAAAA,EAAUU,EAASj7C,GACnBg7D,EAAaD,EAAWxgB,EAAQx8C,OAAOge,GACvCk/C,EAAYF,EAAWxgB,EAAQv8C,KAAK+d,GACtC++C,GAAAA,GAAcE,GAAcF,GAAcG,EAAW,CACrDt0B,EAAQm0B,IAAeE,EACvBp0B,EAAOk0B,IAAeG,EACtB,OAGD,MAAA,CAACt0B,MAAAA,EAAOC,KAAAA,EAAM7lB,MAAAA,GAkBhBy5C,SAAAA,GAAmBU,EAAU94C,GAC9Bk0B,IAAAA,EAAS,GACThe,GAAQ,EAOLge,OANHnyC,GAAQ+2D,IACR5iC,GAAQ,EACRge,EAAS4kB,GAET5kB,EApHC6kB,SAAmBD,EAAU94C,GACL84C,IAAAA,EAAAA,GAAY,GAAlCl2D,EAAAA,EAAAA,EAAAA,OAAI,IAAA,EAAA,KAD6B,EACvBwW,EAAAA,EAAAA,EAAAA,OAAI,IAAA,EAAA,KADmB,EAElCu/C,EAAa34C,EAAKk0B,OAClBA,EAAS,GAYRA,OAXPl0B,EAAK64B,SAAS97C,QAAQ,SAACo7C,GACb5T,IAAAA,EAAQo0B,EAAWxgB,EAAQx8C,OAC3B6oC,EAAOm0B,EAAWxgB,EAAQv8C,KACtB,OAANwd,GACA86B,EAAOt1C,KAAK,CAACgE,EAAG2hC,EAAM3hC,EAAGwW,EAAAA,IACzB86B,EAAOt1C,KAAK,CAACgE,EAAG4hC,EAAK5hC,EAAGwW,EAAAA,KACX,OAANxW,IACPsxC,EAAOt1C,KAAK,CAACgE,EAAAA,EAAGwW,EAAGmrB,EAAMnrB,IACzB86B,EAAOt1C,KAAK,CAACgE,EAAAA,EAAGwW,EAAGorB,EAAKprB,OAGzB86B,EAqGM6kB,CAAmBD,EAAU94C,GAEnCk0B,EAAOv2C,OAAS,IAAI40D,GAAY,CACnCre,OAAAA,EACAphC,QAAS,CAACojC,QAAS,GACnBhgB,MAAAA,EACAijB,UAAWjjB,IACV,KAGA8iC,SAAAA,GAAc9lD,EAASd,EAAO6mD,GAC7B3mD,IAGFC,EAFAgM,EADWrL,EAAQd,GACLmM,KACZ26C,EAAU,CAAC9mD,GAEb,IAAC6mD,EACM16C,OAAAA,EAEJA,MAAS,IAATA,IAA6C,IAA3B26C,EAAQtmD,QAAQ2L,IAAc,CAC/C,IAACxN,GAAewN,GACTA,OAAAA,EAGP,KADJhM,EAASW,EAAQqL,IAEN,OAAA,EAEPhM,GAAAA,EAAO+kB,QACA/Y,OAAAA,EAEX26C,EAAQt6D,KAAK2f,GACbA,EAAOhM,EAAOgM,KAEX,OAAA,EAGFghB,SAAAA,GAAM1pB,EAAKtD,EAAQ4mD,GACxBtjD,EAAIiI,YACJvL,EAAO6/C,KAAKv8C,GACZA,EAAIuI,OAAO7L,EAAOiyB,OAAO5hC,EAAGu2D,GAC5BtjD,EAAIuI,OAAO7L,EAAOgyB,QAAQ3hC,EAAGu2D,GAC7BtjD,EAAImI,YACJnI,EAAIoJ,OAGCm6C,SAAAA,GAAUz/C,EAAU4qB,EAAOC,EAAMrO,GAClCA,IAAAA,EAAAA,CAGAx6B,IAAAA,EAAQ4oC,EAAM5qB,GACd/d,EAAM4oC,EAAK7qB,GAKR,MAJU,UAAbA,IACAhe,EAAQmf,GAAgBnf,GACxBC,EAAMkf,GAAgBlf,IAEnB,CAAC+d,SAAAA,EAAUhe,MAAAA,EAAOC,IAAAA,IAGpBy9D,SAAAA,GAAS15D,EAAGC,EAAGoqB,EAAMzvB,GACtBoF,OAAAA,GAAKC,EACErF,EAAGoF,EAAEqqB,GAAOpqB,EAAEoqB,IAElBrqB,EAAIA,EAAEqqB,GAAQpqB,EAAIA,EAAEoqB,GAAQ,EA0C9BsvC,SAAAA,GAAWzjD,EAAKa,EAAO6uB,GACN7uB,IAAAA,EAAAA,EAAMna,MAAM0rB,UAA3BnJ,EAAAA,EAAAA,IAAKC,EAAAA,EAAAA,OACmBwmB,EAAAA,GAAU,GAAlC5rB,EAAAA,EAAAA,SAAUhe,EAAAA,EAAAA,MAAOC,EAAAA,EAAAA,IACP,MAAb+d,IACA9D,EAAIiI,YACJjI,EAAIyI,KAAK3iB,EAAOmjB,EAAKljB,EAAMD,EAAOojB,EAASD,GAC3CjJ,EAAIoJ,QAIHs6C,SAAAA,GAAmB1jD,EAAKtD,EAAQoM,EAAOhF,GACtC6/C,IAAAA,EAAoBjnD,EAAOkmD,YAAY95C,EAAOhF,GAChD6/C,GACA3jD,EAAIuI,OAAOo7C,EAAkB52D,EAAG42D,EAAkBpgD,GAIjDqgD,SAAAA,GAAM5jD,EAAK+f,GACT5V,IAAAA,EAAwC4V,EAAxC5V,KAAMzN,EAAkCqjB,EAAlCrjB,OAAQoH,EAA0Bic,EAA1Bjc,SAAUrK,EAAgBsmB,EAAhBtmB,MAAOoH,EAASkf,EAATlf,MAChCmiC,EA1DD4Z,SAAUzyC,EAAMzN,EAAQoH,GAKxB,IAJCk/B,IAAAA,EAAW74B,EAAK64B,SAChB3E,EAASl0B,EAAKk0B,OACdwlB,EAAUnnD,EAAO2hC,OACjBsG,EAAQ,GACL58C,EAAI,EAAGA,EAAIi7C,EAASl7C,OAAQC,IAAK,CAChCu6C,IAAAA,EAAUU,EAASj7C,GACnB2nC,EAAS6zB,GAAUz/C,EAAUu6B,EAAOiE,EAAQx8C,OAAQu4C,EAAOiE,EAAQv8C,KAAMu8C,EAAQhiB,MACnF,GAAC5jB,EAAOsmC,SAUP,IADC8gB,IAAAA,EAAO/gB,GAAermC,EAAQgzB,GAC3B93B,EAAI,EAAGA,EAAIksD,EAAKh8D,SAAU8P,EAI1B,IAHCqrC,IAAAA,EAAM6gB,EAAKlsD,GACXmsD,EAAYR,GAAUz/C,EAAU+/C,EAAQ5gB,EAAIn9C,OAAQ+9D,EAAQ5gB,EAAIl9C,KAAMk9C,EAAI3iB,MAC1E0jC,EAAc3hB,GAAcC,EAASjE,EAAQ0lB,GAC1Cr4D,EAAI,EAAGA,EAAIs4D,EAAYl8D,OAAQ4D,IACpCi5C,EAAM57C,KAAK,CACP0T,OAAQunD,EAAYt4D,GACpBgR,OAAQumC,EACRn9C,MACKge,EAAAA,GAAAA,EAAW0/C,GAAS9zB,EAAQq0B,EAAW,QAAS38D,KAAK+B,MAE1DpD,IACK+d,EAAAA,GAAAA,EAAW0/C,GAAS9zB,EAAQq0B,EAAW,MAAO38D,KAAKC,aArBhEs9C,EAAM57C,KAAK,CACP0T,OAAQ6lC,EACR5lC,OAAQgzB,EACR5pC,MAAOu4C,EAAOiE,EAAQx8C,OACtBC,IAAKs4C,EAAOiE,EAAQv8C,OAuBzB4+C,OAAAA,EAsBUiY,CAAUzyC,EAAMzN,EAAQoH,GACzC9D,EAAIwK,UAAY/Q,EACX,IAAA,IAAI1R,EAAI,EAAGoU,EAAO6mC,EAASl7C,OAAQC,EAAIoU,IAAQpU,EAAG,CACJi7C,IAAAA,EAAAA,EAASj7C,GAAzCk8D,EAARxnD,EAAAA,OAAqBynD,EAARxnD,EAAAA,OAAa5W,EAAAA,EAAAA,MAAOC,EAAAA,EAAAA,IACxCia,EAAIsG,OACJm9C,GAAWzjD,EAAKa,EAAO0iD,GAAUz/C,EAAUhe,EAAOC,IAClDia,EAAIiI,YACEk8C,IAAAA,IAAah6C,EAAKkxC,YAAYr7C,EAAKikD,GACrCE,EACAnkD,EAAImI,YAEJu7C,GAAmB1jD,EAAKtD,EAAQ3W,EAAK+d,GAEnCsgD,IAAAA,IAAe1nD,EAAO2+C,YAAYr7C,EAAKkkD,EAAK,CAAC34B,KAAM44B,EAAUpoD,SAAS,IACtEukB,EAAO6jC,GAAYC,EACpB9jC,GACDojC,GAAmB1jD,EAAKtD,EAAQ5W,EAAOge,GAE3C9D,EAAImI,YACJnI,EAAI0I,KAAK4X,EAAO,UAAY,WAC5BtgB,EAAI0G,WAmBR29C,IAAAA,GAAgB,CAChBxpD,GAAI,SACJypD,oBAAoB59D,SAAAA,EAAO69D,EAAOtnD,GACxB6qB,IAGFvU,EAAMxrB,EAAGoiB,EAAM1N,EAHbqrB,GAASphC,EAAMif,KAAKzG,UAAY,IAAIpX,OACpCs7D,EAAYnmD,EAAQmmD,UACpB/lD,EAAU,GAEXtV,IAAAA,EAAI,EAAGA,EAAI+/B,IAAS//B,EAGrB0U,EAAS,MADT0N,GADAoJ,EAAO7sB,EAAM+sB,eAAe1rB,IAChByrB,UAEArJ,EAAKlN,SAAWkN,aAAgBuyC,KACxCjgD,EAAS,CACLglB,QAAS/6B,EAAMsmD,iBAAiBjlD,GAChCwU,MAAOxU,EACP2gB,KAAM+4C,GAAWt3C,EAAMpiB,EAAG+/B,GAC1BphC,MAAAA,EACAma,MAAO0S,EAAK2Q,OACZ/Z,KAAAA,IAGRoJ,EAAKixC,QAAU/nD,EACfY,EAAQtU,KAAK0T,GAEZ1U,IAAAA,EAAI,EAAGA,EAAI+/B,IAAS//B,GACrB0U,EAASY,EAAQtV,MACc,IAAhB0U,EAAOiM,OAGtBjM,EAAOiM,KAAOy6C,GAAc9lD,EAAStV,EAAGq7D,KAGhDqB,mBAAmB/9D,SAAAA,GACTqrB,IAEFhqB,EAAGwrB,EAFDxB,EAAWrrB,EAAMsrB,+BACjBjJ,EAAOriB,EAAM0rB,UAEdrqB,IAAAA,EAAIgqB,EAASjqB,OAAS,EAAGC,GAAK,IAAKA,GACpCwrB,EAAOxB,EAAShqB,GAAGy8D,UAEfjxC,EAAKpJ,KAAK6uC,oBAAoBjwC,IAI1C27C,kBAAkBh+D,SAAAA,EAAO5B,GACfikB,IAAAA,EAAOriB,EAAM0rB,UACbpS,EAAMtZ,EAAMsZ,IACZvD,EAAS3X,EAAKyuB,KAAKixC,QACrB,GAAC/nD,IAA0B,IAAhBA,EAAOiM,KAAlB,CAGEhM,IAAAA,EAzOLioD,SAAUloD,GACR/V,IAAAA,EAAqB+V,EAArB/V,MAAOgiB,EAAcjM,EAAdiM,KAAMyB,EAAQ1N,EAAR0N,KAChBjP,GAAAA,GAAewN,GACRk8C,OAhONA,SAAel+D,EAAO6V,GACrBgX,IAAAA,EAAO7sB,EAAM+sB,eAAelX,GAE3BklB,OADSlO,GAAQ7sB,EAAMsmD,iBAAiBzwC,GAC9BgX,EAAKC,QAAU,KA6NrBoxC,CAAel+D,EAAOgiB,GAE7BA,GAAS,UAATA,EACOs5C,OAAAA,GAAevlD,GAEpBwmD,IAAAA,EAAWpB,GAAgBplD,GAC7BwmD,OAAAA,aAAoBrB,GACbqB,EAEJV,GAAmBU,EAAU94C,GA6NjBw6C,CAAUloD,GAClB0N,EAAe1N,EAAf0N,KAAMtJ,EAASpE,EAAToE,MACPgkD,EAAW16C,EAAKlN,QAChB0kD,EAAakD,EAASn8C,KACtBjP,EAAQorD,EAAS7lD,gBACgB2iD,EAAAA,GAAc,GAA9CmD,EAAAA,EAAAA,MAAAA,OAAQrrD,IAAAA,EAAAA,EAZY,EAYL2oD,EAAAA,EAAAA,MAAAA,OAAQ3oD,IAAAA,EAAAA,EAZH,EAavBiD,GAAUyN,EAAKk0B,OAAOv2C,SACtBqhB,GAASnJ,EAAK+I,GAxEjBg8C,SAAO/kD,EAAK+f,GACV5V,IAAAA,EAA2C4V,EAA3C5V,KAAMzN,EAAqCqjB,EAArCrjB,OAAQooD,EAA6B/kC,EAA7B+kC,MAAO1C,EAAsBriC,EAAtBqiC,MAAOr5C,EAAegX,EAAfhX,KAAMlI,EAASkf,EAATlf,MACnCiD,EAAWqG,EAAKkW,MAAQ,QAAU,IACxCrgB,EAAIsG,OACa,MAAbxC,GAAoBs+C,IAAU0C,IAC9Bp7B,GAAM1pB,EAAKtD,EAAQqM,EAAKE,KACxB26C,GAAM5jD,EAAK,CAACmK,KAAAA,EAAMzN,OAAAA,EAAQjD,MAAOqrD,EAAOjkD,MAAAA,EAAOiD,SAAAA,IAC/C9D,EAAI0G,UACJ1G,EAAIsG,OACJojB,GAAM1pB,EAAKtD,EAAQqM,EAAKG,SAE5B06C,GAAM5jD,EAAK,CAACmK,KAAAA,EAAMzN,OAAAA,EAAQjD,MAAO2oD,EAAOvhD,MAAAA,EAAOiD,SAAAA,IAC/C9D,EAAI0G,UA6DIq+C,CAAO/kD,EAAK,CAACmK,KAAAA,EAAMzN,OAAAA,EAAQooD,MAAAA,EAAO1C,MAAAA,EAAOr5C,KAAAA,EAAMlI,MAAAA,IAC/CwI,GAAWrJ,MAGnBnB,SAAU,CACNukD,WAAW,IAIb4B,GAAa,SAACC,EAAWC,GACuBD,IAAAA,EAAAA,EAA7CE,UAAAA,OAAYD,IAAAA,EAAAA,EADuB,EACUD,EAAAA,EAAvBG,SAAAA,OAAWF,IAAAA,EAAAA,EADE,EAMjC,OAJHD,EAAUI,gBACVF,EAAY/9D,KAAKC,IAAI89D,EAAWD,GAChCE,EAAWh+D,KAAKC,IAAI+9D,EAAUF,IAE3B,CACHE,SAAAA,EACAD,UAAAA,EACAG,WAAYl+D,KAAK+B,IAAI+7D,EAAUC,KAKjCI,GArkUW,SAAA,GAAA,EAAA,EAqkUI35B,IArkUJ,IAAA,EAAA,EAAA,GAskUDhK,SAAAA,EAAAA,GAAQ,IAAA,EAAA,OAAA,EAAA,KAAA,IAChB,EAAA,EAAA,KAAA,OACK4jC,QAAS,EACTC,EAAAA,eAAiB,GACjBC,EAAAA,aAAe,KACfC,EAAAA,cAAe,EACfj/D,EAAAA,MAAQk7B,EAAOl7B,MACfuW,EAAAA,QAAU2kB,EAAO3kB,QACjB+C,EAAAA,IAAM4hB,EAAO5hB,IACb4lD,EAAAA,iBAAcn/D,EACdo/D,EAAAA,iBAAcp/D,EACdq/D,EAAAA,gBAAar/D,EACbipB,EAAAA,eAAYjpB,EACZqkB,EAAAA,cAAWrkB,EACXwiB,EAAAA,SAAMxiB,EACNyiB,EAAAA,YAASziB,EACTR,EAAAA,UAAOQ,EACPP,EAAAA,WAAQO,EACR6gB,EAAAA,YAAS7gB,EACTwf,EAAAA,WAAQxf,EACRsrC,EAAAA,cAAWtrC,EACXorB,EAAAA,cAAWprB,EACXiT,EAAAA,YAASjT,EACTqwB,EAAAA,cAAWrwB,EAvBA,EAtkUP,OAAA,EAAA,EAAA,CAAA,CAAA,IAAA,SAgmUb,MAAA,SAAOqkB,EAAU4E,EAAWD,GAClBnoB,IAAAA,EAAK,KACXA,EAAGwjB,SAAWA,EACdxjB,EAAGooB,UAAYA,EACfpoB,EAAGyqC,SAAWtiB,EACdnoB,EAAGqsC,gBACHrsC,EAAGy+D,cACHz+D,EAAGmtC,QAvmUM,CAAA,IAAA,gBA0mUb,MAAA,WACUntC,IAAAA,EAAK,KACPA,EAAGywB,gBACHzwB,EAAG2e,MAAQ3e,EAAGwjB,SACdxjB,EAAGrB,KAAO,EACVqB,EAAGpB,MAAQoB,EAAG2e,QAEd3e,EAAGggB,OAAShgB,EAAGooB,UACfpoB,EAAG2hB,IAAM,EACT3hB,EAAG4hB,OAAS5hB,EAAGggB,UAnnUV,CAAA,IAAA,cAunUb,MAAA,WACUhgB,IAAAA,EAAK,KACL29D,EAAY39D,EAAG2V,QAAQmrB,QAAU,GACnCw9B,EAAcrhE,GAAS0gE,EAAUzN,eAAgB,CAAClwD,EAAGZ,OAAQY,IAAO,GACpE29D,EAAU/vC,SACV0wC,EAAcA,EAAY1wC,OAAO,SAACltB,GAASi9D,OAAAA,EAAU/vC,OAAOltB,EAAMV,EAAGZ,MAAMif,SAE3Es/C,EAAU9hD,OACVyiD,EAAcA,EAAYziD,KAAK,SAACrZ,EAAGC,GAAMk7D,OAAAA,EAAU9hD,KAAKrZ,EAAGC,EAAGzC,EAAGZ,MAAMif,SAEvEre,EAAG2V,QAAQlB,SACX6pD,EAAY7pD,UAEhBzU,EAAGs+D,YAAcA,IApoUR,CAAA,IAAA,MAuoUb,MAAA,WACUt+D,IAAAA,EAAK,KACJ2V,EAAgB3V,EAAhB2V,QAAS+C,EAAO1Y,EAAP0Y,IACZ,GAAC/C,EAAQ2b,QAAT,CAIEqsC,IAKFh/C,EAAOqB,EALL29C,EAAYhoD,EAAQmrB,OACpB49B,EAAYzxC,GAAO0wC,EAAUxlD,MAC7BylD,EAAWc,EAAUrmD,KACrBu2B,EAAc5uC,EAAG2+D,sBACQjB,EAAAA,GAAWC,EAAWC,GAA9CE,EAAAA,EAAAA,SAAUE,EAAAA,EAAAA,WAEjBtlD,EAAIP,KAAOumD,EAAUlgD,OACjBxe,EAAGywB,gBACH9R,EAAQ3e,EAAGwjB,SACXxD,EAAShgB,EAAG4+D,SAAShwB,EAAagvB,EAAUE,EAAUE,GAAc,KAEpEh+C,EAAShgB,EAAGooB,UACZzJ,EAAQ3e,EAAG6+D,SAASjwB,EAAagvB,EAAUE,EAAUE,GAAc,IAEvEh+D,EAAG2e,MAAQ7e,KAAKC,IAAI4e,EAAOhJ,EAAQ6N,UAAYxjB,EAAGwjB,UAClDxjB,EAAGggB,OAASlgB,KAAKC,IAAIigB,EAAQrK,EAAQyS,WAAapoB,EAAGooB,gBAlBjDpoB,EAAG2e,MAAQ3e,EAAGggB,OAAS,IA3oUlB,CAAA,IAAA,WAgqUb,MAAA,SAAS4uB,EAAagvB,EAAUE,EAAUE,GAChCh+D,IAAAA,EAAK,KACJ0Y,EAA+C1Y,EAA/C0Y,IAAK8K,EAA0CxjB,EAA1CwjB,SAA6BmM,EAAa3vB,EAAhC2V,QAAUmrB,OAASnR,QACnCmvC,EAAW9+D,EAAGm+D,eAAiB,GAC/BK,EAAax+D,EAAGw+D,WAAa,CAAC,GAC9BjmD,EAAaylD,EAAaruC,EAC5BovC,EAAcnwB,EAClBl2B,EAAIyK,UAAY,OAChBzK,EAAI0K,aAAe,SACf47C,IAAAA,GAAO,EACPr9C,GAAOpJ,EAYJwmD,OAXP/+D,EAAGs+D,YAAY1+D,QAAQ,SAACuwD,EAAY1vD,GAC1Bq5C,IAAAA,EAAYgkB,EAAYF,EAAW,EAAKllD,EAAIgG,YAAYyxC,EAAWxtC,MAAMhE,OACrE,IAANle,GAAW+9D,EAAWA,EAAWh+D,OAAS,GAAKs5C,EAAY,EAAInqB,EAAUnM,KACzEu7C,GAAexmD,EACfimD,EAAWA,EAAWh+D,QAAUC,EAAI,EAAI,EAAI,IAAM,EAClDkhB,GAAOpJ,EACPymD,KAEJF,EAASr+D,GAAK,CAAC9B,KAAM,EAAGgjB,IAAAA,EAAKq9C,IAAAA,EAAKrgD,MAAOm7B,EAAW95B,OAAQg+C,GAC5DQ,EAAWA,EAAWh+D,OAAS,IAAMs5C,EAAYnqB,IAE9CovC,IAtrUE,CAAA,IAAA,WAyrUb,MAAA,SAASnwB,EAAagvB,EAAUE,EAAUE,GAChCh+D,IAAAA,EAAK,KACJ0Y,EAAgD1Y,EAAhD0Y,IAAK0P,EAA2CpoB,EAA3CooB,UAA8BuH,EAAa3vB,EAAhC2V,QAAUmrB,OAASnR,QACpCmvC,EAAW9+D,EAAGm+D,eAAiB,GAC/BI,EAAcv+D,EAAGu+D,YAAc,GAC/BU,EAAc72C,EAAYwmB,EAC5BswB,EAAavvC,EACbwvC,EAAkB,EAClBC,EAAmB,EACnBzgE,EAAO,EACPgjB,EAAM,EACN09C,EAAM,EAkBHH,OAjBPl/D,EAAGs+D,YAAY1+D,QAAQ,SAACuwD,EAAY1vD,GAC1Bq5C,IAAAA,EAAYgkB,EAAYF,EAAW,EAAKllD,EAAIgG,YAAYyxC,EAAWxtC,MAAMhE,MAC3Ele,EAAI,GAAK2+D,EAAmBxB,EAAW,EAAIjuC,EAAUsvC,IACrDC,GAAcC,EAAkBxvC,EAChC4uC,EAAY98D,KAAK,CAACkd,MAAOwgD,EAAiBn/C,OAAQo/C,IAClDzgE,GAAQwgE,EAAkBxvC,EAC1B0vC,IACA19C,EAAM,EACNw9C,EAAkBC,EAAmB,GAEzCD,EAAkBr/D,KAAK+B,IAAIs9D,EAAiBrlB,GAC5CslB,GAAoBxB,EAAWjuC,EAC/BmvC,EAASr+D,GAAK,CAAC9B,KAAAA,EAAMgjB,IAAAA,EAAK09C,IAAAA,EAAK1gD,MAAOm7B,EAAW95B,OAAQg+C,GACzDr8C,GAAOq8C,EAAaruC,IAExBuvC,GAAcC,EACdZ,EAAY98D,KAAK,CAACkd,MAAOwgD,EAAiBn/C,OAAQo/C,IAC3CF,IAttUE,CAAA,IAAA,iBAytUb,MAAA,WACUl/D,IAAAA,EAAK,KACP,GAACA,EAAG2V,QAAQ2b,QAAZ,CAGEsd,IAAAA,EAAc5uC,EAAG2+D,sBACAG,EAAiD9+D,EAAjEm+D,eAAiEn+D,EAAAA,EAAvC2V,QAAUrX,EAAAA,EAAAA,MAAgBqxB,EAATmR,EAAAA,OAASnR,QACvD,GAAA,KAAKc,eAAgB,CACjBuuC,IADiB,EACjBA,EAAM,EACNrgE,EAAOJ,EAAeD,EAAO0B,EAAGrB,KAAOgxB,EAAS3vB,EAAGpB,MAAQoB,EAAGw+D,WAAWQ,IACxDF,EAAAA,EAAAA,GAHA,IAGU,IAAA,EAAA,MAAA,EAAA,EAAA,KAAA,MAAA,CAApBQ,IAAAA,EAAoB,EAAA,MACvBN,IAAQM,EAAON,MACfA,EAAMM,EAAON,IACbrgE,EAAOJ,EAAeD,EAAO0B,EAAGrB,KAAOgxB,EAAS3vB,EAAGpB,MAAQoB,EAAGw+D,WAAWQ,KAE7EM,EAAO39C,KAAO3hB,EAAG2hB,IAAMitB,EAAcjf,EACrC2vC,EAAO3gE,KAAOA,EACdA,GAAQ2gE,EAAO3gD,MAAQgR,GAVN,MAAA,GAAA,EAAA,EAAA,GAAA,QAAA,EAAA,SAYlB,CACC0vC,IADD,EACCA,EAAM,EACN19C,EAAMpjB,EAAeD,EAAO0B,EAAG2hB,IAAMitB,EAAcjf,EAAS3vB,EAAG4hB,OAAS5hB,EAAGu+D,YAAYc,GAAKr/C,QAC3E8+C,EAAAA,EAAAA,GAHlB,IAG4B,IAAA,EAAA,MAAA,EAAA,EAAA,KAAA,MAAA,CAApBQ,IAAAA,EAAoB,EAAA,MACvBA,EAAOD,MAAQA,IACfA,EAAMC,EAAOD,IACb19C,EAAMpjB,EAAeD,EAAO0B,EAAG2hB,IAAMitB,EAAcjf,EAAS3vB,EAAG4hB,OAAS5hB,EAAGu+D,YAAYc,GAAKr/C,SAEhGs/C,EAAO39C,IAAMA,EACb29C,EAAO3gE,MAAQqB,EAAGrB,KAAOgxB,EACzBhO,GAAO29C,EAAOt/C,OAAS2P,GAVxB,MAAA,GAAA,EAAA,EAAA,GAAA,QAAA,EAAA,SA5uUE,CAAA,IAAA,eA2vUb,MAAA,WACW,MAA0B,QAA1B,KAAKha,QAAQ4U,UAAgD,WAA1B,KAAK5U,QAAQ4U,WA5vU9C,CAAA,IAAA,OA+vUb,MAAA,WAEQvqB,GADO,KACJ2V,QAAQ2b,QAAS,CACd5Y,IAAAA,EAFC,KAEQA,IACfmJ,GAASnJ,EAHF,MAAA,KAIJ6mD,QACHx9C,GAAWrJ,MArwUN,CAAA,IAAA,QAywUb,MAAA,WACU1Y,IASFw/D,EATEx/D,EAAK,KACK4iB,EAAsC5iB,EAA/C2V,QAAe4oD,EAAgCv+D,EAAhCu+D,YAAaC,EAAmBx+D,EAAnBw+D,WAAY9lD,EAAO1Y,EAAP0Y,IACxCpa,EAA4BskB,EAA5BtkB,MAAeq/D,EAAa/6C,EAArBke,OACR2+B,EAAeloD,GAASpF,MACxButD,EAAYzlB,GAAcr3B,EAAKs3B,IAAKl6C,EAAGrB,KAAMqB,EAAG2e,OAChD+/C,EAAYzxC,GAAO0wC,EAAUxlD,MACrBwnD,EAAsBhC,EAA7BxrD,MAAkBwd,EAAWguC,EAAXhuC,QACnBiuC,EAAWc,EAAUrmD,KACrBunD,EAAehC,EAAW,EAEhC59D,EAAGozC,YACH16B,EAAIyK,UAAYu8C,EAAUv8C,UAAU,QACpCzK,EAAI0K,aAAe,SACnB1K,EAAI4K,UAAY,GAChB5K,EAAI2K,YAAcs8C,EAClBjnD,EAAIwK,UAAYy8C,EAChBjnD,EAAIP,KAAOumD,EAAUlgD,OACqBk/C,IAAAA,EAAAA,GAAWC,EAAWC,GAAzDE,EAAAA,EAAAA,SAAUD,EAAAA,EAAAA,UAAWG,EAAAA,EAAAA,WAuCtBvtC,EAAezwB,EAAGywB,eAClBme,EAAc,KAAK+vB,sBAErBa,EADA/uC,EACS,CACLhrB,EAAGlH,EAAeD,EAAO0B,EAAGrB,KAAOgxB,EAAS3vB,EAAGpB,MAAQ4/D,EAAW,IAClEviD,EAAGjc,EAAG2hB,IAAMgO,EAAUif,EACtB/rB,KAAM,GAGD,CACLpd,EAAGzF,EAAGrB,KAAOgxB,EACb1T,EAAG1d,EAAeD,EAAO0B,EAAG2hB,IAAMitB,EAAcjf,EAAS3vB,EAAG4hB,OAAS28C,EAAY,GAAGv+C,QACpF6C,KAAM,GAGds3B,GAAsBn6C,EAAG0Y,IAAKkK,EAAKi9C,eAC7BtnD,IAAAA,EAAaylD,EAAaruC,EAChC3vB,EAAGs+D,YAAY1+D,QAAQ,SAACuwD,EAAY1vD,GAC1Bge,IAAAA,EAAY/F,EAAIgG,YAAYyxC,EAAWxtC,MAAMhE,MAC7CwE,EAAYu8C,EAAUv8C,UAAUgtC,EAAWhtC,YAAcgtC,EAAWhtC,UAAYw6C,EAAUx6C,YAC1FxE,EAAQm/C,EAAYF,EAAW,EAAKn/C,EACtChZ,EAAI+5D,EAAO/5D,EACXwW,EAAIujD,EAAOvjD,EACfyjD,EAAU/lB,SAAS35C,EAAG2e,OAClB8R,EACIhwB,EAAI,GAAKgF,EAAIkZ,EAAQgR,EAAU3vB,EAAGpB,QAClCqd,EAAIujD,EAAOvjD,GAAK1D,EAChBinD,EAAO38C,OACPpd,EAAI+5D,EAAO/5D,EAAIlH,EAAeD,EAAO0B,EAAGrB,KAAOgxB,EAAS3vB,EAAGpB,MAAQ4/D,EAAWgB,EAAO38C,QAElFpiB,EAAI,GAAKwb,EAAI1D,EAAavY,EAAG4hB,SACpCnc,EAAI+5D,EAAO/5D,EAAIA,EAAI84D,EAAYiB,EAAO38C,MAAMlE,MAAQgR,EACpD6vC,EAAO38C,OACP5G,EAAIujD,EAAOvjD,EAAI1d,EAAeD,EAAO0B,EAAG2hB,IAAMitB,EAAcjf,EAAS3vB,EAAG4hB,OAAS28C,EAAYiB,EAAO38C,MAAM7C,SAvE5F,SAAUva,EAAGwW,EAAGk0C,GAC9Bp0C,KAAAA,MAAM+hD,IAAaA,GAAY,GAAK/hD,MAAM8hD,IAAcA,EAAY,GAApE9hD,CAGJrD,EAAIsG,OACEsE,IAAAA,EAAYrP,GAAek8C,EAAW7sC,UAAW,GAQnDq6C,GAPJjlD,EAAIwK,UAAYjP,GAAek8C,EAAWjtC,UAAWu8C,GACrD/mD,EAAIo9C,QAAU7hD,GAAek8C,EAAW2F,QAAS,QACjDp9C,EAAIg6B,eAAiBz+B,GAAek8C,EAAWzd,eAAgB,GAC/Dh6B,EAAI06C,SAAWn/C,GAAek8C,EAAWiD,SAAU,SACnD16C,EAAI4K,UAAYA,EAChB5K,EAAI2K,YAAcpP,GAAek8C,EAAW9sC,YAAao8C,GACzD/mD,EAAI+5B,YAAYx+B,GAAek8C,EAAW2P,SAAU,KAChDnC,EAAUI,cAAe,CACnBgC,IAAAA,EAAc,CAChBx/C,OAAQu9C,EAAWh+D,KAAKkgE,MAAQ,EAChC3/C,WAAY8vC,EAAW9vC,WACvBC,SAAU6vC,EAAW7vC,SACrBe,YAAaiC,GAEXksC,EAAUkQ,EAAU9lB,MAAMn0C,EAAGq4D,EAAW,GAE9C79C,GAAUvH,EAAKqnD,EAAavQ,EADZvzC,EAAI2jD,OAEjB,CACGK,IAAAA,EAAUhkD,EAAInc,KAAK+B,KAAK+7D,EAAWC,GAAa,EAAG,GACzDnlD,EAAI25B,SAASqtB,EAAU7lB,WAAWp0C,EAAGq4D,GAAWmC,EAASnC,EAAUD,GACjD,IAAdv6C,GACA5K,EAAIwnD,WAAWR,EAAU7lB,WAAWp0C,EAAGq4D,GAAWmC,EAASnC,EAAUD,GAG7EnlD,EAAI0G,WA4CJ+gD,CADcT,EAAUj6D,EAAEA,GACLwW,EAAGk0C,GACxB1qD,EAAI/G,EAAOykB,EAAW1d,EAAIq4D,EAAW8B,EAAc5/D,EAAGpB,OA3CzC,SAAU6G,EAAGwW,EAAGk0C,GAC7BztC,GAAWhK,EAAKy3C,EAAWxtC,KAAMld,EAAGwW,EAAK+hD,EAAa,EAAIU,EAAW,CACjEh7C,cAAeysC,EAAWlJ,OAC1B9jC,UAAWgtC,EAAWhtC,YAyC1BM,CAASi8C,EAAUj6D,EAAEA,GAAIwW,EAAGk0C,GACxB1/B,EACA+uC,EAAO/5D,GAAKkZ,EAAQgR,EAEpB6vC,EAAOvjD,GAAK1D,IAGpBkiC,GAAqBz6C,EAAG0Y,IAAKkK,EAAKi9C,iBA/2UzB,CAAA,IAAA,YAk3Ub,MAAA,WACU7/D,IAAAA,EAAK,KACL4iB,EAAO5iB,EAAG2V,QACV+4B,EAAY9rB,EAAKimB,MACjBu3B,EAAYnzC,GAAOyhB,EAAUv2B,MAC7BkoD,EAAerzC,GAAU0hB,EAAU/e,SACrC,GAAC+e,EAAUpd,QAAX,CAGEouC,IAKFzjD,EALEyjD,EAAYzlB,GAAcr3B,EAAKs3B,IAAKl6C,EAAGrB,KAAMqB,EAAG2e,OAChDjG,EAAM1Y,EAAG0Y,IACT6R,EAAWmkB,EAAUnkB,SACrBq1C,EAAeQ,EAAU/nD,KAAO,EAChCioD,EAA6BD,EAAa1+C,IAAMi+C,EAElDjhE,EAAOqB,EAAGrB,KACV6kB,EAAWxjB,EAAG2e,MACd,GAAA,KAAK8R,eACLjN,EAAW1jB,KAAK+B,IAAL/B,MAAAA,KAAYE,EAAAA,EAAGw+D,aAC1BviD,EAAIjc,EAAG2hB,IAAM2+C,EACb3hE,EAAOJ,EAAeqkB,EAAKtkB,MAAOK,EAAMqB,EAAGpB,MAAQ4kB,OAChD,CACG4E,IAAAA,EAAYpoB,EAAGu+D,YAAY78D,OAAO,SAACC,EAAK0W,GAASvY,OAAAA,KAAK+B,IAAIF,EAAK0W,EAAK2H,SAAS,GACnF/D,EAAIqkD,EAA6B/hE,EAAeqkB,EAAKtkB,MAAO0B,EAAG2hB,IAAK3hB,EAAG4hB,OAASwG,EAAYxF,EAAKke,OAAOnR,QAAU3vB,EAAG2+D,uBAEnHl5D,IAAAA,EAAIlH,EAAegsB,EAAU5rB,EAAMA,EAAO6kB,GAChD9K,EAAIyK,UAAYu8C,EAAUv8C,UAAU9kB,EAAmBksB,IACvD7R,EAAI0K,aAAe,SACnB1K,EAAI2K,YAAcqrB,EAAUv8B,MAC5BuG,EAAIwK,UAAYwrB,EAAUv8B,MAC1BuG,EAAIP,KAAOioD,EAAU5hD,OACrBkE,GAAWhK,EAAKg2B,EAAU/rB,KAAMld,EAAGwW,EAAGmkD,MAj5U7B,CAAA,IAAA,sBAo5Ub,MAAA,WACU1xB,IAAAA,EAAY,KAAK/4B,QAAQkzB,MACzBu3B,EAAYnzC,GAAOyhB,EAAUv2B,MAC7BkoD,EAAerzC,GAAU0hB,EAAU/e,SAClC+e,OAAAA,EAAUpd,QAAU8uC,EAAU7nD,WAAa8nD,EAAargD,OAAS,IAx5U/D,CAAA,IAAA,mBA25Ub,MAAA,SAAiBva,EAAGwW,GACVjc,IACFS,EAAG8/D,EAAQC,EADTxgE,EAAK,KAEPyF,GAAAA,GAAKzF,EAAGrB,MAAQ8G,GAAKzF,EAAGpB,OAASqd,GAAKjc,EAAG2hB,KAAO1F,GAAKjc,EAAG4hB,OAEnDnhB,IADL+/D,EAAKxgE,EAAGm+D,eACH19D,EAAI,EAAGA,EAAI+/D,EAAGhgE,SAAUC,EAErBgF,GAAAA,IADJ86D,EAASC,EAAG//D,IACI9B,MAAQ8G,GAAK86D,EAAO5hE,KAAO4hE,EAAO5hD,OAAS1C,GAAKskD,EAAO5+C,KAAO1F,GAAKskD,EAAO5+C,IAAM4+C,EAAOvgD,OAC5FhgB,OAAAA,EAAGs+D,YAAY79D,GAI3B,OAAA,OAv6UE,CAAA,IAAA,cA06Ub,MAAA,SAAYmC,GACF5C,IAAAA,EAAK,KACL4iB,EAAO5iB,EAAG2V,QACZ,GAoBH8qD,SAAWlhE,EAAMqjB,GAClBrjB,GAAS,cAATA,IAAyBqjB,EAAK1J,SAAW0J,EAAK89C,SACvC,OAAA,EAEP99C,GAAAA,EAAKzJ,UAAqB,UAAT5Z,GAA6B,YAATA,GAC9B,OAAA,EAEJ,OAAA,EA3BEkhE,CAAW79D,EAAErD,KAAMqjB,GAApB,CAGE+9C,IA7WMn+D,EAAGC,EA6WTk+D,EAAc3gE,EAAG4gE,iBAAiBh+D,EAAE6C,EAAG7C,EAAEqZ,GAC3CrZ,GAAW,cAAXA,EAAErD,KAAsB,CAClB0iB,IAAAA,EAAWjiB,EAAGo+D,aACdyC,GAhXKp+D,EAgX2Bk+D,EAhXf,QAAfn+D,EAgXoByf,IAhXS,OAANxf,GAAcD,EAAEwS,eAAiBvS,EAAEuS,cAAgBxS,EAAEyS,QAAUxS,EAAEwS,OAiX5FgN,IAAa4+C,GACb5jE,GAAS2lB,EAAK89C,QAAS,CAAC99D,EAAGqf,EAAUjiB,GAAKA,GAE9CA,EAAGo+D,aAAeuC,EACdA,IAAgBE,GAChB5jE,GAAS2lB,EAAK1J,QAAS,CAACtW,EAAG+9D,EAAa3gE,GAAKA,QAE1C2gE,GACP1jE,GAAS2lB,EAAKzJ,QAAS,CAACvW,EAAG+9D,EAAa3gE,GAAKA,QA57UxC,EAAA,GA28Ub8gE,IAAAA,GAAgB,CAChBvtD,GAAI,SACJwtD,SAAU9C,GACVz/D,MAAMY,SAAAA,EAAO69D,EAAOtnD,GACVs6C,IAAAA,EAAS7wD,EAAM6wD,OAAS,IAAIgO,GAAO,CAACvlD,IAAKtZ,EAAMsZ,IAAK/C,QAAAA,EAASvW,MAAAA,IACnEwwB,GAAQM,UAAU9wB,EAAO6wD,EAAQt6C,GACjCia,GAAQC,OAAOzwB,EAAO6wD,IAE1BlU,KAAK38C,SAAAA,GACDwwB,GAAQI,UAAU5wB,EAAOA,EAAM6wD,eACxB7wD,EAAM6wD,QAEjB/jB,aAAa9sC,SAAAA,EAAO69D,EAAOtnD,GACjBs6C,IAAAA,EAAS7wD,EAAM6wD,OACrBrgC,GAAQM,UAAU9wB,EAAO6wD,EAAQt6C,GACjCs6C,EAAOt6C,QAAUA,GAErB03B,YAAYjuC,SAAAA,GACF6wD,IAAAA,EAAS7wD,EAAM6wD,OACrBA,EAAOwO,cACPxO,EAAO+Q,kBAEXC,WAAW7hE,SAAAA,EAAO5B,GACTA,EAAKyqD,QACN7oD,EAAM6wD,OAAOiR,YAAY1jE,EAAK8D,QAGtCiW,SAAU,CACN+Z,SAAS,EACT/G,SAAU,MACVjsB,MAAO,SACPkxB,UAAU,EACV/a,SAAS,EACTrC,OAAQ,IACR+G,QAAQvW,SAAAA,EAAGutD,EAAYF,GACbh7C,IAAAA,EAAQk7C,EAAWn7C,aACnBmsD,EAAKlR,EAAO7wD,MACd+hE,EAAGzb,iBAAiBzwC,IACpBksD,EAAG/mC,KAAKnlB,GACRk7C,EAAWlJ,QAAS,IAEpBka,EAAGlnC,KAAKhlB,GACRk7C,EAAWlJ,QAAS,IAG5B/tC,QAAS,KACTwnD,QAAS,KACT5/B,OAAQ,CACJ3uB,MAAO,SAACuG,GAAQA,OAAAA,EAAItZ,MAAMuW,QAAQxD,OAClC2rD,SAAU,GACVnuC,QAAS,GACTugC,eAAe9wD,SAAAA,GACLwY,IAAAA,EAAWxY,EAAMif,KAAKzG,SAC6BxY,EAAAA,EAAM6wD,OAAOt6C,QAA/DmrB,OAASi9B,EAAAA,EAAAA,cAAe19C,EAAAA,EAAAA,WAAY8C,EAAAA,EAAAA,UACpC/jB,OAAAA,EAAMw8B,yBAAyB35B,IAAI,SAACgqB,GACjC3T,IAAAA,EAAQ2T,EAAKnC,WAAWxD,SAASy3C,EAAgB,OAAI5+D,GACrDkiB,EAAc2L,GAAU1U,EAAM+I,aAC7B,MAAA,CACHsB,KAAM/K,EAASqU,EAAKhX,OAAOitB,MAC3Bhf,UAAW5K,EAAMZ,gBACjBuvC,QAASh7B,EAAKkO,QACd27B,QAASx9C,EAAMy9C,eACf+J,SAAUxnD,EAAMqwB,WAChB+J,eAAgBp6B,EAAMswB,iBACtBwqB,SAAU96C,EAAM09C,gBAChB1yC,WAAYjC,EAAY1C,MAAQ0C,EAAYrB,QAAU,EACtDqD,YAAa/K,EAAMX,YACnB0I,WAAYA,GAAc/H,EAAM+H,WAChCC,SAAUhI,EAAMgI,SAChB6C,UAAWA,GAAa7K,EAAM6K,UAC9BnO,aAAciX,EAAKhX,QAExB,QAGX4zB,MAAO,CACH12B,MAAO,SAACuG,GAAQA,OAAAA,EAAItZ,MAAMuW,QAAQxD,OAClCmf,SAAS,EACT/G,SAAU,SACV5H,KAAM,KAGd5L,YAAa,CACTsD,YAAa,SAACV,GAAS,OAACA,EAAKW,WAAW,OACxCwmB,OAAQ,CACJzmB,YAAa,SAACV,GAAS,OAAC,CAAC,iBAAkB,SAAU,QAAQi7B,SAASj7B,OAK5EynD,GAriVW,SAAA,GAAA,EAAA,EAqiVG98B,IAriVH,IAAA,EAAA,EAAA,GAsiVDhK,SAAAA,EAAAA,GAAQ,IAAA,EAAA,OAAA,EAAA,KAAA,IAChB,EAAA,EAAA,KAAA,OACKl7B,MAAQk7B,EAAOl7B,MACfuW,EAAAA,QAAU2kB,EAAO3kB,QACjB+C,EAAAA,IAAM4hB,EAAO5hB,IACb2oD,EAAAA,cAAWliE,EACXwiB,EAAAA,SAAMxiB,EACNyiB,EAAAA,YAASziB,EACTR,EAAAA,UAAOQ,EACPP,EAAAA,WAAQO,EACRwf,EAAAA,WAAQxf,EACR6gB,EAAAA,YAAS7gB,EACTorB,EAAAA,cAAWprB,EACXiT,EAAAA,YAASjT,EACTqwB,EAAAA,cAAWrwB,EAdA,EAtiVP,OAAA,EAAA,EAAA,CAAA,CAAA,IAAA,SAujVb,MAAA,SAAOqkB,EAAU4E,GACPpoB,IAAAA,EAAK,KACL4iB,EAAO5iB,EAAG2V,QAGZ,GAFJ3V,EAAGrB,KAAO,EACVqB,EAAG2hB,IAAM,EACJiB,EAAK0O,QAAN,CAIJtxB,EAAG2e,MAAQ3e,EAAGpB,MAAQ4kB,EACtBxjB,EAAGggB,OAAShgB,EAAG4hB,OAASwG,EAClB2pB,IAAAA,EAAYntC,GAAQge,EAAKD,MAAQC,EAAKD,KAAKniB,OAAS,EAC1DR,EAAGqhE,SAAWr0C,GAAUpK,EAAK+M,SACvB2xC,IAAAA,EAAWvvB,EAAY9kB,GAAOrK,EAAKzK,MAAMI,WAAavY,EAAGqhE,SAASrhD,OACpEhgB,EAAGywB,eACHzwB,EAAGggB,OAASshD,EAEZthE,EAAG2e,MAAQ2iD,OAXXthE,EAAG2e,MAAQ3e,EAAGggB,OAAShgB,EAAGpB,MAAQoB,EAAG4hB,OAAS,IA7jVzC,CAAA,IAAA,eA4kVb,MAAA,WACUnL,IAAAA,EAAM,KAAKd,QAAQ4U,SAClB9T,MAAQ,QAARA,GAAyB,WAARA,IA9kVf,CAAA,IAAA,YAilVb,MAAA,SAAU+vB,GACC7kB,IAGH6B,EAAUwvB,EAAQC,EAHftxB,EAAqC,KAArCA,IAAKhjB,EAAgC,KAAhCA,KAAMijB,EAA0B,KAA1BA,OAAQhjB,EAAkB,KAAlBA,MAAO+W,EAAW,KAAXA,QAC3BrX,EAAQqX,EAAQrX,MAClBgiB,EAAW,EAkBR,OAhBH,KAAKmQ,gBACLuiB,EAASz0C,EAAeD,EAAOK,EAAMC,GACrCq0C,EAAStxB,EAAM6kB,EACfhjB,EAAW5kB,EAAQD,IAEM,SAArBgX,EAAQ4U,UACRyoB,EAASr0C,EAAO6nC,EAChByM,EAAS10C,EAAeD,EAAOsjB,EAAQD,GACvCrB,GAAiB,GAAN7F,KAEXu4B,EAASp0C,EAAQ4nC,EACjByM,EAAS10C,EAAeD,EAAOqjB,EAAKC,GACpCtB,EAAgB,GAAL7F,IAEf+I,EAAW5B,EAASD,GAEjB,CAACqxB,OAAAA,EAAQC,OAAAA,EAAQzvB,SAAAA,EAAUlD,SAAAA,KAtmVzB,CAAA,IAAA,OAymVb,MAAA,WACUtgB,IACA0Y,EADK,KACIA,IACTkK,EAFK,KAEKjN,QACZ,GAACiN,EAAK0O,QAAN,CAGEiwC,IAAAA,EAAWt0C,GAAOrK,EAAKzK,MAEvBquB,EADa+6B,EAAShpD,WACA,EARjB,KAQwB8oD,SAAS1/C,IACC3hB,EATlC,KASqCwhE,UAAUh7B,GAAnDwM,EAAAA,EAAAA,OAAQC,EAAAA,EAAAA,OAAQzvB,EAAAA,EAAAA,SAAUlD,EAAAA,EAAAA,SACjCoC,GAAWhK,EAAKkK,EAAKD,KAAM,EAAG,EAAG4+C,EAAU,CACvCpvD,MAAOyQ,EAAKzQ,MACZqR,SAAAA,EACAlD,SAAAA,EACA6C,UAAW9kB,EAAmBukB,EAAKtkB,OACnC8kB,aAAc,SACdH,YAAa,CAAC+vB,EAAQC,UA1nVjB,EAAA,GA0oVbwuB,IAAAA,GAAe,CACfluD,GAAI,QACJwtD,SAAUK,GACV5iE,MAAMY,SAAAA,EAAO69D,EAAOtnD,IAdf+rD,SAAYtiE,EAAOsvC,GAClB7F,IAAAA,EAAQ,IAAIu4B,GAAM,CACpB1oD,IAAKtZ,EAAMsZ,IACX/C,QAAS+4B,EACTtvC,MAAAA,IAEJwwB,GAAQM,UAAU9wB,EAAOypC,EAAO6F,GAChC9e,GAAQC,OAAOzwB,EAAOypC,GACtBzpC,EAAMuiE,WAAa94B,EAOf64B,CAAYtiE,EAAOuW,IAEvBomC,KAAK38C,SAAAA,GACKuiE,IAAAA,EAAaviE,EAAMuiE,WACzB/xC,GAAQI,UAAU5wB,EAAOuiE,UAClBviE,EAAMuiE,YAEjBz1B,aAAa9sC,SAAAA,EAAO69D,EAAOtnD,GACjBkzB,IAAAA,EAAQzpC,EAAMuiE,WACpB/xC,GAAQM,UAAU9wB,EAAOypC,EAAOlzB,GAChCkzB,EAAMlzB,QAAUA,GAEpB4B,SAAU,CACNjZ,MAAO,SACPgzB,SAAS,EACTnZ,KAAM,CACFG,MAAO,QAEXkX,UAAU,EACVG,QAAS,GACTpF,SAAU,MACV5H,KAAM,GACNvQ,OAAQ,KAEZqyB,cAAe,CACXtyB,MAAO,SAEX4E,YAAa,CACTsD,aAAa,EACbE,YAAY,IAIdqnD,GAAc,CAChBC,QAAQthE,SAAAA,GACA,IAACA,EAAMC,OACA,OAAA,EAEPC,IAAAA,EAAGoR,EACHpM,EAAI,EACJwW,EAAI,EACJukB,EAAQ,EACP//B,IAAAA,EAAI,EAAGoR,EAAMtR,EAAMC,OAAQC,EAAIoR,IAAOpR,EAAG,CACpC8lB,IAAAA,EAAKhmB,EAAME,GAAG4lB,QAChBE,GAAAA,GAAMA,EAAGu7C,WAAY,CACfrrD,IAAAA,EAAM8P,EAAGw7C,kBACft8D,GAAKgR,EAAIhR,EACTwW,GAAKxF,EAAIwF,IACPukB,GAGH,MAAA,CACH/6B,EAAGA,EAAI+6B,EACPvkB,EAAGA,EAAIukB,IAGfpU,QAAQ7rB,SAAAA,EAAOyhE,GACPv8D,IAGAhF,EAAGoR,EAAKowD,EAHRx8D,EAAIu8D,EAAcv8D,EAClBwW,EAAI+lD,EAAc/lD,EAClBuP,EAAc3X,OAAOgH,kBAEpBpa,IAAAA,EAAI,EAAGoR,EAAMtR,EAAMC,OAAQC,EAAIoR,IAAOpR,EAAG,CACpC8lB,IAAAA,EAAKhmB,EAAME,GAAG4lB,QAChBE,GAAAA,GAAMA,EAAGu7C,WAAY,CACfr2C,IACA9oB,EAAI4a,GAAsBykD,EADjBz7C,EAAGmF,kBAEd/oB,EAAI6oB,IACJA,EAAc7oB,EACds/D,EAAiB17C,IAIzB07C,GAAAA,EAAgB,CACVC,IAAAA,EAAKD,EAAeF,kBAC1Bt8D,EAAIy8D,EAAGz8D,EACPwW,EAAIimD,EAAGjmD,EAEJ,MAAA,CACHxW,EAAAA,EACAwW,EAAAA,KAKHkmD,SAAAA,GAAah9C,EAAMi9C,GAQjBj9C,OAPHi9C,IACIx9D,GAAQw9D,GACR3kE,MAAMC,UAAU+D,KAAK1D,MAAMonB,EAAMi9C,GAEjCj9C,EAAK1jB,KAAK2gE,IAGXj9C,EAGFk9C,SAAAA,GAAcr9D,GACf,OAAgB,iBAARA,GAAoBA,aAAes9D,SAAWt9D,EAAIyQ,QAAQ,OAAS,EACpEzQ,EAAIkS,MAAM,MAEdlS,EAoBFu9D,SAAAA,GAAerV,EAASv3C,GACvB+C,IAAAA,EAAMw0C,EAAQ3yB,OAAO7hB,IACpB8pD,EAAuBtV,EAAvBsV,KAAMC,EAAiBvV,EAAjBuV,OAAQ55B,EAASqkB,EAATrkB,MACdi1B,EAAuBnoD,EAAvBmoD,SAAUD,EAAaloD,EAAbkoD,UACX6E,EAAWz1C,GAAOtX,EAAQ+sD,UAC1BtC,EAAYnzC,GAAOtX,EAAQyqD,WAC3BuC,EAAa11C,GAAOtX,EAAQgtD,YAC5BC,EAAiB/5B,EAAMroC,OACvBqiE,EAAkBJ,EAAOjiE,OACzBsiE,EAAoBN,EAAKhiE,OACzBmvB,EAAU3C,GAAUrX,EAAQga,SAC9B3P,EAAS2P,EAAQ3P,OACjBrB,EAAQ,EACRokD,EAAqBP,EAAK9gE,OAAO,SAAC8+B,EAAOwiC,GAAaxiC,OAAAA,EAAQwiC,EAASC,OAAOziE,OAASwiE,EAASlgD,MAAMtiB,OAASwiE,EAASE,MAAM1iE,QAAQ,IAC1IuiE,GAAsB7V,EAAQiW,WAAW3iE,OAAS0sD,EAAQkW,UAAU5iE,OAChEoiE,IACA5iD,GAAU4iD,EAAiBxC,EAAU7nD,YAC9BqqD,EAAiB,GAAKjtD,EAAQ0tD,aAC/B1tD,EAAQ2tD,mBAEdP,KAEA/iD,GAAU8iD,GADantD,EAAQ4tD,cAAgBzjE,KAAK+B,IAAIg8D,EAAW6E,EAASnqD,YAAcmqD,EAASnqD,aAE5FwqD,EAAqBD,GAAqBJ,EAASnqD,YACnDwqD,EAAqB,GAAKptD,EAAQ6tD,aAEzCX,IACA7iD,GAAUrK,EAAQ8tD,gBACZZ,EAAkBF,EAAWpqD,YAC5BsqD,EAAkB,GAAKltD,EAAQ+tD,eAEtCC,IAAAA,EAAe,EACbC,EAAe,SAAU/gD,GAC3BlE,EAAQ7e,KAAK+B,IAAI8c,EAAOjG,EAAIgG,YAAYmE,GAAMlE,MAAQglD,IAkBnD,OAhBPjrD,EAAIsG,OACJtG,EAAIP,KAAOioD,EAAU5hD,OACrBjK,GAAK24C,EAAQrkB,MAAO+6B,GACpBlrD,EAAIP,KAAOuqD,EAASlkD,OACpBjK,GAAK24C,EAAQiW,WAAWryC,OAAOo8B,EAAQkW,WAAYQ,GACnDD,EAAehuD,EAAQ4tD,cAAiBzF,EAAW,EAAK,EACxDvpD,GAAKiuD,EAAM,SAACQ,GACRzuD,GAAKyuD,EAASC,OAAQW,GACtBrvD,GAAKyuD,EAASlgD,MAAO8gD,GACrBrvD,GAAKyuD,EAASE,MAAOU,KAEzBD,EAAe,EACfjrD,EAAIP,KAAOwqD,EAAWnkD,OACtBjK,GAAK24C,EAAQuV,OAAQmB,GACrBlrD,EAAI0G,UAEG,CAACT,MADRA,GAASgR,EAAQhR,MACFqB,OAAAA,GAwBV6jD,SAAAA,GAAgBzkE,EAAOuW,EAAS0C,EAAMyrD,GACpCr+D,IAAAA,EAAY4S,EAAZ5S,EAAGkZ,EAAStG,EAATsG,MACIolD,EAAwC3kE,EAA/Cuf,MAA+Cvf,EAAAA,EAA5B0rB,UAAYnsB,EAAAA,EAAAA,KAAMC,EAAAA,EAAAA,MACxColE,EAAS,SAWNA,MAVQ,WAAXF,EACAE,EAASv+D,IAAM9G,EAAOC,GAAS,EAAI,OAAS,QACrC6G,GAAKkZ,EAAQ,EACpBqlD,EAAS,OACFv+D,GAAKs+D,EAAaplD,EAAQ,IACjCqlD,EAAS,SApBRC,SAAoBD,EAAQ5kE,EAAOuW,EAAS0C,GAC1C5S,IAAAA,EAAY4S,EAAZ5S,EAAGkZ,EAAStG,EAATsG,MACJulD,EAAQvuD,EAAQwuD,UAAYxuD,EAAQyuD,aACtCJ,MAAW,SAAXA,GAAqBv+D,EAAIkZ,EAAQulD,EAAQ9kE,EAAMuf,OAGpC,UAAXqlD,GAAsBv+D,EAAIkZ,EAAQulD,EAAQ,QAA1CF,EAgBAC,CAAoBD,EAAQ5kE,EAAOuW,EAAS0C,KAC5C2rD,EAAS,UAENA,EAGFK,SAAAA,GAAmBjlE,EAAOuW,EAAS0C,GAClCyrD,IAAAA,EAASnuD,EAAQmuD,QAvClBQ,SAAgBllE,EAAOiZ,GACrB4D,IAAAA,EAAa5D,EAAb4D,EAAG+D,EAAU3H,EAAV2H,OACN/D,OAAAA,EAAI+D,EAAS,EACN,MACA/D,EAAK7c,EAAM4gB,OAASA,EAAS,EAC7B,SAEJ,SAgC0BskD,CAAgBllE,EAAOiZ,GACjD,MAAA,CACH2rD,OAAQruD,EAAQquD,QAAUH,GAAgBzkE,EAAOuW,EAAS0C,EAAMyrD,GAChEA,OAAAA,GA0BCS,SAAAA,GAAmB5uD,EAAS0C,EAAMmsD,EAAWplE,GAC3C+kE,IAAAA,EAAyCxuD,EAAzCwuD,UAAWC,EAA8BzuD,EAA9ByuD,aAAchkD,EAAgBzK,EAAhByK,aACzB4jD,EAAkBQ,EAAlBR,OAAQF,EAAUU,EAAVV,OACTW,EAAiBN,EAAYC,EAC7BM,EAAmBtkD,EAAegkD,EACpC3+D,EA3BCk/D,SAAOtsD,EAAM2rD,GACbv+D,IAAAA,EAAY4S,EAAZ5S,EAAGkZ,EAAStG,EAATsG,MAMDlZ,MALQ,UAAXu+D,EACAv+D,GAAKkZ,EACa,WAAXqlD,IACPv+D,GAAMkZ,EAAQ,GAEXlZ,EAoBCk/D,CAAOtsD,EAAM2rD,GACf/nD,EAlBD2oD,SAAOvsD,EAAMyrD,EAAQW,GACrBxoD,IAAAA,EAAa5D,EAAb4D,EAAG+D,EAAU3H,EAAV2H,OAQD/D,MAPQ,QAAX6nD,EACA7nD,GAAKwoD,EAELxoD,GADkB,WAAX6nD,EACF9jD,EAASykD,EAERzkD,EAAS,EAEZ/D,EASG2oD,CAAOvsD,EAAMyrD,EAAQW,GAYxB,MAXQ,WAAXX,EACe,SAAXE,EACAv+D,GAAKg/D,EACa,UAAXT,IACPv+D,GAAKg/D,GAES,SAAXT,EACPv+D,GAAKi/D,EACa,UAAXV,IACPv+D,GAAKi/D,GAEF,CACHj/D,EAAGwY,GAAYxY,EAAG,EAAGrG,EAAMuf,MAAQtG,EAAKsG,OACxC1C,EAAGgC,GAAYhC,EAAG,EAAG7c,EAAM4gB,OAAS3H,EAAK2H,SAIxC6kD,SAAAA,GAAY3X,EAAS5uD,EAAOqX,GAC3Bga,IAAAA,EAAU3C,GAAUrX,EAAQga,SAC3BrxB,MAAU,WAAVA,EACD4uD,EAAQznD,EAAIynD,EAAQvuC,MAAQ,EAClB,UAAVrgB,EACI4uD,EAAQznD,EAAIynD,EAAQvuC,MAAQgR,EAAQ/wB,MACpCsuD,EAAQznD,EAAIkqB,EAAQhxB,KAGzBmmE,SAAAA,GAAwB7nE,GACtBklE,OAAAA,GAAa,GAAIE,GAAcplE,IAWjC8nE,SAAAA,GAAkBvlE,EAAWsY,GAC5Bu9B,IAAAA,EAAWv9B,GAAWA,EAAQoU,SAAWpU,EAAQoU,QAAQghC,SAAWp1C,EAAQoU,QAAQghC,QAAQ1tD,UAC3F61C,OAAAA,EAAW71C,EAAU61C,SAASA,GAAY71C,EAG/CwlE,IAAAA,GAj7VW,SAAA,GAAA,EAAA,EAi7VK1gC,IAj7VL,IAAA,EAAA,EAAA,GAk7VDhK,SAAAA,EAAAA,GAAQ,IAAA,EAAA,OAAA,EAAA,KAAA,IAChB,EAAA,EAAA,KAAA,OACK2qC,QAAU,EACVrkE,EAAAA,QAAU,GACV25B,EAAAA,OAASD,EAAOC,OAChB2qC,EAAAA,oBAAiB/lE,EACjBgmE,EAAAA,WAAQhmE,EACRimE,EAAAA,uBAAoBjmE,EACpBkmE,EAAAA,cAAgB,GAChBrqC,EAAAA,iBAAc77B,EACdk/B,EAAAA,cAAWl/B,EACXwW,EAAAA,QAAU2kB,EAAO3kB,QACjB2vD,EAAAA,gBAAanmE,EACb0pC,EAAAA,WAAQ1pC,EACRgkE,EAAAA,gBAAahkE,EACbqjE,EAAAA,UAAOrjE,EACPikE,EAAAA,eAAYjkE,EACZsjE,EAAAA,YAAStjE,EACT6kE,EAAAA,YAAS7kE,EACT2kE,EAAAA,YAAS3kE,EACTsG,EAAAA,OAAItG,EACJ8c,EAAAA,OAAI9c,EACJ6gB,EAAAA,YAAS7gB,EACTwf,EAAAA,WAAQxf,EACRomE,EAAAA,YAASpmE,EACTqmE,EAAAA,YAASrmE,EACTsmE,EAAAA,iBAActmE,EACdumE,EAAAA,sBAAmBvmE,EACnBwmE,EAAAA,qBAAkBxmE,EA5BP,EAl7VP,OAAA,EAAA,EAAA,CAAA,CAAA,IAAA,aAi9Vb,MAAA,SAAWwW,GACFA,KAAAA,QAAUA,EACVyvD,KAAAA,uBAAoBjmE,EACpBk/B,KAAAA,cAAWl/B,IAp9VP,CAAA,IAAA,qBAu9Vb,MAAA,WACUa,IAAAA,EAAK,KACLw9B,EAASx9B,EAAGolE,kBACd5nC,GAAAA,EACOA,OAAAA,EAELp+B,IAAAA,EAAQY,EAAGu6B,OACX5kB,EAAU3V,EAAG2V,QAAQ27B,WAAWtxC,EAAG6f,cACnC+C,EAAOjN,EAAQsxB,SAAW7nC,EAAMuW,QAAQ8B,WAAa9B,EAAQukB,WAC7DA,EAAa,IAAIG,GAAWr6B,EAAGu6B,OAAQ3X,GAItCsX,OAHHtX,EAAK2gB,aACLvjC,EAAGolE,kBAAoB10D,OAAO6gB,OAAO2I,IAElCA,IAp+VE,CAAA,IAAA,aAu+Vb,MAAA,WACUl6B,IApEgB6lB,EAAQqnC,EAAS0Y,EAoEjC5lE,EAAK,KACJA,OAAAA,EAAGq+B,WACLr+B,EAAGq+B,UAtEcxY,EAsEkB7lB,EAAGu6B,OAAO1a,aAtEpBqtC,EAsEkCltD,EAtEzB4lE,EAsE6B5lE,EAAGqlE,cArEpE30D,OAAOW,OAAOX,OAAO2E,OAAOwQ,GAAS,CACxCqnC,QAAAA,EACA0Y,aAAAA,EACArmE,KAAM,gBAx6VG,CAAA,IAAA,WA6+Vb,MAAA,SAASuY,EAASnC,GACR3V,IACCR,EAAamW,EAAbnW,UACDqmE,EAAcrmE,EAAUqmE,YAAY9nE,MAF/B,KAEyC,CAAC+Z,IAC/C+wB,EAAQrpC,EAAUqpC,MAAM9qC,MAHnB,KAG6B,CAAC+Z,IACnCguD,EAAatmE,EAAUsmE,WAAW/nE,MAJ7B,KAIuC,CAAC+Z,IAC/CgL,EAAQ,GAILA,OAHPA,EAAQq/C,GAAar/C,EAAOu/C,GAAcwD,IAC1C/iD,EAAQq/C,GAAar/C,EAAOu/C,GAAcx5B,IAC1C/lB,EAAQq/C,GAAar/C,EAAOu/C,GAAcyD,MAt/VjC,CAAA,IAAA,gBA0/Vb,MAAA,SAAcF,EAAcjwD,GACjBmvD,OAAAA,GAAwBnvD,EAAQnW,UAAU2jE,WAAWplE,MAAM,KAAM,CAAC6nE,OA3/VhE,CAAA,IAAA,UA8/Vb,MAAA,SAAQA,EAAcjwD,GACZ3V,IAAAA,EAAK,KACJR,EAAamW,EAAbnW,UACDumE,EAAY,GAaXA,OAZPxxD,GAAKqxD,EAAc,SAAC9tD,GACVkrD,IAAAA,EAAW,CACbC,OAAQ,GACRngD,MAAO,GACPogD,MAAO,IAEL8C,EAASjB,GAAkBvlE,EAAWsY,GAC5CqqD,GAAaa,EAASC,OAAQZ,GAAc2D,EAAOC,YAAYroE,KAAKoC,EAAI8X,KACxEqqD,GAAaa,EAASlgD,MAAOkjD,EAAO9jC,MAAMtkC,KAAKoC,EAAI8X,IACnDqqD,GAAaa,EAASE,MAAOb,GAAc2D,EAAOE,WAAWtoE,KAAKoC,EAAI8X,KACtEiuD,EAAUtkE,KAAKuhE,KAEZ+C,IA9gWE,CAAA,IAAA,eAihWb,MAAA,SAAaH,EAAcjwD,GAChBmvD,OAAAA,GAAwBnvD,EAAQnW,UAAU4jE,UAAUrlE,MAAM,KAAM,CAAC6nE,OAlhW/D,CAAA,IAAA,YAqhWb,MAAA,SAAUA,EAAcjwD,GACd3V,IACCR,EAAamW,EAAbnW,UACD2mE,EAAe3mE,EAAU2mE,aAAapoE,MAFjC,KAE2C,CAAC6nE,IACjDnD,EAASjjE,EAAUijE,OAAO1kE,MAHrB,KAG+B,CAAC6nE,IACrCQ,EAAc5mE,EAAU4mE,YAAYroE,MAJ/B,KAIyC,CAAC6nE,IACjD9iD,EAAQ,GAILA,OAHPA,EAAQq/C,GAAar/C,EAAOu/C,GAAc8D,IAC1CrjD,EAAQq/C,GAAar/C,EAAOu/C,GAAcI,IAC1C3/C,EAAQq/C,GAAar/C,EAAOu/C,GAAc+D,MA9hWjC,CAAA,IAAA,eAkiWb,MAAA,SAAazwD,GACH3V,IAOFS,EAAGoR,EAtTYzS,EAAOsB,EACvB2lB,EAASrR,EAAcC,EACxB6U,EACiBA,EAAhBoY,EAAOnvB,EA4SJ/S,EAAK,KACLg6B,EAASh6B,EAAGY,QACZyd,EAAOre,EAAGu6B,OAAOlc,KACjBonD,EAAc,GACdC,EAAmB,GACnBC,EAAkB,GACpBC,EAAe,GAEdnlE,IAAAA,EAAI,EAAGoR,EAAMmoB,EAAOx5B,OAAQC,EAAIoR,IAAOpR,EACxCmlE,EAAankE,MAxTErC,EAwTqBY,EAAGu6B,OAxTjB75B,EAwTyBs5B,EAAOv5B,GAvTvD4lB,OAAAA,EAASrR,OAAAA,EAAcC,OAAAA,EACxB6U,OAAAA,EACiBA,OAAAA,EAAhBoY,OAAAA,EAAOnvB,OAAAA,EAFPsT,EAAgC3lB,EAAhC2lB,QAASrR,EAAuBtU,EAAvBsU,aAAcC,EAASvU,EAATuU,MACxB6U,EAAa1qB,EAAM+sB,eAAenX,GAAc8U,WAC/BA,EAAAA,EAAWu8C,iBAAiBpxD,GAA5CitB,EAAAA,EAAAA,MAAOnvB,EAAAA,EAAAA,MACP,CACH3T,MAAAA,EACA8iC,MAAAA,EACAxF,OAAQ5S,EAAWmY,UAAUhtB,GAC7B0tB,IAAKvjC,EAAMif,KAAKzG,SAAS5C,GAAcqJ,KAAKpJ,GAC5Cs7C,eAAgBx9C,EAChBmZ,QAASpC,EAAW4U,aACpBgE,UAAWztB,EACXD,aAAAA,EACAqR,QAAAA,KA6TOu/C,OAhBHjwD,EAAQiY,SACRg4C,EAAeA,EAAah4C,OAAO,SAACvH,EAASpR,EAAOsH,GAAU5G,OAAAA,EAAQiY,OAAOvH,EAASpR,EAAOsH,EAAO8B,MAEpG1I,EAAQ2wD,WACRV,EAAeA,EAAa/pD,KAAK,SAACrZ,EAAGC,GAAMkT,OAAAA,EAAQ2wD,SAAS9jE,EAAGC,EAAG4b,MAEtE9J,GAAKqxD,EAAc,SAAC9tD,GACVkuD,IAAAA,EAASjB,GAAkBpvD,EAAQnW,UAAWsY,GACpD2tD,EAAYhkE,KAAKukE,EAAOO,WAAW3oE,KAAKoC,EAAI8X,IAC5C4tD,EAAiBjkE,KAAKukE,EAAOQ,gBAAgB5oE,KAAKoC,EAAI8X,IACtD6tD,EAAgBlkE,KAAKukE,EAAOS,eAAe7oE,KAAKoC,EAAI8X,MAExD9X,EAAGylE,YAAcA,EACjBzlE,EAAG0lE,iBAAmBA,EACtB1lE,EAAG2lE,gBAAkBA,EACrB3lE,EAAGslE,WAAaM,EACTA,IA9jWE,CAAA,IAAA,SAikWb,MAAA,SAAOt2C,EAAS24B,GACNjoD,IAGF85B,EAHE95B,EAAK,KACL2V,EAAU3V,EAAG2V,QAAQ27B,WAAWtxC,EAAG6f,cACnCma,EAASh6B,EAAGY,QAEdglE,EAAe,GACf,GAAC5rC,EAAOx5B,OAML,CACG+pB,IAAAA,EAAWq3C,GAAYjsD,EAAQ4U,UAAU3sB,KAAKoC,EAAIg6B,EAAQh6B,EAAGklE,gBACnEU,EAAe5lE,EAAG0mE,aAAa/wD,GAC/B3V,EAAG6oC,MAAQ7oC,EAAG2mE,SAASf,EAAcjwD,GACrC3V,EAAGmjE,WAAanjE,EAAG4mE,cAAchB,EAAcjwD,GAC/C3V,EAAGwiE,KAAOxiE,EAAG6mE,QAAQjB,EAAcjwD,GACnC3V,EAAGojE,UAAYpjE,EAAG8mE,aAAalB,EAAcjwD,GAC7C3V,EAAGyiE,OAASziE,EAAG+mE,UAAUnB,EAAcjwD,GACjC0C,IAAAA,EAAOrY,EAAGmlE,MAAQ5C,GAAeviE,EAAI2V,GACrCqxD,EAAkBt2D,OAAOW,OAAO,GAAIkZ,EAAUlS,GAC9CmsD,EAAYH,GAAmBrkE,EAAGu6B,OAAQ5kB,EAASqxD,GACnDC,EAAkB1C,GAAmB5uD,EAASqxD,EAAiBxC,EAAWxkE,EAAGu6B,QACnFv6B,EAAGgkE,OAASQ,EAAUR,OACtBhkE,EAAG8jE,OAASU,EAAUV,OACtBhqC,EAAa,CACTmrC,QAAS,EACTx/D,EAAGwhE,EAAgBxhE,EACnBwW,EAAGgrD,EAAgBhrD,EACnB0C,MAAOtG,EAAKsG,MACZqB,OAAQ3H,EAAK2H,OACbulD,OAAQh7C,EAAS9kB,EACjB+/D,OAAQj7C,EAAStO,QA1BF,IAAfjc,EAAGilE,UACHnrC,EAAa,CACTmrC,QAAS,IA2BrBjlE,EAAGqlE,cAAgBO,EACnB5lE,EAAGq+B,cAAWl/B,EACV26B,GACA95B,EAAG0jC,qBAAqBnU,OAAOvvB,EAAI85B,GAEnCxK,GAAW3Z,EAAQuxD,UACnBvxD,EAAQuxD,SAAStpE,KAAKoC,EAAI,CAACZ,MAAOY,EAAGu6B,OAAQ2yB,QAASltD,EAAIioD,OAAAA,MA3mWrD,CAAA,IAAA,YA+mWb,MAAA,SAAUkf,EAAczuD,EAAKL,EAAM1C,GACzByxD,IAAAA,EAAgB,KAAKC,iBAAiBF,EAAc9uD,EAAM1C,GAChE+C,EAAIuI,OAAOmmD,EAAcr2B,GAAIq2B,EAAcp2B,IAC3Ct4B,EAAIuI,OAAOmmD,EAAcn2B,GAAIm2B,EAAcl2B,IAC3Cx4B,EAAIuI,OAAOmmD,EAAcE,GAAIF,EAAcG,MAnnWlC,CAAA,IAAA,mBAsnWb,MAAA,SAAiBJ,EAAc9uD,EAAM1C,GAC1BquD,IAIHjzB,EAAIE,EAAIq2B,EAAIt2B,EAAIE,EAAIq2B,EAJjBvD,EAAkB,KAAlBA,OAAQF,EAAU,KAAVA,OACR1jD,EAA2BzK,EAA3ByK,aAAc+jD,EAAaxuD,EAAbwuD,UACXqD,EAAeL,EAAlB1hE,EAAWgiE,EAAON,EAAVlrD,EACR0C,EAAiBtG,EAAjBsG,MAAOqB,EAAU3H,EAAV2H,OAqCP,MAnCQ,WAAX8jD,GACA5yB,EAAKu2B,EAAOznD,EAAS,EACN,SAAXgkD,GAEA/yB,GADAF,EAAKy2B,GACKrD,EACVnzB,EAAKE,EAAKizB,EACVoD,EAAKr2B,EAAKizB,IAGVlzB,GADAF,EAAKy2B,EAAM7oD,GACDwlD,EACVnzB,EAAKE,EAAKizB,EACVoD,EAAKr2B,EAAKizB,GAEdmD,EAAKv2B,IAGDE,EADW,SAAX+yB,EACKwD,EAAMpnD,EAAgB+jD,EACT,UAAXH,EACFwD,EAAM7oD,EAAQyB,EAAe+jD,EAE7B,KAAKoB,OAEC,QAAXzB,GAEA5yB,GADAF,EAAKy2B,GACKtD,EACVpzB,EAAKE,EAAKkzB,EACVmD,EAAKr2B,EAAKkzB,IAGVjzB,GADAF,EAAKy2B,EAAMznD,GACDmkD,EACVpzB,EAAKE,EAAKkzB,EACVmD,EAAKr2B,EAAKkzB,GAEdoD,EAAKv2B,GAEF,CAACD,GAAAA,EAAIE,GAAAA,EAAIq2B,GAAAA,EAAIt2B,GAAAA,EAAIE,GAAAA,EAAIq2B,GAAAA,KA/pWnB,CAAA,IAAA,YAkqWb,MAAA,SAAU7uB,EAAIhgC,EAAK/C,GACT3V,IAGFogE,EAAWiD,EAAc5iE,EAFvBooC,EADK,KACMA,MACXroC,EAASqoC,EAAMroC,OAEjBA,GAAAA,EAAQ,CACFk/D,IAAAA,EAAYzlB,GAActkC,EAAQukC,IALjC,KAKyCz0C,EALzC,KAK+CkZ,OAQjDle,IAPLi4C,EAAGjzC,EAAIo/D,GANA,KAMgBlvD,EAAQ40B,WAAY50B,GAC3C+C,EAAIyK,UAAYu8C,EAAUv8C,UAAUxN,EAAQ40B,YAC5C7xB,EAAI0K,aAAe,SACnBg9C,EAAYnzC,GAAOtX,EAAQyqD,WAC3BiD,EAAe1tD,EAAQ0tD,aACvB3qD,EAAIwK,UAAYvN,EAAQ+xD,WACxBhvD,EAAIP,KAAOioD,EAAU5hD,OAChB/d,EAAI,EAAGA,EAAID,IAAUC,EACtBiY,EAAI+K,SAASolB,EAAMpoC,GAAIi/D,EAAUj6D,EAAEizC,EAAGjzC,GAAIizC,EAAGz8B,EAAImkD,EAAU7nD,WAAa,GACxEmgC,EAAGz8B,GAAKmkD,EAAU7nD,WAAa8qD,EAC3B5iE,EAAI,IAAMD,IACVk4C,EAAGz8B,GAAKtG,EAAQ2tD,kBAAoBD,MAprWvC,CAAA,IAAA,gBA0rWb,MAAA,SAAc3qD,EAAKggC,EAAIj4C,EAAGi/D,EAAW/pD,GAC3B3V,IACAylE,EADK,KACYA,YAAYhlE,GAC7B+lE,EAFK,KAEgBd,iBAAiBjlE,GACrCo9D,EAAuBloD,EAAvBkoD,UAAWC,EAAYnoD,EAAZmoD,SACZ4E,EAAWz1C,GAAOtX,EAAQ+sD,UAC1BiF,EAAS9C,GALJ,KAKoB,OAAQlvD,GACjCiyD,EAAYlI,EAAUj6D,EAAEkiE,GACxBE,EAAUhK,EAAY6E,EAASnqD,YAAcmqD,EAASnqD,WAAaslD,GAAa,EAAI,EACpFiK,EAASpvB,EAAGz8B,EAAI4rD,EAClBlyD,GAAAA,EAAQooD,cAAe,CACjBgC,IAAAA,EAAc,CAChBx/C,OAAQzgB,KAAKC,IAAI+9D,EAAUD,GAAa,EACxCx9C,WAAYmmD,EAAgBnmD,WAC5BC,SAAUkmD,EAAgBlmD,SAC1Be,YAAa,GAEXmuC,EAAUkQ,EAAU7lB,WAAW+tB,EAAW9J,GAAYA,EAAW,EACjErO,EAAUqY,EAASjK,EAAY,EACrCnlD,EAAI2K,YAAc1N,EAAQoyD,mBAC1BrvD,EAAIwK,UAAYvN,EAAQoyD,mBACxB9nD,GAAUvH,EAAKqnD,EAAavQ,EAASC,GACrC/2C,EAAI2K,YAAcoiD,EAAY9tD,YAC9Be,EAAIwK,UAAYuiD,EAAY/tD,gBAC5BuI,GAAUvH,EAAKqnD,EAAavQ,EAASC,QAErC/2C,EAAIwK,UAAYvN,EAAQoyD,mBACxBrvD,EAAI25B,SAASqtB,EAAU7lB,WAAW+tB,EAAW9J,GAAWgK,EAAQhK,EAAUD,GAC1EnlD,EAAI4K,UAAY,EAChB5K,EAAI2K,YAAcoiD,EAAY9tD,YAC9Be,EAAIwnD,WAAWR,EAAU7lB,WAAW+tB,EAAW9J,GAAWgK,EAAQhK,EAAUD,GAC5EnlD,EAAIwK,UAAYuiD,EAAY/tD,gBAC5BgB,EAAI25B,SAASqtB,EAAU7lB,WAAW6lB,EAAU9lB,MAAMguB,EAAW,GAAI9J,EAAW,GAAIgK,EAAS,EAAGhK,EAAW,EAAGD,EAAY,GAE1HnlD,EAAIwK,UAjCO,KAiCQyiD,gBAAgBllE,KA5tW1B,CAAA,IAAA,WA+tWb,MAAA,SAASi4C,EAAIhgC,EAAK/C,GACR3V,IAYFgjE,EAAUgF,EAAWllD,EAAOriB,EAAG6P,EAAGuE,EAAMoK,EAZtCjf,EAAK,KACJwiE,EAAQxiE,EAARwiE,KACAgB,EAA8D7tD,EAA9D6tD,YAAayE,EAAiDtyD,EAAjDsyD,UAAW1E,EAAsC5tD,EAAtC4tD,cAAe1F,EAAuBloD,EAAvBkoD,UAAWC,EAAYnoD,EAAZmoD,SACnD4E,EAAWz1C,GAAOtX,EAAQ+sD,UAC5BwF,EAAiBxF,EAASnqD,WAC1B4vD,EAAe,EACbzI,EAAYzlB,GAActkC,EAAQukC,IAAKl6C,EAAGyF,EAAGzF,EAAG2e,OAChDypD,EAAiB,SAAUvlD,GAC7BnK,EAAI+K,SAASZ,EAAM68C,EAAUj6D,EAAEizC,EAAGjzC,EAAI0iE,GAAezvB,EAAGz8B,EAAIisD,EAAiB,GAC7ExvB,EAAGz8B,GAAKisD,EAAiB1E,GAEvB6E,EAA0B3I,EAAUv8C,UAAU8kD,GAW/CxnE,IATLiY,EAAIyK,UAAY8kD,EAChBvvD,EAAI0K,aAAe,SACnB1K,EAAIP,KAAOuqD,EAASlkD,OACpBk6B,EAAGjzC,EAAIo/D,GAAY7kE,EAAIqoE,EAAyB1yD,GAChD+C,EAAIwK,UAAYvN,EAAQ2yD,UACxB/zD,GAAKvU,EAAGmjE,WAAYiF,GACpBD,EAAe5E,GAA6C,UAA5B8E,EACZ,WAAdJ,EAA0BnK,EAAW,EAAI,EAAMA,EAAW,EAC1D,EACDr9D,EAAI,EAAGoU,EAAO2tD,EAAKhiE,OAAQC,EAAIoU,IAAQpU,EAAG,CAUtC6P,IATL0yD,EAAWR,EAAK/hE,GAChBunE,EAAYhoE,EAAG2lE,gBAAgBllE,GAC/BiY,EAAIwK,UAAY8kD,EAChBzzD,GAAKyuD,EAASC,OAAQmF,GACtBtlD,EAAQkgD,EAASlgD,MACbygD,GAAiBzgD,EAAMtiB,SACvBR,EAAGuoE,cAAc7vD,EAAKggC,EAAIj4C,EAAGi/D,EAAW/pD,GACxCuyD,EAAiBpoE,KAAK+B,IAAI6gE,EAASnqD,WAAYslD,IAE9CvtD,EAAI,EAAG2O,EAAO6D,EAAMtiB,OAAQ8P,EAAI2O,IAAQ3O,EACzC83D,EAAetlD,EAAMxS,IACrB43D,EAAiBxF,EAASnqD,WAE9BhE,GAAKyuD,EAASE,MAAOkF,GAEzBD,EAAe,EACfD,EAAiBxF,EAASnqD,WAC1BhE,GAAKvU,EAAGojE,UAAWgF,GACnB1vB,EAAGz8B,GAAKunD,IAzwWC,CAAA,IAAA,aA4wWb,MAAA,SAAW9qB,EAAIhgC,EAAK/C,GACV3V,IAGF2iE,EAAYliE,EAFVgiE,EADK,KACOA,OACZjiE,EAASiiE,EAAOjiE,OAElBA,GAAAA,EAAQ,CACFk/D,IAAAA,EAAYzlB,GAActkC,EAAQukC,IALjC,KAKyCz0C,EALzC,KAK+CkZ,OAQjDle,IAPLi4C,EAAGjzC,EAAIo/D,GANA,KAMgBlvD,EAAQ6yD,YAAa7yD,GAC5C+iC,EAAGz8B,GAAKtG,EAAQ8tD,gBAChB/qD,EAAIyK,UAAYu8C,EAAUv8C,UAAUxN,EAAQ6yD,aAC5C9vD,EAAI0K,aAAe,SACnBu/C,EAAa11C,GAAOtX,EAAQgtD,YAC5BjqD,EAAIwK,UAAYvN,EAAQ8yD,YACxB/vD,EAAIP,KAAOwqD,EAAWnkD,OACjB/d,EAAI,EAAGA,EAAID,IAAUC,EACtBiY,EAAI+K,SAASg/C,EAAOhiE,GAAIi/D,EAAUj6D,EAAEizC,EAAGjzC,GAAIizC,EAAGz8B,EAAI0mD,EAAWpqD,WAAa,GAC1EmgC,EAAGz8B,GAAK0mD,EAAWpqD,WAAa5C,EAAQ+tD,iBA5xWvC,CAAA,IAAA,iBAiyWb,MAAA,SAAehrB,EAAIhgC,EAAKgwD,EAAa/yD,GAC1BquD,IAAAA,EAAkB,KAAlBA,OAAQF,EAAU,KAAVA,OACRr+D,EAAQizC,EAARjzC,EAAGwW,EAAKy8B,EAALz8B,EACH0C,EAAiB+pD,EAAjB/pD,MAAOqB,EAAU0oD,EAAV1oD,OACRO,EAAS5K,EAAQyK,aACvB1H,EAAIwK,UAAYvN,EAAQ+B,gBACxBgB,EAAI2K,YAAc1N,EAAQgC,YAC1Be,EAAI4K,UAAY3N,EAAQ0L,YACxB3I,EAAIiI,YACJjI,EAAIoI,OAAOrb,EAAI8a,EAAQtE,GACR,QAAX6nD,GACK6E,KAAAA,UAAUjwB,EAAIhgC,EAAKgwD,EAAa/yD,GAEzC+C,EAAIuI,OAAOxb,EAAIkZ,EAAQ4B,EAAQtE,GAC/BvD,EAAIkwD,iBAAiBnjE,EAAIkZ,EAAO1C,EAAGxW,EAAIkZ,EAAO1C,EAAIsE,GACnC,WAAXujD,GAAkC,UAAXE,GAClB2E,KAAAA,UAAUjwB,EAAIhgC,EAAKgwD,EAAa/yD,GAEzC+C,EAAIuI,OAAOxb,EAAIkZ,EAAO1C,EAAI+D,EAASO,GACnC7H,EAAIkwD,iBAAiBnjE,EAAIkZ,EAAO1C,EAAI+D,EAAQva,EAAIkZ,EAAQ4B,EAAQtE,EAAI+D,GACrD,WAAX8jD,GACK6E,KAAAA,UAAUjwB,EAAIhgC,EAAKgwD,EAAa/yD,GAEzC+C,EAAIuI,OAAOxb,EAAI8a,EAAQtE,EAAI+D,GAC3BtH,EAAIkwD,iBAAiBnjE,EAAGwW,EAAI+D,EAAQva,EAAGwW,EAAI+D,EAASO,GACrC,WAAXujD,GAAkC,SAAXE,GAClB2E,KAAAA,UAAUjwB,EAAIhgC,EAAKgwD,EAAa/yD,GAEzC+C,EAAIuI,OAAOxb,EAAGwW,EAAIsE,GAClB7H,EAAIkwD,iBAAiBnjE,EAAGwW,EAAGxW,EAAI8a,EAAQtE,GACvCvD,EAAImI,YACJnI,EAAI0I,OACAzL,EAAQ0L,YAAc,GACtB3I,EAAI4I,WAl0WC,CAAA,IAAA,yBAs0Wb,MAAA,SAAuB3L,GACb3V,IAAAA,EAAK,KACLZ,EAAQY,EAAGu6B,OACXl7B,EAAQW,EAAGg7B,YACX6tC,EAAQxpE,GAASA,EAAMoG,EACvBqjE,EAAQzpE,GAASA,EAAM4c,EACzB4sD,GAAAA,GAASC,EAAO,CACVv+C,IAAAA,EAAWq3C,GAAYjsD,EAAQ4U,UAAU3sB,KAAKoC,EAAIA,EAAGY,QAASZ,EAAGklE,gBACnE,IAAC36C,EACD,OAEElS,IAAAA,EAAOrY,EAAGmlE,MAAQ5C,GAAeviE,EAAI2V,GACrCqxD,EAAkBt2D,OAAOW,OAAO,GAAIkZ,EAAUvqB,EAAGmlE,OACjDX,EAAYH,GAAmBjlE,EAAOuW,EAASqxD,GAC/CxlD,EAAQ+iD,GAAmB5uD,EAASqxD,EAAiBxC,EAAWplE,GAClEypE,EAAMzvC,MAAQ5X,EAAM/b,GAAKqjE,EAAM1vC,MAAQ5X,EAAMvF,IAC7Cjc,EAAGgkE,OAASQ,EAAUR,OACtBhkE,EAAG8jE,OAASU,EAAUV,OACtB9jE,EAAG2e,MAAQtG,EAAKsG,MAChB3e,EAAGggB,OAAS3H,EAAK2H,OACjBhgB,EAAGulE,OAASh7C,EAAS9kB,EACrBzF,EAAGwlE,OAASj7C,EAAStO,EACrBjc,EAAG0jC,qBAAqBnU,OAAOvvB,EAAIwhB,OA51WlC,CAAA,IAAA,OAi2Wb,MAAA,SAAK9I,GACK1Y,IAAAA,EAAK,KACL2V,EAAU3V,EAAG2V,QAAQ27B,WAAWtxC,EAAG6f,cACrColD,EAAUjlE,EAAGilE,QACb,GAACA,EAAD,CAGJjlE,EAAG+oE,uBAAuBpzD,GACpB+yD,IAAAA,EAAc,CAChB/pD,MAAO3e,EAAG2e,MACVqB,OAAQhgB,EAAGggB,QAET04B,EAAK,CACPjzC,EAAGzF,EAAGyF,EACNwW,EAAGjc,EAAGic,GAEVgpD,EAAUnlE,KAAKqc,IAAI8oD,GAAW,KAAO,EAAIA,EACnCt1C,IAAAA,EAAU3C,GAAUrX,EAAQga,SAC5Bq5C,EAAoBhpE,EAAG6oC,MAAMroC,QAAUR,EAAGmjE,WAAW3iE,QAAUR,EAAGwiE,KAAKhiE,QAAUR,EAAGojE,UAAU5iE,QAAUR,EAAGyiE,OAAOjiE,OACpHmV,EAAQsxB,SAAW+hC,IACnBtwD,EAAIsG,OACJtG,EAAIuwD,YAAchE,EAClBjlE,EAAGkzC,eAAewF,EAAIhgC,EAAKgwD,EAAa/yD,GACxCwkC,GAAsBzhC,EAAK/C,EAAQkqD,eACnCnnB,EAAGz8B,GAAK0T,EAAQhO,IAChB3hB,EAAGozC,UAAUsF,EAAIhgC,EAAK/C,GACtB3V,EAAGkpE,SAASxwB,EAAIhgC,EAAK/C,GACrB3V,EAAGmpE,WAAWzwB,EAAIhgC,EAAK/C,GACvB8kC,GAAqB/hC,EAAK/C,EAAQkqD,eAClCnnD,EAAI0G,cA93WC,CAAA,IAAA,oBAk4Wb,MAAA,WACW,OAAA,KAAKxe,SAAW,KAn4Wd,CAAA,IAAA,oBAs4Wb,MAAA,SAAkBinD,EAAgBma,GACxBhiE,IAAAA,EAAK,KACL8nD,EAAa9nD,EAAGY,QAChBo5B,EAAS6tB,EAAe5lD,IAAI,SAA2B,GAAzB+S,IAAAA,EAAAA,EAAAA,aAAcC,EAAAA,EAAAA,MACxCgX,EAAOjsB,EAAGu6B,OAAOpO,eAAenX,GAClC,IAACiX,EACK,MAAA,IAAIypB,MAAM,kCAAoC1gC,GAEjD,MAAA,CACHA,aAAAA,EACAqR,QAAS4F,EAAK5N,KAAKpJ,GACnBA,MAAAA,KAGFqa,GAAW5a,GAAeozC,EAAY9tB,GACtCovC,EAAkBppE,EAAGqpE,iBAAiBrvC,EAAQgoC,IAChD1yC,GAAW85C,KACXppE,EAAGY,QAAUo5B,EACbh6B,EAAGklE,eAAiBlD,EACpBhiE,EAAGuvB,QAAO,MAz5WL,CAAA,IAAA,cA65Wb,MAAA,SAAY3sB,EAAGqlD,GACLjoD,IAGFsvB,EAHEtvB,EAAK,KACL2V,EAAU3V,EAAG2V,QACbmyC,EAAa9nD,EAAGY,SAAW,GAE7Bo5B,EAAS,GACE,aAAXp3B,EAAErD,OACFy6B,EAASh6B,EAAGu6B,OAAOiuB,0BAA0B5lD,EAAG+S,EAAQoD,KAAMpD,EAASsyC,GACnEtyC,EAAQlB,SACRulB,EAAOvlB,WAGT20D,IAAAA,EAAkBppE,EAAGqpE,iBAAiBrvC,EAAQp3B,GAY7C0sB,OAXPA,EAAU24B,IAAWvzC,GAAeslB,EAAQ8tB,IAAeshB,KAEvDppE,EAAGY,QAAUo5B,GACTrkB,EAAQsxB,SAAWtxB,EAAQuxD,YAC3BlnE,EAAGklE,eAAiB,CAChBz/D,EAAG7C,EAAE6C,EACLwW,EAAGrZ,EAAEqZ,GAETjc,EAAGuvB,QAAO,EAAM04B,KAGjB34B,IAr7WE,CAAA,IAAA,mBAw7Wb,MAAA,SAAiB0K,EAAQp3B,GACf5C,IACAuqB,EAAWq3C,GADN,KACqBjsD,QAAQ4U,UAAU3sB,KADvC,KACgDo8B,EAAQp3B,GAC5D5C,OAFI,KAEDulE,SAAWh7C,EAAS9kB,GAFnB,KAE2B+/D,SAAWj7C,EAAStO,MA37WjD,EAAA,GA+7WjB+oD,GAAQpD,YAAcA,GAClB0H,IAAAA,GAAiB,CACjB/1D,GAAI,UACJwtD,SAAUiE,GACVpD,YAAAA,GACA2H,UAAUnqE,SAAAA,EAAO69D,EAAOtnD,GAChBA,IACAvW,EAAM8tD,QAAU,IAAI8X,GAAQ,CAACzqC,OAAQn7B,EAAOuW,QAAAA,MAGpDu2B,aAAa9sC,SAAAA,EAAO69D,EAAOtnD,GACnBvW,EAAM8tD,SACN9tD,EAAM8tD,QAAQ5uB,WAAW3oB,IAGjCqwC,MAAM5mD,SAAAA,EAAO69D,EAAOtnD,GACZvW,EAAM8tD,SACN9tD,EAAM8tD,QAAQ5uB,WAAW3oB,IAGjC6zD,UAAUpqE,SAAAA,GACA8tD,IAAAA,EAAU9tD,EAAM8tD,QAChB1vD,EAAO,CACT0vD,QAAAA,IAEmD,IAAnD9tD,EAAMuuC,cAAc,oBAAqBnwC,KAGzC0vD,GACAA,EAAQvsD,KAAKvB,EAAMsZ,KAEvBtZ,EAAMuuC,cAAc,mBAAoBnwC,KAE5CyjE,WAAW7hE,SAAAA,EAAO5B,GACV4B,GAAAA,EAAM8tD,QAAS,CACTriC,IAAAA,EAAmBrtB,EAAKyqD,OAC1B7oD,EAAM8tD,QAAQgU,YAAY1jE,EAAK8D,MAAOupB,KACtCrtB,EAAK8xB,SAAU,KAI3B/X,SAAU,CACN0vB,SAAS,EACTigC,SAAU,KACV38C,SAAU,UACV7S,gBAAiB,kBACjBgwD,WAAY,OACZtH,UAAW,CACP9nD,MAAO,QAEX+qD,aAAc,EACdC,kBAAmB,EACnB/4B,WAAY,OACZ+9B,UAAW,OACX9E,YAAa,EACbd,SAAU,GACVuF,UAAW,OACXQ,YAAa,OACb/E,cAAe,EACfD,gBAAiB,EACjBd,WAAY,CACRrqD,MAAO,QAEXkwD,YAAa,OACb74C,QAAS,EACTy0C,aAAc,EACdD,UAAW,EACX/jD,aAAc,EACdy9C,UAAW,SAACnlD,EAAKkK,GAASA,OAAAA,EAAK8/C,SAASrqD,MACxCylD,SAAU,SAACplD,EAAKkK,GAASA,OAAAA,EAAK8/C,SAASrqD,MACvC0vD,mBAAoB,OACpBxE,eAAe,EACf5rD,YAAa,gBACb0J,YAAa,EACb5J,UAAW,CACP9X,SAAU,IACVk5B,OAAQ,gBAEZqB,WAAY,CACRH,QAAS,CACLx6B,KAAM,SACNu6B,WAAY,CAAC,IAAK,IAAK,QAAS,SAAU,SAAU,WAExDmrC,QAAS,CACLpsC,OAAQ,SACRl5B,SAAU,MAGlBH,UAAW,CACPqmE,YAAaxyD,GACbw1B,MAAM+8B,SAAAA,GACEA,GAAAA,EAAaplE,OAAS,EAAG,CACnBE,IAAAA,EAAOklE,EAAa,GACpB9kC,EAASpgC,EAAKtB,MAAMif,KAAKyiB,OACzB2oC,EAAa3oC,EAASA,EAAOtgC,OAAS,EACxC,GAAA,MAAQ,KAAKmV,SAAiC,YAAtB,KAAKA,QAAQoD,KAC9BrY,OAAAA,EAAKwrB,QAAQgW,OAAS,GAC1B,GAAIxhC,EAAKwhC,MACLxhC,OAAAA,EAAKwhC,MACT,GAAIunC,EAAa,GAAK/oE,EAAKgiC,UAAY+mC,EACnC3oC,OAAAA,EAAOpgC,EAAKgiC,WAGpB,MAAA,IAEXojC,WAAYzyD,GACZ8vD,WAAY9vD,GACZ4yD,YAAa5yD,GACb6uB,MAAMmuB,SAAAA,GACE,GAAA,MAAQ,KAAK16C,SAAiC,YAAtB,KAAKA,QAAQoD,KAC9Bs3C,OAAAA,EAAYnuB,MAAQ,KAAOmuB,EAAYE,gBAAkBF,EAAYE,eAE5EruB,IAAAA,EAAQmuB,EAAYnkC,QAAQgW,OAAS,GACrCA,IACAA,GAAS,MAEPnvB,IAAAA,EAAQs9C,EAAYE,eAInBruB,OAHF1uB,GAAcT,KACfmvB,GAASnvB,GAENmvB,GAEXqkC,WAAWlW,SAAAA,GACDpkC,IACAtW,EADO06C,EAAYjxD,MAAM+sB,eAAekkC,EAAYr7C,cACrC8U,WAAWxD,SAAS+pC,EAAY3tB,WAC9C,MAAA,CACH/qB,YAAahC,EAAQgC,YACrBD,gBAAiB/B,EAAQ+B,kBAGjC+uD,eAAiB,WACN,OAAA,KAAK9wD,QAAQ2yD,WAExB9B,gBAAgBnW,SAAAA,GACNpkC,IACAtW,EADO06C,EAAYjxD,MAAM+sB,eAAekkC,EAAYr7C,cACrC8U,WAAWxD,SAAS+pC,EAAY3tB,WAC9C,MAAA,CACHriB,WAAY1K,EAAQ0K,WACpBC,SAAU3K,EAAQ2K,WAG1B4lD,WAAY7yD,GACZ+vD,UAAW/vD,GACX8yD,aAAc9yD,GACdovD,OAAQpvD,GACR+yD,YAAa/yD,KAGrBoxB,cAAe,CACXi+B,SAAU,OACVC,WAAY,OACZvC,UAAW,QAEfrpD,YAAa,CACTsD,YAAa,SAACV,GAASA,MAAS,WAATA,GAA8B,aAATA,GAAgC,aAATA,GACnEY,YAAY,EACZ/a,UAAW,CACP6a,aAAa,EACbE,YAAY,GAEhB9C,UAAW,CACP+C,WAAW,GAEf0f,WAAY,CACR1f,UAAW,cAGnB6mC,uBAAwB,CAAC,gBAGzBhoC,GAAuB3I,OAAO6gB,OAAO,CACrCmE,UAAW,KACXg0C,WAAYrR,GACZsR,OAAQ5M,GACRkB,OAAQ6C,GACRM,MAAOK,GACPuD,QAASsE,KAGPM,GAAc,SAAC9oC,EAAQ6B,EAAK1tB,GAAU,MAAe,iBAAR0tB,EAC7C7B,EAAOr/B,KAAKkhC,GAAO,EACnB5mB,MAAM4mB,GAAO,KAAO1tB,GAWpB+0B,IAEA6/B,GAjoXW,SAAA,GAAA,EAAA,EAioXWr/B,IAjoXX,IAAA,EAAA,EAAA,GAkoXD/R,SAAAA,EAAAA,GAAK,IAAA,EAAA,OAAA,EAAA,KAAA,IACPA,EAAAA,EAAAA,KAAAA,KAAAA,IACDqxC,iBAAc3qE,EACd4qE,EAAAA,YAAc,EAHN,EAloXJ,OAAA,EAAA,EAAA,CAAA,CAAA,IAAA,QAwoXb,MAAA,SAAMpnC,EAAK1tB,GACHzB,GAAAA,GAAcmvB,GACP,OAAA,KAEL7B,IAAAA,EAAS,KAAKC,YAGbiJ,OAhBI,SAAC/0B,EAAOpT,GAAQoT,OAAU,OAAVA,EAAiB,KAAOgJ,GAAYne,KAAKyD,MAAM0R,GAAQ,EAAGpT,GAgB9EmoC,CAFP/0B,EAAQnB,SAASmB,IAAU6rB,EAAO7rB,KAAW0tB,EAAM1tB,EAvBlD+0D,SAAelpC,EAAQ6B,EAAK1tB,GAC3BmyB,IAAAA,EAAQtG,EAAOrrB,QAAQktB,GACzByE,OAAW,IAAXA,EACOwiC,GAAY9oC,EAAQ6B,EAAK1tB,GAG7BmyB,IADMtG,EAAOmpC,YAAYtnC,GACR1tB,EAAQmyB,EAkBtB4iC,CAAelpC,EAAQ6B,EAAK1uB,GAAegB,EAAO0tB,IAC/B7B,EAAOtgC,OAAS,KA/oXhC,CAAA,IAAA,sBAkpXb,MAAA,WACUR,IAAAA,EAAK,KACsBA,EAAAA,EAAG0hC,gBAA7BC,EAAAA,EAAAA,WAAYC,EAAAA,EAAAA,WACF5hC,EAAAA,EAAG+rC,WAAU,GAAzBhsC,EAAAA,EAAAA,IAAK8B,EAAAA,EAAAA,IACgB,UAAtB7B,EAAG2V,QAAQyyB,SACNzG,IACD5hC,EAAM,GAEL6hC,IACD//B,EAAM7B,EAAG+gC,YAAYvgC,OAAS,IAGtCR,EAAGD,IAAMA,EACTC,EAAG6B,IAAMA,IA/pXA,CAAA,IAAA,aAkqXb,MAAA,WACU7B,IAAAA,EAAK,KACLD,EAAMC,EAAGD,IACT8B,EAAM7B,EAAG6B,IACT2kC,EAASxmC,EAAG2V,QAAQ6wB,OACpBhB,EAAQ,GACV1E,EAAS9gC,EAAG+gC,YAChBD,EAAkB,IAAR/gC,GAAa8B,IAAQi/B,EAAOtgC,OAAS,EAAKsgC,EAASA,EAAOnjC,MAAMoC,EAAK8B,EAAM,GACrF7B,EAAG+pE,YAAcjqE,KAAK+B,IAAIi/B,EAAOtgC,QAAUgmC,EAAS,EAAI,GAAI,GAC5DxmC,EAAG8pE,YAAc9pE,EAAGD,KAAOymC,EAAS,GAAM,GACrC,IAAA,IAAIzzB,EAAQhT,EAAKgT,GAASlR,EAAKkR,IAChCyyB,EAAM/jC,KAAK,CAACsR,MAAAA,IAETyyB,OAAAA,IA/qXE,CAAA,IAAA,mBAkrXb,MAAA,SAAiBzyB,GACP/S,IACA8gC,EADK,KACOC,YACdhuB,OAAAA,GAAS,GAAKA,EAAQ+tB,EAAOtgC,OACtBsgC,EAAO/tB,GAEXA,IAxrXE,CAAA,IAAA,YA2rXb,MAAA,WAEI,EAAA,EAAA,EAAA,WAAA,YAAA,MAAA,KAAA,MADW,KAEH0d,iBAFG,KAGJtG,gBAHI,KAGiBA,kBA/rXnB,CAAA,IAAA,mBAmsXb,MAAA,SAAiBpX,GAKNA,MAHc,iBAAVA,IACPA,EAFO,KAEIkuB,MAAMluB,IAEJ,OAAVA,EAAiBsuB,IAJb,KAIsB4rB,oBAAoBl6C,EAJ1C,KAIqD+2D,aAJrD,KAIuEC,eAxsXzE,CAAA,IAAA,kBA2sXb,MAAA,SAAgB90D,GACNjV,IACAwlC,EADK,KACMA,MACbvwB,OAAAA,EAAQ,GAAKA,EAAQuwB,EAAMhlC,OAAS,EAC7B,KAHA,KAKD2vC,iBAAiB3K,EAAMvwB,GAAOlC,SAjtX/B,CAAA,IAAA,mBAotXb,MAAA,SAAiByM,GAEN1f,OAAAA,KAAKyD,MADD,KACUumE,YADV,KAC2BI,mBAAmB1qD,GAD9C,KAC0DuqD,eAttX5D,CAAA,IAAA,eAytXb,MAAA,WACW,OAAA,KAAKnoD,WA1tXH,EAAA,GA8tXjBioD,GAAct2D,GAAK,WACnBs2D,GAActyD,SAAW,CACrBiuB,MAAO,CACHvoC,SAAU4sE,GAAcnsE,UAAUykC,mBA2EpCgoC,IAAAA,GA5yXW,SAAA,GAAA,EAAA,EA4yXa3/B,IA5yXb,IAAA,EAAA,EAAA,GA6yXD/R,SAAAA,EAAAA,GAAK,IAAA,EAAA,OAAA,EAAA,KAAA,IACPA,EAAAA,EAAAA,KAAAA,KAAAA,IACDj6B,WAAQW,EACRV,EAAAA,SAAMU,EACN2qE,EAAAA,iBAAc3qE,EACdirE,EAAAA,eAAYjrE,EACZ4qE,EAAAA,YAAc,EANN,EA7yXJ,OAAA,EAAA,EAAA,CAAA,CAAA,IAAA,QAszXb,MAAA,SAAMpnC,EAAK1tB,GACHzB,OAAAA,GAAcmvB,GACP,MAES,iBAARA,GAAoBA,aAAe9uB,UAAYC,UAAU6uB,GAC1D,MAEHA,IA7zXC,CAAA,IAAA,yBAg0Xb,MAAA,WACU3iC,IAAAA,EAAK,KACoBA,EAAAA,EAAG2V,QAA3BwyB,EAAAA,EAAAA,YAAahM,EAAAA,EAAAA,QACan8B,EAAAA,EAAG0hC,gBAA7BC,EAAAA,EAAAA,WAAYC,EAAAA,EAAAA,WACd7hC,EAAYC,EAAZD,IAAK8B,EAAO7B,EAAP6B,IACJwoE,EAAS,SAAAlnE,GAAMpD,OAAAA,EAAM4hC,EAAa5hC,EAAMoD,GACxCmnE,EAAS,SAAAnnE,GAAMtB,OAAAA,EAAM+/B,EAAa//B,EAAMsB,GAC1CglC,GAAAA,GAAehM,EAAS,CAClBouC,IAAAA,EAAUpvD,GAAKpb,GACfyqE,EAAUrvD,GAAKtZ,GACjB0oE,EAAU,GAAKC,EAAU,EACzBF,EAAO,GACAC,EAAU,GAAKC,EAAU,GAChCH,EAAO,GAGXtqE,IAAQ8B,IACRyoE,EAAOzoE,EAAM,GACRsmC,GACDkiC,EAAOtqE,EAAM,IAGrBC,EAAGD,IAAMA,EACTC,EAAG6B,IAAMA,IAv1XA,CAAA,IAAA,eA01Xb,MAAA,WACU7B,IAGFyqE,EAFErkC,EADK,KACSzwB,QAAQ6vB,MACvBc,EAA2BF,EAA3BE,cAAeokC,EAAYtkC,EAAZskC,SAWbD,OATHC,EACAD,EAAW3qE,KAAK4nC,KALT,KAKiB7lC,IAAM6oE,GAAY5qE,KAAKyb,MALxC,KAKiDxb,IAAM2qE,GAAY,GAE1ED,EAPO,KAOOE,mBACdrkC,EAAgBA,GAAiB,IAEjCA,IACAmkC,EAAW3qE,KAAKC,IAAIumC,EAAemkC,IAEhCA,IAx2XE,CAAA,IAAA,mBA22Xb,MAAA,WACW52D,OAAAA,OAAOgH,oBA52XL,CAAA,IAAA,aA+2Xb,MAAA,WACU7a,IAAAA,EAAK,KACL4iB,EAAO5iB,EAAG2V,QACVywB,EAAWxjB,EAAK4iB,MAClBilC,EAAWzqE,EAAG4qE,eAUZplC,EAxJLqlC,SAAgBC,EAAmBC,GAClCvlC,IAUFrN,EAAQ6yC,EAASC,EAASC,EAVxB1lC,EAAQ,GAEP2lC,EAA8CL,EAA9CK,KAAMprE,EAAwC+qE,EAAxC/qE,IAAK8B,EAAmCipE,EAAnCjpE,IAAKupE,EAA8BN,EAA9BM,UAAW5qC,EAAmBsqC,EAAnBtqC,MAAOiqC,EAAYK,EAAZL,SACnC1hB,EAAOoiB,GAAQ,EACfE,EAAYZ,EAAW,EACjBa,EAAmBP,EAAxBhrE,IAAgBwrE,EAAQR,EAAblpE,IACZ8/B,GAAcnuB,GAAczT,GAC5B6hC,GAAcpuB,GAAc3R,GAC5B2pE,GAAgBh4D,GAAcgtB,GAChCgH,EAAUpsB,IAASmwD,EAAOD,GAAQD,EAAYtiB,GAAQA,EAEtDvhB,GAAAA,EAVgB,QAUU7F,IAAeC,EAClC,MAAA,CAAC,CAAC7uB,MAAOu4D,GAAO,CAACv4D,MAAOw4D,KAEnCL,EAAYprE,KAAK4nC,KAAK6jC,EAAO/jC,GAAW1nC,KAAKyb,MAAM+vD,EAAO9jC,IAC1C6jC,IACZ7jC,EAAUpsB,GAAQ8vD,EAAY1jC,EAAU6jC,EAAYtiB,GAAQA,GAE3Dv1C,GAAc43D,KACfjzC,EAASr4B,KAAKwb,IAAI,GAAI8vD,GACtB5jC,EAAU1nC,KAAK4nC,KAAKF,EAAUrP,GAAUA,GAE5C6yC,EAAUlrE,KAAKyb,MAAM+vD,EAAO9jC,GAAWA,EACvCyjC,EAAUnrE,KAAK4nC,KAAK6jC,EAAO/jC,GAAWA,EAClC7F,GAAcC,GAAcupC,GAAQ/uD,IAAava,EAAM9B,GAAOorE,EAAM3jC,EAAU,MAE9EA,GAAW3lC,EAAM9B,IADjBmrE,EAAYprE,KAAKC,KAAK8B,EAAM9B,GAAOynC,EAASijC,IAE5CO,EAAUjrE,EACVkrE,EAAUppE,GACH2pE,EAIPhkC,IAFAyjC,EAAUrpC,EAAa//B,EAAMopE,IAD7BD,EAAUrpC,EAAa5hC,EAAMirE,KAE7BE,EAAY1qC,EAAQ,GAKhB0qC,EADAlvD,GADJkvD,GAAaD,EAAUD,GAAWxjC,EACN1nC,KAAKyD,MAAM2nE,GAAY1jC,EAAU,KAC7C1nC,KAAKyD,MAAM2nE,GAEXprE,KAAK4nC,KAAKwjC,GAG9B/yC,EAASr4B,KAAKwb,IAAI,GAAI9H,GAAc43D,GAAavuD,GAAe2qB,GAAW4jC,GAC3EJ,EAAUlrE,KAAKyD,MAAMynE,EAAU7yC,GAAUA,EACzC8yC,EAAUnrE,KAAKyD,MAAM0nE,EAAU9yC,GAAUA,EACrC7nB,IAAAA,EAAI,EAUDA,IATHqxB,IACA6D,EAAM/jC,KAAK,CAACsR,MAAOhT,IACfirE,EAAUjrE,GACVuQ,IAEA8L,GAAYtc,KAAKyD,OAAOynE,EAAU16D,EAAIk3B,GAAWrP,GAAUA,EAASp4B,EAAKynC,EAAU,MACnFl3B,KAGDA,EAAI46D,IAAa56D,EACpBk1B,EAAM/jC,KAAK,CAACsR,MAAOjT,KAAKyD,OAAOynE,EAAU16D,EAAIk3B,GAAWrP,GAAUA,IAW/DqN,OATH5D,EACIxlB,GAAYopB,EAAMA,EAAMhlC,OAAS,GAAGuS,MAAQlR,EAAK2lC,EAAU,KAC3DhC,EAAMA,EAAMhlC,OAAS,GAAGuS,MAAQlR,EAEhC2jC,EAAM/jC,KAAK,CAACsR,MAAOlR,IAGvB2jC,EAAM/jC,KAAK,CAACsR,MAAOk4D,IAEhBzlC,EAoFWqlC,CARkB,CAC5BJ,SAFJA,EAAW3qE,KAAK+B,IAAI,EAAG4oE,GAGnB1qE,IAAK6iB,EAAK7iB,IACV8B,IAAK+gB,EAAK/gB,IACVupE,UAAWhlC,EAASglC,UACpBD,KAAM/kC,EAASskC,SACflqC,MAAO4F,EAAS5F,OAEmCjT,GAAUvtB,EAAI4iB,EAAK6K,QAYnE+X,MAXa,UAAhB5iB,EAAKwlB,QACL9rB,GAAmBkpB,EAAOxlC,EAAI,SAE9B4iB,EAAKnO,SACL+wB,EAAM/wB,UACNzU,EAAGxB,MAAQwB,EAAG6B,IACd7B,EAAGvB,IAAMuB,EAAGD,MAEZC,EAAGxB,MAAQwB,EAAGD,IACdC,EAAGvB,IAAMuB,EAAG6B,KAET2jC,IAz4XE,CAAA,IAAA,YA44Xb,MAAA,WACUxlC,IAAAA,EAAK,KACLwlC,EAAQxlC,EAAGwlC,MACbhnC,EAAQwB,EAAGD,IACXtB,EAAMuB,EAAG6B,IAET7B,GADJ,EAAA,EAAA,EAAA,WAAA,YAAA,MAAA,KAAA,MACIA,EAAG2V,QAAQ6wB,QAAUhB,EAAMhlC,OAAQ,CAC7BgmC,IAAAA,GAAU/nC,EAAMD,GAASsB,KAAK+B,IAAI2jC,EAAMhlC,OAAS,EAAG,GAAK,EAC/DhC,GAASgoC,EACT/nC,GAAO+nC,EAEXxmC,EAAG8pE,YAActrE,EACjBwB,EAAGoqE,UAAY3rE,EACfuB,EAAG+pE,YAActrE,EAAMD,IAz5Xd,CAAA,IAAA,mBA45Xb,MAAA,SAAiBuU,GACN4xB,OAAAA,GAAa5xB,EAAO,KAAK3T,MAAMuW,QAAQkvB,YA75XrC,EAAA,GAi6XX4mC,GAj6XW,SAAA,GAAA,EAAA,EAi6XStB,IAj6XT,IAAA,EAAA,EAAA,GAAA,SAAA,IAAA,OAAA,EAAA,KAAA,GAAA,EAAA,MAAA,KAAA,WAAA,OAAA,EAAA,EAAA,CAAA,CAAA,IAAA,sBAk6Xb,MAAA,WACUnqE,IACaA,EADR,KACW+rC,WAAU,GAAzBhsC,EAAAA,EAAAA,IAAK8B,EAAAA,EAAAA,IADD,KAER9B,IAAM6T,GAAe7T,GAAOA,EAAM,EAF1B,KAGR8B,IAAM+R,GAAe/R,GAAOA,EAAM,EAH1B,KAIR6pE,2BAv6XM,CAAA,IAAA,mBA06Xb,MAAA,WAEQ1rE,GADO,KACJywB,eACI3wB,OAAAA,KAAK4nC,KAFL,KAEa/oB,MAAQ,IAE1B8wB,IAAAA,EAJK,KAISQ,wBAAwB,GACrCnwC,OAAAA,KAAK4nC,KALD,KAKS1nB,OAASyvB,EAASl3B,cAh7X7B,CAAA,IAAA,mBAm7Xb,MAAA,SAAiBxF,GACNA,OAAU,OAAVA,EAAiBsuB,IAAM,KAAK4rB,oBAAoBl6C,EAAQ,KAAK+2D,aAAe,KAAKC,eAp7X/E,CAAA,IAAA,mBAu7Xb,MAAA,SAAiBvqD,GACN,OAAA,KAAKsqD,YAAc,KAAKI,mBAAmB1qD,GAAS,KAAKuqD,gBAx7XvD,EAAA,GAm8XR4B,SAAAA,GAAQC,GAENryC,OAAW,IADHqyC,EAAW9rE,KAAKwb,IAAI,GAAIxb,KAAKyb,MAAML,GAAM0wD,KAR5DH,GAAYl4D,GAAK,SACjBk4D,GAAYl0D,SAAW,CACnBiuB,MAAO,CACHvoC,SAAUipC,GAAMb,WAAWC,UAgC7BumC,IAAAA,GA/9XW,SAAA,GAAA,EAAA,EA+9XcrhC,IA/9Xd,IAAA,EAAA,EAAA,GAg+XD/R,SAAAA,EAAAA,GAAK,IAAA,EAAA,OAAA,EAAA,KAAA,IACPA,EAAAA,EAAAA,KAAAA,KAAAA,IACDj6B,WAAQW,EACRV,EAAAA,SAAMU,EACN2qE,EAAAA,iBAAc3qE,EACd4qE,EAAAA,YAAc,EALN,EAh+XJ,OAAA,EAAA,EAAA,CAAA,CAAA,IAAA,QAw+Xb,MAAA,SAAMpnC,EAAK1tB,GACDlC,IAAAA,EAAQo3D,GAAgBzsE,UAAUujC,MAAMljC,MAAM,KAAM,CAAC4kC,EAAK1tB,IAC5DlC,GAAU,IAAVA,EAIGa,OAAAA,GAAeb,IAAUA,EAAQ,EAAIA,EAAQ,KAH3C+4D,KAAAA,OAAQ,IA3+XR,CAAA,IAAA,sBAi/Xb,MAAA,WACU9rE,IAAAA,EAAK,KACQA,EAAAA,EAAG+rC,WAAU,GAAzBhsC,EAAAA,EAAAA,IAAK8B,EAAAA,EAAAA,IACZ7B,EAAGD,IAAM6T,GAAe7T,GAAOD,KAAK+B,IAAI,EAAG9B,GAAO,KAClDC,EAAG6B,IAAM+R,GAAe/R,GAAO/B,KAAK+B,IAAI,EAAGA,GAAO,KAC9C7B,EAAG2V,QAAQwyB,cACXnoC,EAAG8rE,OAAQ,GAEf9rE,EAAG0rE,2BAz/XM,CAAA,IAAA,yBA4/Xb,MAAA,WACU1rE,IAAAA,EAAK,KACsBA,EAAAA,EAAG0hC,gBAA7BC,EAAAA,EAAAA,WAAYC,EAAAA,EAAAA,WACf7hC,EAAMC,EAAGD,IACT8B,EAAM7B,EAAG6B,IACPwoE,EAAS,SAAAlnE,GAAMpD,OAAAA,EAAM4hC,EAAa5hC,EAAMoD,GACxCmnE,EAAS,SAAAnnE,GAAMtB,OAAAA,EAAM+/B,EAAa//B,EAAMsB,GACxC4oE,EAAM,SAAC5oE,EAAG8B,GAAMnF,OAAAA,KAAKwb,IAAI,GAAIxb,KAAKyb,MAAML,GAAM/X,IAAM8B,IACtDlF,IAAQ8B,IACJ9B,GAAO,GACPsqE,EAAO,GACPC,EAAO,MAEPD,EAAO0B,EAAIhsE,GAAM,IACjBuqE,EAAOyB,EAAIlqE,EAAK,MAGpB9B,GAAO,GACPsqE,EAAO0B,EAAIlqE,GAAM,IAEjBA,GAAO,GACPyoE,EAAOyB,EAAIhsE,EAAK,IAEhBC,EAAG8rE,OAAS9rE,EAAGD,MAAQC,EAAGsrC,eAAiBvrC,IAAQgsE,EAAI/rE,EAAGD,IAAK,IAC/DsqE,EAAO0B,EAAIhsE,GAAM,IAErBC,EAAGD,IAAMA,EACTC,EAAG6B,IAAMA,IAvhYA,CAAA,IAAA,aA0hYb,MAAA,WACU7B,IAAAA,EAAK,KACL4iB,EAAO5iB,EAAG2V,QAKV6vB,EAzFLwmC,SAAclB,EAAmBC,GAChCkB,IAAAA,EAASnsE,KAAKyb,MAAML,GAAM6vD,EAAUlpE,MACpCqqE,EAAiBpsE,KAAK4nC,KAAKqjC,EAAUlpE,IAAM/B,KAAKwb,IAAI,GAAI2wD,IACxDzmC,EAAQ,GACVomC,EAAU73D,GAAgB+2D,EAAkB/qE,IAAKD,KAAKwb,IAAI,GAAIxb,KAAKyb,MAAML,GAAM6vD,EAAUhrE,QACzFgsE,EAAMjsE,KAAKyb,MAAML,GAAM0wD,IACvBO,EAAcrsE,KAAKyb,MAAMqwD,EAAU9rE,KAAKwb,IAAI,GAAIywD,IAChDX,EAAYW,EAAM,EAAIjsE,KAAKwb,IAAI,GAAIxb,KAAKqc,IAAI4vD,IAAQ,EACrD,GACCvmC,EAAM/jC,KAAK,CAACsR,MAAO64D,EAAS5kC,MAAO2kC,GAAQC,KAEvB,MADlBO,IAEEA,EAAc,EAEdf,IADEW,GACiB,EAAI,EAAIX,GAE/BQ,EAAU9rE,KAAKyD,MAAM4oE,EAAcrsE,KAAKwb,IAAI,GAAIywD,GAAOX,GAAaA,QAC/DW,EAAME,GAAWF,IAAQE,GAAUE,EAAcD,GACpDE,IAAAA,EAAWr4D,GAAgB+2D,EAAkBjpE,IAAK+pE,GAEjDpmC,OADPA,EAAM/jC,KAAK,CAACsR,MAAOq5D,EAAUplC,MAAO2kC,GAAQC,KACrCpmC,EAqEWwmC,CAJY,CACtBjsE,IAAKC,EAAGorC,SACRvpC,IAAK7B,EAAGmrC,UAEmCnrC,GAYxCwlC,MAXa,UAAhB5iB,EAAKwlB,QACL9rB,GAAmBkpB,EAAOxlC,EAAI,SAE9B4iB,EAAKnO,SACL+wB,EAAM/wB,UACNzU,EAAGxB,MAAQwB,EAAG6B,IACd7B,EAAGvB,IAAMuB,EAAGD,MAEZC,EAAGxB,MAAQwB,EAAGD,IACdC,EAAGvB,IAAMuB,EAAG6B,KAET2jC,IA7iYE,CAAA,IAAA,mBAgjYb,MAAA,SAAiBzyB,GACNA,YAAU5T,IAAV4T,EAAsB,IAAM4xB,GAAa5xB,EAAO,KAAK3T,MAAMuW,QAAQkvB,UAjjYjE,CAAA,IAAA,YAojYb,MAAA,WACU7kC,IACAxB,EADK,KACMuB,IACjB,EAAA,EAAA,EAAA,WAAA,YAAA,MAAA,KAAA,MAFW,KAGR+pE,YAAc5uD,GAAM1c,GAHZ,KAIRurE,YAAc7uD,GAJN,KAIerZ,KAAOqZ,GAAM1c,KAzjY9B,CAAA,IAAA,mBA4jYb,MAAA,SAAiBuU,GACP/S,IAAAA,EAAK,KAIJA,YAHOb,IAAV4T,GAAiC,IAAVA,IACvBA,EAAQ/S,EAAGD,KAERC,EAAGitD,mBAAmBl6C,IAAU/S,EAAGD,IACpC,GACCmb,GAAMnI,GAAS/S,EAAG8pE,aAAe9pE,EAAG+pE,eAnkYlC,CAAA,IAAA,mBAskYb,MAAA,SAAiBvqD,GACPxf,IACAowC,EADK,KACQ85B,mBAAmB1qD,GAC/B1f,OAAAA,KAAKwb,IAAI,GAFL,KAEYwuD,YAAc15B,EAF1B,KAEuC25B,iBAzkYzC,EAAA,GAulYRsC,SAAAA,GAAsBzpD,GACrBwjB,IAAAA,EAAWxjB,EAAK4iB,MAClBY,GAAAA,EAAS9U,SAAW1O,EAAK0O,QAAS,CAC5B3B,IAAAA,EAAU3C,GAAUoZ,EAASkmC,iBAC5Br4D,OAAAA,GAAemyB,EAASjuB,MAAQiuB,EAASjuB,KAAKE,KAAMd,GAASY,KAAKE,MAAQsX,EAAQ3P,OAEtF,OAAA,EAgBFusD,SAAAA,GAAgBnvD,EAAO3G,EAAK4B,EAAMtY,EAAK8B,GACxCub,OAAAA,IAAUrd,GAAOqd,IAAUvb,EACpB,CACHrD,MAAOiY,EAAO4B,EAAO,EACrB5Z,IAAKgY,EAAO4B,EAAO,GAEhB+E,EAAQrd,GAAOqd,EAAQvb,EACvB,CACHrD,MAAOiY,EAAM4B,EACb5Z,IAAKgY,GAGN,CACHjY,MAAOiY,EACPhY,IAAKgY,EAAM4B,GA8EVm0D,SAAAA,GAAqBpvD,GACtBA,OAAU,IAAVA,GAAyB,MAAVA,EACR,SACAA,EAAQ,IACR,OAEJ,QAGFqvD,SAAAA,GAAkCrvD,EAAOkkD,EAAU/2C,GAC1C,KAAVnN,GAA0B,MAAVA,EAChBmN,EAAStO,GAAMqlD,EAAS59D,EAAI,GACrB0Z,EAAQ,KAAOA,EAAQ,MAC9BmN,EAAStO,GAAKqlD,EAAS59D,GA+BtBgpE,SAAAA,GAAenzD,EAAOgH,EAAQiyC,EAAUiX,GACtC/wD,IAAAA,EAAOa,EAAPb,IACH85C,GAAAA,EACA95C,EAAIkI,IAAIrH,EAAMw4C,QAASx4C,EAAMy4C,QAASzxC,EAAQ,EAAG7F,QAC9C,CACCk4C,IAAAA,EAAgBr5C,EAAMozD,iBAAiB,EAAGpsD,GAC9C7H,EAAIoI,OAAO8xC,EAAcntD,EAAGmtD,EAAc32C,GACrC,IAAA,IAAIxb,EAAI,EAAGA,EAAIgpE,EAAYhpE,IAC5BmyD,EAAgBr5C,EAAMozD,iBAAiBlsE,EAAG8f,GAC1C7H,EAAIuI,OAAO2xC,EAAcntD,EAAGmtD,EAAc32C,IAwB7C2wD,SAAAA,GAAaC,GACX/wD,OAAAA,GAAS+wD,GAASA,EAAQ,EA1MrChB,GAAiBt4D,GAAK,cACtBs4D,GAAiBt0D,SAAW,CACxBiuB,MAAO,CACHvoC,SAAUipC,GAAMb,WAAWY,YAC3Be,MAAO,CACHC,SAAS,KAwMf6lC,IAAAA,GA1xYW,SAAA,GAAA,EAAA,EA0xYe3C,IA1xYf,IAAA,EAAA,EAAA,GA2xYD1xC,SAAAA,EAAAA,GAAK,IAAA,EAAA,OAAA,EAAA,KAAA,IACPA,EAAAA,EAAAA,KAAAA,KAAAA,IACDs5B,aAAU5yD,EACV6yD,EAAAA,aAAU7yD,EACV4tE,EAAAA,iBAAc5tE,EACd6tE,EAAAA,aAAe,GACfC,EAAAA,iBAAmB,GANX,EA3xYJ,OAAA,EAAA,EAAA,CAAA,CAAA,IAAA,gBAoyYb,MAAA,WACUjtE,IAAAA,EAAK,KACXA,EAAG2e,MAAQ3e,EAAGwjB,SACdxjB,EAAGggB,OAAShgB,EAAGooB,UACfpoB,EAAG0qC,WAAa2hC,GAAsBrsE,EAAG2V,SAAW,EACpD3V,EAAG+xD,QAAUjyD,KAAKyb,MAAMvb,EAAG2e,MAAQ,GACnC3e,EAAGgyD,QAAUlyD,KAAKyb,OAAOvb,EAAGggB,OAAShgB,EAAG0qC,YAAc,GACtD1qC,EAAG+sE,YAAcjtE,KAAKC,IAAIC,EAAGggB,OAAShgB,EAAG0qC,WAAY1qC,EAAG2e,OAAS,IA3yYxD,CAAA,IAAA,sBA8yYb,MAAA,WACU3e,IACaA,EADR,KACW+rC,WAAU,GAAzBhsC,EAAAA,EAAAA,IAAK8B,EAAAA,EAAAA,IADD,KAER9B,IAAM6T,GAAe7T,KAASgc,MAAMhc,GAAOA,EAAM,EAFzC,KAGR8B,IAAM+R,GAAe/R,KAASka,MAAMla,GAAOA,EAAM,EAHzC,KAIR6pE,2BAnzYM,CAAA,IAAA,mBAszYb,MAAA,WACW5rE,OAAAA,KAAK4nC,KAAK,KAAKqlC,YAAcV,GAAsB,KAAK12D,YAvzYtD,CAAA,IAAA,qBA0zYb,MAAA,SAAmB6vB,GACTxlC,IAAAA,EAAK,KACXmqE,GAAgBzsE,UAAU6xC,mBAAmB3xC,KAAKoC,EAAIwlC,GACtDxlC,EAAGgtE,aAAehtE,EAAG+gC,YAAY9+B,IAAI,SAAC8Q,EAAOkC,GACnCitB,IAAAA,EAAQjlC,GAAS+C,EAAG2V,QAAQ88C,YAAYx1D,SAAU,CAAC8V,EAAOkC,GAAQjV,GACjEkiC,OAAAA,GAAmB,IAAVA,EAAcA,EAAQ,OA/zYjC,CAAA,IAAA,MAm0Yb,MAAA,WACUliC,IACA4iB,EADK,KACKjN,QACZiN,EAAK0O,SAAW1O,EAAK6vC,YAAYnhC,QAvMpC47C,SAAmB3zD,GAClB4zD,IAOF1sE,EAAG6gE,EAAU1O,EAvCKl6C,EAAKH,EAAY2pB,EAgCjCirC,EAAiB,CACnB1pE,EAAG,EACHJ,EAAGkW,EAAMoF,MACTiX,EAAG,EACHnzB,EAAG8W,EAAMyG,OAASzG,EAAMmxB,YAEtB0iC,EAAiB,GAEjBl/B,EAAa,GACbve,EAAU,GACV09C,EAAa9zD,EAAMwnB,YAAYvgC,OAChCC,IAAAA,EAAI,EAAGA,EAAI4sE,EAAY5sE,IAAK,CACvBmiB,IAAAA,EAAOrJ,EAAM5D,QAAQ88C,YAAYnhB,WAAW/3B,EAAMsG,WAAWpf,IACnEkvB,EAAQlvB,GAAKmiB,EAAK+M,QAClBijC,EAAgBr5C,EAAMozD,iBAAiBlsE,EAAG8Y,EAAMwzD,YAAcp9C,EAAQlvB,IAChE6sE,IAAAA,EAASrgD,GAAOrK,EAAKzK,MAC3BoB,EAAMb,IAAIP,KAAOm1D,EAAO9uD,OAhDN9F,EAiDUa,EAAMb,IAjDXH,EAiDgB+0D,EAAO/0D,WAA9C+oD,EAhDA18D,GADmCs9B,EAiDuB3oB,EAAMyzD,aAAavsE,IA/CtE,CACH8D,EAAGqa,GAAalG,EAAKA,EAAIP,KAAM+pB,GAC/Bx+B,EAAGw+B,EAAM1hC,OAAS+X,GAGnB,CACHhU,EAAGmU,EAAIgG,YAAYwjB,GAAOvjB,MAC1Bjb,EAAG6U,GAyCH21B,EAAWztC,GAAK6gE,EACVxyB,IAAAA,EAAev1B,EAAM24C,cAAczxD,GACnC2c,EAAQT,GAAUmyB,GAClBy+B,EAAUhB,GAAgBnvD,EAAOw1C,EAAcntD,EAAG67D,EAAS/8D,EAAG,EAAG,KACjEipE,EAAUjB,GAAgBnvD,EAAOw1C,EAAc32C,EAAGqlD,EAAS59D,EAAG,GAAI,KACpE6pE,EAAQ/uE,MAAQ2uE,EAAe1pE,IAC/B0pE,EAAe1pE,EAAI8pE,EAAQ/uE,MAC3B4uE,EAAe3pE,EAAIqrC,GAEnBy+B,EAAQ9uE,IAAM0uE,EAAe9pE,IAC7B8pE,EAAe9pE,EAAIkqE,EAAQ9uE,IAC3B2uE,EAAe/pE,EAAIyrC,GAEnB0+B,EAAQhvE,MAAQ2uE,EAAev3C,IAC/Bu3C,EAAev3C,EAAI43C,EAAQhvE,MAC3B4uE,EAAex3C,EAAIkZ,GAEnB0+B,EAAQ/uE,IAAM0uE,EAAe1qE,IAC7B0qE,EAAe1qE,EAAI+qE,EAAQ/uE,IAC3B2uE,EAAe3qE,EAAIqsC,GAG3Bv1B,EAAMk0D,eAAel0D,EAAMwzD,YAAaI,EAAgBC,GACxD7zD,EAAM0zD,iBAAmB,GACnBrqD,IAAAA,EAAOrJ,EAAM5D,QACb+3D,EAAqBrB,GAAsBzpD,GAC3C+qD,EAAgBp0D,EAAM+4C,8BAA8B1vC,EAAK4iB,MAAM/wB,QAAU8E,EAAMxZ,IAAMwZ,EAAM1X,KAC5FpB,IAAAA,EAAI,EAAGA,EAAI4sE,EAAY5sE,IAAK,CACvBmtE,IAAAA,EAAe,IAANntE,EAAUitE,EAAqB,EAAI,EAC5CG,EAAqBt0D,EAAMozD,iBAAiBlsE,EAAGktE,EAAgBC,EAAQj+C,EAAQlvB,IAC/E2c,EAAQT,GAAUpD,EAAM24C,cAAczxD,IACtC4X,EAAO61B,EAAWztC,GACxBgsE,GAAkCrvD,EAAO/E,EAAMw1D,GACzC1qD,IAAAA,EAAYqpD,GAAqBpvD,GACnCze,OAAJ,EAQMC,GANFD,EADc,SAAdwkB,EACO0qD,EAAmBpoE,EACL,WAAd0d,EACA0qD,EAAmBpoE,EAAK4S,EAAK9T,EAAI,EAEjCspE,EAAmBpoE,EAAI4S,EAAK9T,GAElB8T,EAAK9T,EAC1BgV,EAAM0zD,iBAAiBxsE,GAAK,CACxBgF,EAAGooE,EAAmBpoE,EACtBwW,EAAG4xD,EAAmB5xD,EACtBkH,UAAAA,EACAxkB,KAAAA,EACAgjB,IAAKksD,EAAmB5xD,EACxBrd,MAAAA,EACAgjB,OAAQisD,EAAmB5xD,EAAI5D,EAAK3U,IAmIpCwpE,CAHO,MAAA,KAKJY,eAAe,EAAG,EAAG,EAAG,KAz0YtB,CAAA,IAAA,iBA60Yb,MAAA,SAAeC,EAAuBZ,EAAgBC,GAC5CptE,IAAAA,EAAK,KACPguE,EAAsBb,EAAe1pE,EAAI3D,KAAKihB,IAAIqsD,EAAe3pE,GACjEwqE,EAAuBnuE,KAAK+B,IAAIsrE,EAAe9pE,EAAIrD,EAAG2e,MAAO,GAAK7e,KAAKihB,IAAIqsD,EAAe/pE,GAC1F6qE,GAAsBf,EAAev3C,EAAI91B,KAAKkhB,IAAIosD,EAAex3C,GACjEu4C,GAAyBruE,KAAK+B,IAAIsrE,EAAe1qE,GAAKzC,EAAGggB,OAAShgB,EAAG0qC,YAAa,GAAK5qC,KAAKkhB,IAAIosD,EAAe3qE,GACnHurE,EAAsBpB,GAAaoB,GACnCC,EAAuBrB,GAAaqB,GACpCC,EAAqBtB,GAAasB,GAClCC,EAAwBvB,GAAauB,GACrCnuE,EAAG+sE,YAAcjtE,KAAK+B,IAAIksE,EAAwB,EAAGjuE,KAAKC,IACtDD,KAAKyb,MAAMwyD,GAAyBC,EAAsBC,GAAwB,GAClFnuE,KAAKyb,MAAMwyD,GAAyBG,EAAqBC,GAAyB,KACtFnuE,EAAG8tE,eAAeE,EAAqBC,EAAsBC,EAAoBC,KA11YxE,CAAA,IAAA,iBA61Yb,MAAA,SAAeC,EAAcC,EAAeC,EAAaC,GAC/CvuE,IAAAA,EAAK,KACLwuE,EAAWxuE,EAAG2e,MAAQ0vD,EAAgBruE,EAAG+sE,YACzC0B,EAAUL,EAAepuE,EAAG+sE,YAC5B2B,EAASJ,EAActuE,EAAG+sE,YAC1B4B,EAAa3uE,EAAGggB,OAAShgB,EAAG0qC,WAAc6jC,EAAiBvuE,EAAG+sE,YACpE/sE,EAAG+xD,QAAUjyD,KAAKyb,OAAQkzD,EAAUD,GAAY,EAAKxuE,EAAGrB,MACxDqB,EAAGgyD,QAAUlyD,KAAKyb,OAAQmzD,EAASC,GAAa,EAAK3uE,EAAG2hB,IAAM3hB,EAAG0qC,cAp2YxD,CAAA,IAAA,gBAu2Yb,MAAA,SAAcz1B,GAGH0I,OAAAA,GAAgB1I,GAFCyF,GAAM,KAAKqmB,YAAYvgC,QAEEic,GAD9B,KAAK9G,QAAQy4C,YAAc,MAz2YrC,CAAA,IAAA,gCA62Yb,MAAA,SAA8Br7C,GACpB/S,IAAAA,EAAK,KACPwT,GAAAA,GAAcT,GACPsuB,OAAAA,IAELutC,IAAAA,EAAgB5uE,EAAG+sE,aAAe/sE,EAAG6B,IAAM7B,EAAGD,KAChDC,OAAAA,EAAG2V,QAAQlB,SACHzU,EAAG6B,IAAMkR,GAAS67D,GAEtB77D,EAAQ/S,EAAGD,KAAO6uE,IAt3YjB,CAAA,IAAA,gCAy3Yb,MAAA,SAA8BtxD,GACtB9J,GAAAA,GAAc8J,GACP+jB,OAAAA,IAELrhC,IAAAA,EAAK,KACL6uE,EAAiBvxD,GAAYtd,EAAG+sE,aAAe/sE,EAAG6B,IAAM7B,EAAGD,MAC1DC,OAAAA,EAAG2V,QAAQlB,QAAUzU,EAAG6B,IAAMgtE,EAAiB7uE,EAAGD,IAAM8uE,IA/3YtD,CAAA,IAAA,mBAk4Yb,MAAA,SAAiB55D,EAAO65D,GACd9uE,IACAod,EADK,KACM80C,cAAcj9C,GAAS8F,GACjC,MAAA,CACHtV,EAAG3F,KAAKkhB,IAAI5D,GAAS0xD,EAHd,KAGsC/c,QAC7C91C,EAAGnc,KAAKihB,IAAI3D,GAAS0xD,EAJd,KAIsC9c,QAC7C50C,MAAAA,KAx4YK,CAAA,IAAA,2BA44Yb,MAAA,SAAyBnI,EAAOlC,GACrB,OAAA,KAAK45D,iBAAiB13D,EAAO,KAAKq9C,8BAA8Bv/C,MA74Y9D,CAAA,IAAA,kBAg5Yb,MAAA,SAAgBkC,GACL,OAAA,KAAK49C,yBAAyB59C,GAAS,EAAG,KAAKo7B,kBAj5Y7C,CAAA,IAAA,wBAo5Yb,MAAA,SAAsBp7B,GACiB,IAAA,EAAA,KAAKg4D,iBAAiBh4D,GAClD,MAAA,CACHtW,KAFGA,EAAAA,KAGHgjB,IAHSA,EAAAA,IAIT/iB,MAJcA,EAAAA,MAKdgjB,OALqBA,EAAAA,UAr5YhB,CAAA,IAAA,iBA85Yb,MAAA,WACU5hB,IAAAA,EAAK,KACiCA,EAAAA,EAAG2V,QAAxC+B,EAAAA,EAAAA,gBAAwB86C,EAAPnqB,EAAAA,KAAOmqB,SAC3B96C,GAAAA,EAAiB,CACXgB,IAAAA,EAAM1Y,EAAG0Y,IACfA,EAAIsG,OACJtG,EAAIiI,YACJ+rD,GAAe1sE,EAAIA,EAAGsyD,8BAA8BtyD,EAAGoqE,WAAY5X,EAAUxyD,EAAG+gC,YAAYvgC,QAC5FkY,EAAImI,YACJnI,EAAIwK,UAAYxL,EAChBgB,EAAI0I,OACJ1I,EAAI0G,aAz6YC,CAAA,IAAA,WA66Yb,MAAA,WACUpf,IAKFS,EAAG+lC,EAAQjc,EALTvqB,EAAK,KACL0Y,EAAM1Y,EAAG0Y,IACTkK,EAAO5iB,EAAG2V,QACT48C,EAAoB3vC,EAApB2vC,WAAYlqB,EAAQzlB,EAARylB,KACbohC,EAAazpE,EAAG+gC,YAAYvgC,OAc9B+xD,GAZA3vC,EAAK6vC,YAAYnhC,SA1NpBy9C,SAAgBx1D,EAAOkwD,GAEvB,IADE/wD,IAAAA,EAA+Ba,EAA/Bb,IAAe+5C,EAAgBl5C,EAA1B5D,QAAU88C,YACbhyD,EAAIgpE,EAAa,EAAGhpE,GAAK,EAAGA,IAAK,CAChCkxC,IAAAA,EAAc8gB,EAAYnhB,WAAW/3B,EAAMsG,WAAWpf,IACtD6sE,EAASrgD,GAAO0kB,EAAYx5B,MACkBoB,EAAAA,EAAM0zD,iBAAiBxsE,GAApEgF,EAAAA,EAAAA,EAAGwW,EAAAA,EAAAA,EAAGkH,EAAAA,EAAAA,UAAWxkB,EAAAA,EAAAA,KAAMgjB,EAAAA,EAAAA,IAAK/iB,EAAAA,EAAAA,MAAOgjB,EAAAA,EAAAA,OACnCotD,EAAiBr9B,EAAjBq9B,cACH,IAACx7D,GAAcw7D,GAAgB,CACzBr/C,IAAAA,EAAU3C,GAAU2kB,EAAY26B,iBACtC5zD,EAAIwK,UAAY8rD,EAChBt2D,EAAI25B,SAAS1zC,EAAOgxB,EAAQhxB,KAAMgjB,EAAMgO,EAAQhO,IAAK/iB,EAAQD,EAAOgxB,EAAQhR,MAAOiD,EAASD,EAAMgO,EAAQ3P,QAE9G0C,GACIhK,EACAa,EAAMyzD,aAAavsE,GACnBgF,EACAwW,EAAKqxD,EAAO/0D,WAAa,EACzB+0D,EACA,CACIn7D,MAAOw/B,EAAYx/B,MACnBgR,UAAWA,EACXC,aAAc,YAsMlB2rD,CAAgB/uE,EAAIypE,GAEpBphC,EAAK/W,SACLtxB,EAAGwlC,MAAM5lC,QAAQ,SAACkB,EAAMmU,GAChBA,GAAU,IAAVA,EAAa,CACbuxB,EAASxmC,EAAGsyD,8BAA8BxxD,EAAKiS,OACzC4+B,IAAAA,EAActJ,EAAKiJ,WAAWtxC,EAAG6f,WAAW5K,EAAQ,KAxLrEg6D,SAAe11D,EAAO21D,EAAc3uD,EAAQkpD,GAC3C/wD,IAAAA,EAAMa,EAAMb,IACZ85C,EAAW0c,EAAa1c,SACvBrgD,EAAoB+8D,EAApB/8D,MAAOmR,EAAa4rD,EAAb5rD,WACRkvC,IAAaiX,IAAgBt3D,IAAUmR,GAAa/C,EAAS,IAGnE7H,EAAIsG,OACJtG,EAAI2K,YAAclR,EAClBuG,EAAI4K,UAAYA,EAChB5K,EAAI+5B,YAAYy8B,EAAavmC,YAC7BjwB,EAAIg6B,eAAiBw8B,EAAatmC,iBAClClwB,EAAIiI,YACJ+rD,GAAenzD,EAAOgH,EAAQiyC,EAAUiX,GACxC/wD,EAAImI,YACJnI,EAAI4I,SACJ5I,EAAI0G,WAyKY6vD,CAAejvE,EAAI2xC,EAAanL,EAAQijC,MAIhDlX,EAAWjhC,QAAS,CAEf7wB,IADLiY,EAAIsG,OACCve,EAAIT,EAAG+gC,YAAYvgC,OAAS,EAAGC,GAAK,EAAGA,IAAK,CACvCkxC,IAAAA,EAAc4gB,EAAWjhB,WAAWtxC,EAAG6f,WAAWpf,IACjD0R,EAAoBw/B,EAApBx/B,MAAOmR,EAAaquB,EAAbruB,UACTA,GAAcnR,IAGnBuG,EAAI4K,UAAYA,EAChB5K,EAAI2K,YAAclR,EAClBuG,EAAI+5B,YAAYd,EAAYhJ,YAC5BjwB,EAAIg6B,eAAiBf,EAAY/I,iBACjCpC,EAASxmC,EAAGsyD,8BAA8B1vC,EAAK4iB,MAAM/wB,QAAUzU,EAAGD,IAAMC,EAAG6B,KAC3E0oB,EAAWvqB,EAAG2sE,iBAAiBlsE,EAAG+lC,GAClC9tB,EAAIiI,YACJjI,EAAIoI,OAAO9gB,EAAG+xD,QAAS/xD,EAAGgyD,SAC1Bt5C,EAAIuI,OAAOsJ,EAAS9kB,EAAG8kB,EAAStO,GAChCvD,EAAI4I,UAER5I,EAAI0G,aAn9YC,CAAA,IAAA,aAu9Yb,MAAA,WACUpf,IAAAA,EAAK,KACL0Y,EAAM1Y,EAAG0Y,IACTkK,EAAO5iB,EAAG2V,QACVywB,EAAWxjB,EAAK4iB,MAClB,GAACY,EAAS9U,QAAV,CAGE88B,IACF5nB,EAAQ7nB,EADNyvC,EAAapuD,EAAGkyD,cAAc,GAEpCx5C,EAAIsG,OACJtG,EAAI+H,UAAUzgB,EAAG+xD,QAAS/xD,EAAGgyD,SAC7Bt5C,EAAI9F,OAAOw7C,GACX11C,EAAIyK,UAAY,SAChBzK,EAAI0K,aAAe,SACnBpjB,EAAGwlC,MAAM5lC,QAAQ,SAACkB,EAAMmU,GAChBA,GAAU,IAAVA,GAAgB2N,EAAKnO,QAArBQ,CAGE08B,IAAAA,EAAcvL,EAASkL,WAAWtxC,EAAG6f,WAAW5K,IAChDw6B,EAAWxiB,GAAO0kB,EAAYx5B,MAEhCw5B,GADJnL,EAASxmC,EAAGsyD,8BAA8BtyD,EAAGwlC,MAAMvwB,GAAOlC,OACtD4+B,EAAYw9B,kBAAmB,CAC/BxwD,EAAQjG,EAAIgG,YAAY5d,EAAKohC,OAAOvjB,MACpCjG,EAAIwK,UAAYyuB,EAAYq9B,cACtBr/C,IAAAA,EAAU3C,GAAU2kB,EAAY26B,iBACtC5zD,EAAI25B,UACC1zB,EAAQ,EAAIgR,EAAQhxB,MACpB6nC,EAASiJ,EAASp3B,KAAO,EAAIsX,EAAQhO,IACtChD,EAAQgR,EAAQhR,MAChB8wB,EAASp3B,KAAOsX,EAAQ3P,QAGhC0C,GAAWhK,EAAK5X,EAAKohC,MAAO,GAAIsE,EAAQiJ,EAAU,CAC9Ct9B,MAAOw/B,EAAYx/B,WAG3BuG,EAAI0G,aA5/YK,CAAA,IAAA,YA+/Yb,MAAA,gBA//Ya,EAAA,GAmgZjB0tD,GAAkBv5D,GAAK,eACvBu5D,GAAkBv1D,SAAW,CACzB+Z,SAAS,EACT89C,SAAS,EACT7kD,SAAU,YACVgoC,WAAY,CACRjhC,SAAS,EACThO,UAAW,EACXqlB,WAAY,GACZC,iBAAkB,GAEtBP,KAAM,CACFmqB,UAAU,GAEdpE,WAAY,EACZ5oB,MAAO,CACH2pC,mBAAmB,EACnBH,cAAe,yBACf1C,gBAAiB,EACjBrvE,SAAUipC,GAAMb,WAAWC,SAE/BmtB,YAAa,CACTuc,mBAAe7vE,EACfmtE,gBAAiB,EACjBh7C,SAAS,EACTnZ,KAAM,CACFE,KAAM,IAEVpb,SAASilC,SAAAA,GACEA,OAAAA,GAEXvS,QAAS,IAGjBm9C,GAAkBroC,cAAgB,CACV,mBAAA,cACC,oBAAA,QACN,cAAA,SAEnBqoC,GAAkB/1D,YAAc,CAC5Bw7C,WAAY,CACR/3C,UAAW,SAIb60D,IAAAA,GAAY,CACdC,YAAa,CAACC,QAAQ,EAAMl3D,KAAM,EAAGm3D,MAAO,KAC5CC,OAAQ,CAACF,QAAQ,EAAMl3D,KAAM,IAAMm3D,MAAO,IAC1CE,OAAQ,CAACH,QAAQ,EAAMl3D,KAAM,IAAOm3D,MAAO,IAC3CG,KAAM,CAACJ,QAAQ,EAAMl3D,KAAM,KAASm3D,MAAO,IAC3CI,IAAK,CAACL,QAAQ,EAAMl3D,KAAM,MAAUm3D,MAAO,IAC3CK,KAAM,CAACN,QAAQ,EAAOl3D,KAAM,OAAWm3D,MAAO,GAC9CM,MAAO,CAACP,QAAQ,EAAMl3D,KAAM,OAASm3D,MAAO,IAC5CO,QAAS,CAACR,QAAQ,EAAOl3D,KAAM,OAASm3D,MAAO,GAC/CQ,KAAM,CAACT,QAAQ,EAAMl3D,KAAM,SAEzB43D,GAASv/D,OAAOD,KAAK4+D,IAElBa,SAAAA,GAAO1tE,EAAGC,GACRD,OAAAA,EAAIC,EAGNw+B,SAAAA,GAAM1nB,EAAOhI,GACdiC,GAAAA,GAAcjC,GACP,OAAA,KAEL4+D,IAAAA,EAAU52D,EAAM62D,SAChBz6D,EAAU4D,EAAM5D,QAAQ06D,KACvBC,EAA6B36D,EAA7B26D,OAAQ/sE,EAAqBoS,EAArBpS,MAAOgtE,EAAc56D,EAAd46D,WAClBx9D,EAAQxB,EASRwB,MARkB,mBAAXu9D,IACPv9D,EAAQu9D,EAAOv9D,IAEda,GAAeb,KAChBA,EAA0B,iBAAXu9D,EACTH,EAAQlvC,MAAMluB,EAAOu9D,GACrBH,EAAQlvC,MAAMluB,IAEV,OAAVA,EACO,MAEPxP,IACAwP,EAAkB,SAAVxP,IAAqBuY,GAASy0D,KAA8B,IAAfA,EAE/CJ,EAAQK,QAAQz9D,EAAOxP,GADvB4sE,EAAQK,QAAQz9D,EAAO,UAAWw9D,KAGpCx9D,GAGH09D,SAAAA,GAA0BC,EAAS3wE,EAAK8B,EAAK8uE,GAE7C,IADC97D,IAAAA,EAAOo7D,GAAMzvE,OACVC,EAAIwvE,GAAMx6D,QAAQi7D,GAAUjwE,EAAIoU,EAAO,IAAKpU,EAAG,CAC9CmwE,IAAAA,EAAWvB,GAAUY,GAAMxvE,IAC3B03B,EAASy4C,EAASpB,MAAQoB,EAASpB,MAAQ37D,OAAOg9D,iBACpDD,GAAAA,EAASrB,QAAUzvE,KAAK4nC,MAAM7lC,EAAM9B,IAAQo4B,EAASy4C,EAASv4D,QAAUs4D,EACjEV,OAAAA,GAAMxvE,GAGdwvE,OAAAA,GAAMp7D,EAAO,GAqBfi8D,SAAAA,GAAQtrC,EAAO6qC,EAAMU,GACtB,GAACA,GAEE,GAAIA,EAAWvwE,OAAQ,CACT2jB,IAAAA,EAAAA,GAAQ4sD,EAAYV,GAA9B7rD,EAAAA,EAAAA,GAAIF,EAAAA,EAAAA,GAEXkhB,EADkBurC,EAAWvsD,IAAO6rD,EAAOU,EAAWvsD,GAAMusD,EAAWzsD,KACpD,QAJnBkhB,EAAM6qC,IAAQ,EAsBbW,SAAAA,GAAoBz3D,EAAOlC,EAAQ45D,GAClCzrC,IAGF/kC,EAAGsS,EAHDyyB,EAAQ,GACRvjC,EAAM,GACN4S,EAAOwC,EAAO7W,OAEfC,IAAAA,EAAI,EAAGA,EAAIoU,IAAQpU,EAEpBwB,EADA8Q,EAAQsE,EAAO5W,IACFA,EACb+kC,EAAM/jC,KAAK,CACPsR,MAAAA,EACAi0B,OAAO,IAGPnyB,OAAS,IAATA,GAAeo8D,EA3BlBC,SAAc33D,EAAOisB,EAAOvjC,EAAKgvE,GAChCd,IAGFnpC,EAAO/xB,EAHLk7D,EAAU52D,EAAM62D,SAChBhpC,GAAS+oC,EAAQK,QAAQhrC,EAAM,GAAGzyB,MAAOk+D,GACzC5pC,EAAO7B,EAAMA,EAAMhlC,OAAS,GAAGuS,MAEhCi0B,IAAAA,EAAQI,EAAOJ,GAASK,EAAML,GAASmpC,EAAQzqD,IAAIshB,EAAO,EAAGiqC,IAC9Dh8D,EAAQhT,EAAI+kC,KACC,IACTxB,EAAMvwB,GAAO+xB,OAAQ,GAGtBxB,OAAAA,EAgBqC0rC,CAAc33D,EAAOisB,EAAOvjC,EAAKgvE,GAAzCzrC,EAGlC2rC,IAAAA,GAlqZW,SAAA,GAAA,EAAA,EAkqZO3mC,IAlqZP,IAAA,EAAA,EAAA,GAmqZD9d,SAAAA,EAAAA,GAAO,IAAA,EAAA,OAAA,EAAA,KAAA,IACTA,EAAAA,EAAAA,KAAAA,KAAAA,IACD+e,OAAS,CACVptB,KAAM,GACNyiB,OAAQ,GACRzF,IAAK,IAEJ+1C,EAAAA,MAAQ,MACRC,EAAAA,gBAAalyE,EACbmyE,EAAAA,SAAW,GACXC,EAAAA,aAAc,EAVJ,EAnqZN,OAAA,EAAA,EAAA,CAAA,CAAA,IAAA,OAgrZb,MAAA,SAAK7sB,EAAW9hC,GACNytD,IAAAA,EAAO3rB,EAAU2rB,OAAS3rB,EAAU2rB,KAAO,IAC3CF,EAAU,KAAKC,SAAW,IAAIlnB,GAAUC,MAAMzE,EAAU8sB,SAASlyE,MACvE2W,GAAQo6D,EAAKoB,eAAgBtB,EAAQuB,WAC1BhtB,EAAAA,EAAAA,EAAAA,WAAAA,OAAAA,MAAAA,KAAAA,KAAAA,GACN6sB,KAAAA,YAAc3uD,EAAK+uD,aArrZf,CAAA,IAAA,QAwrZb,MAAA,SAAMhvC,EAAK1tB,GACH0tB,YAAQxjC,IAARwjC,EACO,KAEJ1B,GAAM,KAAM0B,KA5rZV,CAAA,IAAA,eA+rZb,MAAA,WACI,EAAA,EAAA,EAAA,WAAA,eAAA,MAAA,KAAA,MACK8I,KAAAA,OAAS,CACVptB,KAAM,GACNyiB,OAAQ,GACRzF,IAAK,MApsZA,CAAA,IAAA,sBAwsZb,MAAA,WACUr7B,IAAAA,EAAK,KACL2V,EAAU3V,EAAG2V,QACbw6D,EAAUnwE,EAAGowE,SACbrnB,EAAOpzC,EAAQ06D,KAAKtnB,MAAQ,MACO/oD,EAAAA,EAAG0hC,gBAAvC3hC,EAAAA,EAAAA,IAAK8B,EAAAA,EAAAA,IAAK8/B,EAAAA,EAAAA,WAAYC,EAAAA,EAAAA,WAElBgwC,SAAAA,EAAaxpC,GACbzG,GAAe5lB,MAAMqsB,EAAOroC,OAC7BA,EAAMD,KAAKC,IAAIA,EAAKqoC,EAAOroC,MAE1B6hC,GAAe7lB,MAAMqsB,EAAOvmC,OAC7BA,EAAM/B,KAAK+B,IAAIA,EAAKumC,EAAOvmC,MAI9B8/B,GAAeC,IAChBgwC,EAAa5xE,EAAG6xE,mBACO,UAAnBl8D,EAAQyyB,QAA+C,WAAzBzyB,EAAQ6vB,MAAMrwB,QAC5Cy8D,EAAa5xE,EAAG+rC,WAAU,KAGlChsC,EAAM6T,GAAe7T,KAASgc,MAAMhc,GAAOA,GAAOowE,EAAQK,QAAQrwE,KAAKC,MAAO2oD,GAC9ElnD,EAAM+R,GAAe/R,KAASka,MAAMla,GAAOA,GAAOsuE,EAAQ2B,MAAM3xE,KAAKC,MAAO2oD,GAAQ,EACpF/oD,EAAGD,IAAMD,KAAKC,IAAIA,EAAK8B,EAAM,GAC7B7B,EAAG6B,IAAM/B,KAAK+B,IAAI9B,EAAM,EAAG8B,KAjuZlB,CAAA,IAAA,kBAouZb,MAAA,WACUqiC,IAAAA,EAAM,KAAK6tC,qBACbhyE,EAAM8T,OAAOgH,kBACbhZ,EAAMgS,OAAO4tB,kBAKV,OAJHyC,EAAI1jC,SACJT,EAAMmkC,EAAI,GACVriC,EAAMqiC,EAAIA,EAAI1jC,OAAS,IAEpB,CAACT,IAAAA,EAAK8B,IAAAA,KA5uZJ,CAAA,IAAA,aA+uZb,MAAA,WACU7B,IAAAA,EAAK,KACL2V,EAAU3V,EAAG2V,QACbq8D,EAAWr8D,EAAQ06D,KACnBjqC,EAAWzwB,EAAQ6vB,MACnBurC,EAAiC,WAApB3qC,EAASjxB,OAAsBnV,EAAG+xE,qBAAuB/xE,EAAGiyE,YACxD,UAAnBt8D,EAAQyyB,QAAsB2oC,EAAWvwE,SACzCR,EAAGD,IAAMC,EAAGorC,UAAY2lC,EAAW,GACnC/wE,EAAG6B,IAAM7B,EAAGmrC,UAAY4lC,EAAWA,EAAWvwE,OAAS,IAErDT,IAAAA,EAAMC,EAAGD,IAETylC,EAAQ7gB,GAAeosD,EAAYhxE,EAD7BC,EAAG6B,KAWRmvE,OATPhxE,EAAGoxE,MAAQY,EAASjpB,OAAS3iB,EAASD,SAChCsqC,GAA0BuB,EAAStB,QAAS1wE,EAAGD,IAAKC,EAAG6B,IAAK7B,EAAGkyE,kBAAkBnyE,IArJtFoyE,SAA2B54D,EAAOy0B,EAAU0iC,EAAS3wE,EAAK8B,GAC1D,IAAA,IAAIpB,EAAIwvE,GAAMzvE,OAAS,EAAGC,GAAKwvE,GAAMx6D,QAAQi7D,GAAUjwE,IAAK,CACvDsoD,IAAAA,EAAOknB,GAAMxvE,GACf4uE,GAAAA,GAAUtmB,GAAMwmB,QAAUh2D,EAAM62D,SAAStoC,KAAKjmC,EAAK9B,EAAKgpD,IAAS/a,EAAW,EACrE+a,OAAAA,EAGRknB,OAAAA,GAAMS,EAAUT,GAAMx6D,QAAQi7D,GAAW,GA+ItCyB,CAA2BnyE,EAAIwlC,EAAMhlC,OAAQwxE,EAAStB,QAAS1wE,EAAGD,IAAKC,EAAG6B,MAChF7B,EAAGqxE,WAAcjrC,EAASY,MAAMC,SAAwB,SAAbjnC,EAAGoxE,MA7I7CgB,SAAmBrpB,GACnB,IAAA,IAAItoD,EAAIwvE,GAAMx6D,QAAQszC,GAAQ,EAAGl0C,EAAOo7D,GAAMzvE,OAAQC,EAAIoU,IAAQpU,EAC/D4uE,GAAAA,GAAUY,GAAMxvE,IAAI8uE,OACbU,OAAAA,GAAMxvE,GA2IX2xE,CAAmBpyE,EAAGoxE,YADqCjyE,EAEjEa,EAAGqyE,YAAYtB,GACXp7D,EAAQlB,SACR+wB,EAAM/wB,UAEHu8D,GAAoBhxE,EAAIwlC,EAAOxlC,EAAGqxE,cArwZhC,CAAA,IAAA,cAwwZb,MAAA,SAAYN,GACF/wE,IAGFonC,EAAOC,EAHLrnC,EAAK,KACPxB,EAAQ,EACRC,EAAM,EAENuB,EAAG2V,QAAQ6wB,QAAUuqC,EAAWvwE,SAChC4mC,EAAQpnC,EAAGsyE,mBAAmBvB,EAAW,IAErCvyE,EADsB,IAAtBuyE,EAAWvwE,OACH,EAAI4mC,GAEHpnC,EAAGsyE,mBAAmBvB,EAAW,IAAM3pC,GAAS,EAE7DC,EAAOrnC,EAAGsyE,mBAAmBvB,EAAWA,EAAWvwE,OAAS,IAExD/B,EADsB,IAAtBsyE,EAAWvwE,OACL6mC,GAECA,EAAOrnC,EAAGsyE,mBAAmBvB,EAAWA,EAAWvwE,OAAS,KAAO,GAG5E+xE,IAAAA,EAAQxB,EAAWvwE,OAAS,EAAI,GAAM,IAC5ChC,EAAQyf,GAAYzf,EAAO,EAAG+zE,GAC9B9zE,EAAMwf,GAAYxf,EAAK,EAAG8zE,GAC1BvyE,EAAGsxE,SAAW,CAAC9yE,MAAAA,EAAOC,IAAAA,EAAK05B,OAAQ,GAAK35B,EAAQ,EAAIC,MA9xZ3C,CAAA,IAAA,YAiyZb,MAAA,WACUuB,IAYFqwE,EAAM7vC,EAZJxgC,EAAK,KACLmwE,EAAUnwE,EAAGowE,SACbrwE,EAAMC,EAAGD,IACT8B,EAAM7B,EAAG6B,IACT8T,EAAU3V,EAAG2V,QACbq8D,EAAWr8D,EAAQ06D,KACnBhnC,EAAQ2oC,EAASjpB,MAAQ0nB,GAA0BuB,EAAStB,QAAS3wE,EAAK8B,EAAK7B,EAAGkyE,kBAAkBnyE,IACpG2qE,EAAWz2D,GAAe+9D,EAAStH,SAAU,GAC7C1hB,EAAoB,SAAV3f,GAAmB2oC,EAASzB,WACtCiC,EAAa12D,GAASktC,KAAwB,IAAZA,EAClCxjB,EAAQ,GACV4B,EAAQrnC,EAMRowE,GAJAqC,IACAprC,GAAS+oC,EAAQK,QAAQppC,EAAO,UAAW4hB,IAE/C5hB,GAAS+oC,EAAQK,QAAQppC,EAAOorC,EAAa,MAAQnpC,GACjD8mC,EAAQroC,KAAKjmC,EAAK9B,EAAKspC,GAAS,IAASqhC,EACnC,MAAA,IAAIh1B,MAAM31C,EAAM,QAAU8B,EAAM,uCAAyC6oE,EAAW,IAAMrhC,GAE9F0nC,IAAAA,EAAsC,SAAzBp7D,EAAQ6vB,MAAMrwB,QAAqBnV,EAAGyyE,oBACpDpC,IAAAA,EAAOjpC,EAAO5G,EAAQ,EAAG6vC,EAAOxuE,EAAKwuE,GAAQF,EAAQzqD,IAAI2qD,EAAM3F,EAAUrhC,GAAQ7I,IAClFswC,GAAQtrC,EAAO6qC,EAAMU,GAKlBrgE,OAHH2/D,IAASxuE,GAA0B,UAAnB8T,EAAQyyB,QAAgC,IAAV5H,GAC9CswC,GAAQtrC,EAAO6qC,EAAMU,GAElBrgE,OAAOD,KAAK+0B,GAAO3pB,KAAK,SAACrZ,EAAGC,GAAMD,OAAAA,EAAIC,IAAGR,IAAI,SAAAwD,GAAK,OAACA,MA7zZjD,CAAA,IAAA,mBAg0Zb,MAAA,SAAiBsN,GACP/S,IACAmwE,EADK,KACQC,SACb4B,EAFK,KAESr8D,QAAQ06D,KACxB2B,OAAAA,EAASU,cACFvC,EAAQ/qC,OAAOryB,EAAOi/D,EAASU,eAEnCvC,EAAQ/qC,OAAOryB,EAAOi/D,EAASP,eAAekB,YAv0Z5C,CAAA,IAAA,sBA00Zb,MAAA,SAAoBtC,EAAMp7D,EAAOuwB,EAAOJ,GAC9BplC,IACA2V,EADK,KACQA,QACb+7D,EAAU/7D,EAAQ06D,KAAKoB,eACvB1oB,EAHK,KAGKqoB,MACVH,EAJK,KAIUI,WACfuB,EAAc7pB,GAAQ2oB,EAAQ3oB,GAC9B8pB,EAAc5B,GAAaS,EAAQT,GACnCnwE,EAAO0kC,EAAMvwB,GACb+xB,EAAQiqC,GAAa4B,GAAe/xE,GAAQA,EAAKkmC,MACjD9E,EATK,KASMkuC,SAAShrC,OAAOirC,EAAMjrC,IAAW4B,EAAQ6rC,EAAcD,IAClE3tC,EAAYtvB,EAAQ6vB,MAAMvoC,SACzBgoC,OAAAA,EAAYA,EAAU/C,EAAOjtB,EAAOuwB,GAAStD,IAt1Z3C,CAAA,IAAA,qBAy1Zb,MAAA,SAAmBsD,GACX/kC,IAAAA,EAAGoU,EAAM/T,EACRL,IAAAA,EAAI,EAAGoU,EAAO2wB,EAAMhlC,OAAQC,EAAIoU,IAAQpU,GACzCK,EAAO0kC,EAAM/kC,IACRyhC,MAAQ,KAAK4wC,oBAAoBhyE,EAAKiS,MAAOtS,EAAG+kC,KA71ZhD,CAAA,IAAA,qBAi2Zb,MAAA,SAAmBzyB,GAERA,OAAU,OAAVA,EAAiBsuB,KAAOtuB,EADpB,KAC+BhT,MAD/B,KAC0C8B,IAD1C,KACmD9B,OAn2ZrD,CAAA,IAAA,mBAs2Zb,MAAA,SAAiBgT,GACP/S,IACA+yE,EADK,KACQzB,SACb76D,EAFK,KAEI67D,mBAAmBv/D,GAC3B/S,OAHI,KAGDitD,oBAAoB8lB,EAAQv0E,MAAQiY,GAAOs8D,EAAQ56C,UA12ZpD,CAAA,IAAA,mBA62Zb,MAAA,SAAiB3Y,GACPxf,IAAAA,EAAK,KACL+yE,EAAU/yE,EAAGsxE,SACb76D,EAAMzW,EAAGkqE,mBAAmB1qD,GAASuzD,EAAQ56C,OAAS46C,EAAQt0E,IAC7DuB,OAAAA,EAAGD,IAAM0W,GAAOzW,EAAG6B,IAAM7B,EAAGD,OAj3Z1B,CAAA,IAAA,gBAo3Zb,MAAA,SAAcmiC,GACJliC,IACAgzE,EADK,KACUr9D,QAAQ6vB,MACvBytC,EAFK,KAEev6D,IAAIgG,YAAYwjB,GAAOvjB,MAC3CvB,EAAQX,GAHH,KAGgBgU,eAAiBuiD,EAAUjqC,YAAciqC,EAAUlqC,aACxEoqC,EAAcpzE,KAAKkhB,IAAI5D,GACvB+1D,EAAcrzE,KAAKihB,IAAI3D,GACvBg2D,EANK,KAManjC,wBAAwB,GAAG53B,KAC5C,MAAA,CACH9T,EAAI0uE,EAAiBC,EAAgBE,EAAeD,EACpDzvE,EAAIuvE,EAAiBE,EAAgBC,EAAeF,KA93Z/C,CAAA,IAAA,oBAk4Zb,MAAA,SAAkBG,GACRrzE,IAAAA,EAAK,KACLgyE,EAAWhyE,EAAG2V,QAAQ06D,KACtBoB,EAAiBO,EAASP,eAC1BrsC,EAASqsC,EAAeO,EAASjpB,OAAS0oB,EAAenC,YACzDgE,EAAetzE,EAAG8yE,oBAAoBO,EAAa,EAAGrC,GAAoBhxE,EAAI,CAACqzE,GAAcrzE,EAAGqxE,YAAajsC,GAC7G/sB,EAAOrY,EAAGuzE,cAAcD,GACxB3C,EAAW7wE,KAAKyb,MAAMvb,EAAGywB,eAAiBzwB,EAAG2e,MAAQtG,EAAK9T,EAAIvE,EAAGggB,OAAS3H,EAAK3U,GAAK,EACnFitE,OAAAA,EAAW,EAAIA,EAAW,IA14ZxB,CAAA,IAAA,oBA64Zb,MAAA,WACU3wE,IAEFS,EAAGoU,EAFD7U,EAAK,KACP+wE,EAAa/wE,EAAGyrC,OAAOptB,MAAQ,GAE/B0yD,GAAAA,EAAWvwE,OACJuwE,OAAAA,EAELllC,IAAAA,EAAQ7rC,EAAG8rC,0BACb9rC,GAAAA,EAAGuxE,aAAe1lC,EAAMrrC,OAChBR,OAAAA,EAAGyrC,OAAOptB,KAAOwtB,EAAM,GAAG/hB,WAAW0/B,mBAAmBxpD,GAE/DS,IAAAA,EAAI,EAAGoU,EAAOg3B,EAAMrrC,OAAQC,EAAIoU,IAAQpU,EACzCswE,EAAaA,EAAWjgD,OAAO+a,EAAMprC,GAAGqpB,WAAW0/B,mBAAmBxpD,IAElEA,OAAAA,EAAGyrC,OAAOptB,KAAOre,EAAG66C,UAAUk2B,KA35Z7B,CAAA,IAAA,qBA85Zb,MAAA,WACU/wE,IAEFS,EAAGoU,EAFD7U,EAAK,KACL+wE,EAAa/wE,EAAGyrC,OAAO3K,QAAU,GAEnCiwC,GAAAA,EAAWvwE,OACJuwE,OAAAA,EAELjwC,IAAAA,EAAS9gC,EAAG+gC,YACbtgC,IAAAA,EAAI,EAAGoU,EAAOisB,EAAOtgC,OAAQC,EAAIoU,IAAQpU,EAC1CswE,EAAWtvE,KAAKw/B,GAAMjhC,EAAI8gC,EAAOrgC,KAE7BT,OAAAA,EAAGyrC,OAAO3K,OAAS9gC,EAAGuxE,YAAcR,EAAa/wE,EAAG66C,UAAUk2B,KAz6Z7D,CAAA,IAAA,YA46Zb,MAAA,SAAU15D,GACCmO,OAAAA,GAAanO,EAAOwE,KAAKq0D,SA76ZvB,EAAA,GAq8ZR5U,SAAAA,GAAYl3C,EAAO1R,EAAK+B,GACzB++D,IAAAA,EAAYC,EAAYC,EAAYC,EACpCl/D,GAAAA,EACA++D,EAAa1zE,KAAKyb,MAAM7I,GACxB+gE,EAAa3zE,KAAK4nC,KAAKh1B,GACvBghE,EAAatvD,EAAMovD,GACnBG,EAAavvD,EAAMqvD,OAChB,CACG93D,IAAAA,EAASwI,GAAQC,EAAO1R,GAC9BghE,EAAa/3D,EAAO6I,GACpBmvD,EAAah4D,EAAO2I,GACpBkvD,EAAapvD,EAAMsvD,GACnBD,EAAarvD,EAAMuvD,GAEjBC,IAAAA,EAAOH,EAAaD,EACnBI,OAAAA,EAAOF,GAAcC,EAAaD,IAAehhE,EAAM8gE,GAAcI,EAAOF,EAnCvFvC,GAAU59D,GAAK,OACf49D,GAAU55D,SAAW,CACjB6wB,OAAQ,OACRopC,SAAU,GACVnB,KAAM,CACFC,QAAQ,EACRvnB,MAAM,EACNxlD,OAAO,EACPgtE,YAAY,EACZG,QAAS,cACTe,eAAgB,IAEpBjsC,MAAO,CACHrwB,OAAQ,OACR6xB,MAAO,CACHC,SAAS,KAuBf4sC,IAAAA,GAv9ZW,SAAA,GAAA,EAAA,EAu9Za1C,IAv9Zb,IAAA,EAAA,EAAA,GAw9ZDzkD,SAAAA,EAAAA,GAAO,IAAA,EAAA,OAAA,EAAA,KAAA,IACTA,EAAAA,EAAAA,KAAAA,KAAAA,IACDonD,OAAS,GACTC,EAAAA,eAAY50E,EAHF,EAx9ZN,OAAA,EAAA,EAAA,CAAA,CAAA,IAAA,cA89Zb,MAAA,WACUa,IAAAA,EAAK,KACL+wE,EAAa/wE,EAAGg0E,yBACtBh0E,EAAG8zE,OAAS9zE,EAAGi0E,iBAAiBlD,GAChC/wE,EAAG+zE,UAAY/zE,EAAG8zE,OAAOtzE,OAAS,EAChBuwE,EAAAA,EAAAA,EAAAA,WAAAA,cAAAA,MAAAA,KAAAA,KAAAA,KAn+ZT,CAAA,IAAA,mBAs+Zb,MAAA,SAAiBA,GACP/wE,IACCD,EADI,KACJA,IAAK8B,EADD,KACCA,IACR,IAACkvE,EAAWvwE,OACL,MAAA,CACH,CAAC6vE,KAAMtwE,EAAK0W,IAAK,GACjB,CAAC45D,KAAMxuE,EAAK4U,IAAK,IAGnBlW,IACFE,EAAGoU,EAAMw0C,EADP9oD,EAAQ,CAACR,GAEVU,IAAAA,EAAI,EAAGoU,EAAOk8D,EAAWvwE,OAAQC,EAAIoU,IAAQpU,GAC9C4oD,EAAO0nB,EAAWtwE,IACPV,GAAOspD,EAAOxnD,GACrBtB,EAAMkB,KAAK4nD,GAIZ9oD,OADPA,EAAMkB,KAAKI,GACJtB,IAx/ZE,CAAA,IAAA,yBA2/Zb,MAAA,WACUP,IAAAA,EAAK,KACP+wE,EAAa/wE,EAAGyrC,OAAOpQ,KAAO,GAC9B01C,GAAAA,EAAWvwE,OACJuwE,OAAAA,EAEL1yD,IAAAA,EAAOre,EAAGyyE,oBACVvwC,EAAQliC,EAAG+xE,qBAOVhB,OALHA,EADA1yD,EAAK7d,QAAU0hC,EAAM1hC,OACRR,EAAG66C,UAAUx8B,EAAKyS,OAAOoR,IAEzB7jB,EAAK7d,OAAS6d,EAAO6jB,EAEtC6uC,EAAa/wE,EAAGyrC,OAAOpQ,IAAM01C,IAxgapB,CAAA,IAAA,mBA4gab,MAAA,SAAiBh+D,EAAOkC,GACdjV,IAAAA,EAAK,KACL+yE,EAAU/yE,EAAGsxE,SACb76D,EAAMzW,EAAGuxE,aAAevxE,EAAG+zE,UAAY,IAAMvgE,GAAcyB,GAC3DA,EAAQjV,EAAG+zE,UAAY/zE,EAAGsyE,mBAAmBv/D,GAC5C/S,OAAAA,EAAGitD,oBAAoB8lB,EAAQv0E,MAAQiY,GAAOs8D,EAAQ56C,UAjhapD,CAAA,IAAA,qBAohab,MAAA,SAAmBplB,GACRuoD,OAAAA,GAAY,KAAKwY,OAAQ/gE,GAAS,KAAKghE,YArharC,CAAA,IAAA,mBAwhab,MAAA,SAAiBv0D,GACPxf,IACA+yE,EADK,KACQzB,SACblhC,EAFK,KAEQ85B,mBAAmB1qD,GAASuzD,EAAQ56C,OAAS46C,EAAQt0E,IACjE68D,OAAAA,GAHI,KAGWwY,OAAQ1jC,EAAU,KAAK2jC,WAAW,OA5ha/C,EAAA,GAgiajBF,GAAgBtgE,GAAK,aACrBsgE,GAAgBt8D,SAAW45D,GAAU55D,SAEjCiC,IAAAA,GAAsB9I,OAAO6gB,OAAO,CACpCmE,UAAW,KACXm0C,cAAeA,GACf4B,YAAaA,GACbI,iBAAkBA,GAClBiB,kBAAmBA,GACnBqE,UAAWA,GACX0C,gBAAiBA,KAwBd/2E,OArBPA,GAAM+/C,SAASW,GAAahkC,GAAQvB,GAAUoB,IAC9Cvc,GAAMm/C,QAAcA,EAAAA,GAAAA,IACpBn/C,GAAMosD,UAAYA,GAClBpsD,GAAM07B,UAAYA,GAClB17B,GAAMu9B,WAAaA,GACnBv9B,GAAM+B,SAAWA,EACjB/B,GAAM0gD,YAAcD,GAASC,YAAYj9C,MACzCzD,GAAM4gC,kBAAoBA,GAC1B5gC,GAAMwnC,QAAUA,GAChBxnC,GAAMmb,SAAWA,GACjBnb,GAAMivB,YAAcA,GACpBjvB,GAAM8yB,QAAUA,GAChB9yB,GAAM24B,UAAYA,GAClB34B,GAAM0tC,MAAQA,GACd1tC,GAAMopC,MAAQA,GACdx1B,OAAOW,OAAOvU,GAAO0gD,GAAahkC,GAAQvB,GAAUoB,GAASoc,IAC7D34B,GAAMA,MAAQA,GACQ,oBAAXE,SACPA,OAAOF,MAAQA,IAGZA","file":"chart.f9139ac1.js","sourceRoot":"..\\src","sourcesContent":["/*!\r\n * Chart.js v3.0.1\r\n * https://www.chartjs.org\r\n * (c) 2021 Chart.js Contributors\r\n * Released under the MIT License\r\n */\r\n(function (global, factory) {\r\n    typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :\r\n        typeof define === 'function' && define.amd ? define(factory) :\r\n            (global = typeof globalThis !== 'undefined' ? globalThis : global || self, global.Chart = factory());\r\n}(this, (function () {\r\n    'use strict';\r\n\r\n    function fontString(pixelSize, fontStyle, fontFamily) {\r\n        return fontStyle + ' ' + pixelSize + 'px ' + fontFamily;\r\n    }\r\n\r\n    const requestAnimFrame = (function () {\r\n        if (typeof window === 'undefined') {\r\n            return function (callback) {\r\n                return callback();\r\n            };\r\n        }\r\n        return window.requestAnimationFrame;\r\n    }());\r\n\r\n    function throttled(fn, thisArg, updateFn) {\r\n        const updateArgs = updateFn || ((args) => Array.prototype.slice.call(args));\r\n        let ticking = false;\r\n        let args = [];\r\n        return function (...rest) {\r\n            args = updateArgs(rest);\r\n            if (!ticking) {\r\n                ticking = true;\r\n                requestAnimFrame.call(window, () => {\r\n                    ticking = false;\r\n                    fn.apply(thisArg, args);\r\n                });\r\n            }\r\n        };\r\n    }\r\n\r\n    function debounce(fn, delay) {\r\n        let timeout;\r\n        return function () {\r\n            if (delay) {\r\n                clearTimeout(timeout);\r\n                timeout = setTimeout(fn, delay);\r\n            } else {\r\n                fn();\r\n            }\r\n            return delay;\r\n        };\r\n    }\r\n\r\n    const _toLeftRightCenter = (align) => align === 'start' ? 'left' : align === 'end' ? 'right' : 'center';\r\n    const _alignStartEnd = (align, start, end) => align === 'start' ? start : align === 'end' ? end : (start + end) / 2;\r\n    const _textX = (align, left, right) => align === 'right' ? right : align === 'center' ? (left + right) / 2 : left;\r\n\r\n    class Animator {\r\n        constructor() {\r\n            this._request = null;\r\n            this._charts = new Map();\r\n            this._running = false;\r\n            this._lastDate = undefined;\r\n        }\r\n\r\n        _notify(chart, anims, date, type) {\r\n            const callbacks = anims.listeners[type];\r\n            const numSteps = anims.duration;\r\n            callbacks.forEach(fn => fn({\r\n                chart,\r\n                numSteps,\r\n                currentStep: Math.min(date - anims.start, numSteps)\r\n            }));\r\n        }\r\n\r\n        _refresh() {\r\n            const me = this;\r\n            if (me._request) {\r\n                return;\r\n            }\r\n            me._running = true;\r\n            me._request = requestAnimFrame.call(window, () => {\r\n                me._update();\r\n                me._request = null;\r\n                if (me._running) {\r\n                    me._refresh();\r\n                }\r\n            });\r\n        }\r\n\r\n        _update(date = Date.now()) {\r\n            const me = this;\r\n            let remaining = 0;\r\n            me._charts.forEach((anims, chart) => {\r\n                if (!anims.running || !anims.items.length) {\r\n                    return;\r\n                }\r\n                const items = anims.items;\r\n                let i = items.length - 1;\r\n                let draw = false;\r\n                let item;\r\n                for (; i >= 0; --i) {\r\n                    item = items[i];\r\n                    if (item._active) {\r\n                        if (item._total > anims.duration) {\r\n                            anims.duration = item._total;\r\n                        }\r\n                        item.tick(date);\r\n                        draw = true;\r\n                    } else {\r\n                        items[i] = items[items.length - 1];\r\n                        items.pop();\r\n                    }\r\n                }\r\n                if (draw) {\r\n                    chart.draw();\r\n                    me._notify(chart, anims, date, 'progress');\r\n                }\r\n                if (!items.length) {\r\n                    anims.running = false;\r\n                    me._notify(chart, anims, date, 'complete');\r\n                }\r\n                remaining += items.length;\r\n            });\r\n            me._lastDate = date;\r\n            if (remaining === 0) {\r\n                me._running = false;\r\n            }\r\n        }\r\n\r\n        _getAnims(chart) {\r\n            const charts = this._charts;\r\n            let anims = charts.get(chart);\r\n            if (!anims) {\r\n                anims = {\r\n                    running: false,\r\n                    items: [],\r\n                    listeners: {\r\n                        complete: [],\r\n                        progress: []\r\n                    }\r\n                };\r\n                charts.set(chart, anims);\r\n            }\r\n            return anims;\r\n        }\r\n\r\n        listen(chart, event, cb) {\r\n            this._getAnims(chart).listeners[event].push(cb);\r\n        }\r\n\r\n        add(chart, items) {\r\n            if (!items || !items.length) {\r\n                return;\r\n            }\r\n            this._getAnims(chart).items.push(...items);\r\n        }\r\n\r\n        has(chart) {\r\n            return this._getAnims(chart).items.length > 0;\r\n        }\r\n\r\n        start(chart) {\r\n            const anims = this._charts.get(chart);\r\n            if (!anims) {\r\n                return;\r\n            }\r\n            anims.running = true;\r\n            anims.start = Date.now();\r\n            anims.duration = anims.items.reduce((acc, cur) => Math.max(acc, cur._duration), 0);\r\n            this._refresh();\r\n        }\r\n\r\n        running(chart) {\r\n            if (!this._running) {\r\n                return false;\r\n            }\r\n            const anims = this._charts.get(chart);\r\n            if (!anims || !anims.running || !anims.items.length) {\r\n                return false;\r\n            }\r\n            return true;\r\n        }\r\n\r\n        stop(chart) {\r\n            const anims = this._charts.get(chart);\r\n            if (!anims || !anims.items.length) {\r\n                return;\r\n            }\r\n            const items = anims.items;\r\n            let i = items.length - 1;\r\n            for (; i >= 0; --i) {\r\n                items[i].cancel();\r\n            }\r\n            anims.items = [];\r\n            this._notify(chart, anims, Date.now(), 'complete');\r\n        }\r\n\r\n        remove(chart) {\r\n            return this._charts.delete(chart);\r\n        }\r\n    }\r\n\r\n    var animator = new Animator();\r\n\r\n    /*!\r\n * @kurkle/color v0.1.9\r\n * https://github.com/kurkle/color#readme\r\n * (c) 2020 Jukka Kurkela\r\n * Released under the MIT License\r\n */\r\n    const map = {\r\n        0: 0,\r\n        1: 1,\r\n        2: 2,\r\n        3: 3,\r\n        4: 4,\r\n        5: 5,\r\n        6: 6,\r\n        7: 7,\r\n        8: 8,\r\n        9: 9,\r\n        A: 10,\r\n        B: 11,\r\n        C: 12,\r\n        D: 13,\r\n        E: 14,\r\n        F: 15,\r\n        a: 10,\r\n        b: 11,\r\n        c: 12,\r\n        d: 13,\r\n        e: 14,\r\n        f: 15\r\n    };\r\n    const hex = '0123456789ABCDEF';\r\n    const h1 = (b) => hex[b & 0xF];\r\n    const h2 = (b) => hex[(b & 0xF0) >> 4] + hex[b & 0xF];\r\n    const eq = (b) => (((b & 0xF0) >> 4) === (b & 0xF));\r\n\r\n    function isShort(v) {\r\n        return eq(v.r) && eq(v.g) && eq(v.b) && eq(v.a);\r\n    }\r\n\r\n    function hexParse(str) {\r\n        var len = str.length;\r\n        var ret;\r\n        if (str[0] === '#') {\r\n            if (len === 4 || len === 5) {\r\n                ret = {\r\n                    r: 255 & map[str[1]] * 17,\r\n                    g: 255 & map[str[2]] * 17,\r\n                    b: 255 & map[str[3]] * 17,\r\n                    a: len === 5 ? map[str[4]] * 17 : 255\r\n                };\r\n            } else if (len === 7 || len === 9) {\r\n                ret = {\r\n                    r: map[str[1]] << 4 | map[str[2]],\r\n                    g: map[str[3]] << 4 | map[str[4]],\r\n                    b: map[str[5]] << 4 | map[str[6]],\r\n                    a: len === 9 ? (map[str[7]] << 4 | map[str[8]]) : 255\r\n                };\r\n            }\r\n        }\r\n        return ret;\r\n    }\r\n\r\n    function hexString(v) {\r\n        var f = isShort(v) ? h1 : h2;\r\n        return v\r\n            ? '#' + f(v.r) + f(v.g) + f(v.b) + (v.a < 255 ? f(v.a) : '')\r\n            : v;\r\n    }\r\n\r\n    function round(v) {\r\n        return v + 0.5 | 0;\r\n    }\r\n\r\n    const lim = (v, l, h) => Math.max(Math.min(v, h), l);\r\n\r\n    function p2b(v) {\r\n        return lim(round(v * 2.55), 0, 255);\r\n    }\r\n\r\n    function n2b(v) {\r\n        return lim(round(v * 255), 0, 255);\r\n    }\r\n\r\n    function b2n(v) {\r\n        return lim(round(v / 2.55) / 100, 0, 1);\r\n    }\r\n\r\n    function n2p(v) {\r\n        return lim(round(v * 100), 0, 100);\r\n    }\r\n\r\n    const RGB_RE = /^rgba?\\(\\s*([-+.\\d]+)(%)?[\\s,]+([-+.e\\d]+)(%)?[\\s,]+([-+.e\\d]+)(%)?(?:[\\s,/]+([-+.e\\d]+)(%)?)?\\s*\\)$/;\r\n\r\n    function rgbParse(str) {\r\n        const m = RGB_RE.exec(str);\r\n        let a = 255;\r\n        let r, g, b;\r\n        if (!m) {\r\n            return;\r\n        }\r\n        if (m[7] !== r) {\r\n            const v = +m[7];\r\n            a = 255 & (m[8] ? p2b(v) : v * 255);\r\n        }\r\n        r = +m[1];\r\n        g = +m[3];\r\n        b = +m[5];\r\n        r = 255 & (m[2] ? p2b(r) : r);\r\n        g = 255 & (m[4] ? p2b(g) : g);\r\n        b = 255 & (m[6] ? p2b(b) : b);\r\n        return {\r\n            r: r,\r\n            g: g,\r\n            b: b,\r\n            a: a\r\n        };\r\n    }\r\n\r\n    function rgbString(v) {\r\n        return v && (\r\n            v.a < 255\r\n                ? `rgba(${v.r}, ${v.g}, ${v.b}, ${b2n(v.a)})`\r\n                : `rgb(${v.r}, ${v.g}, ${v.b})`\r\n        );\r\n    }\r\n\r\n    const HUE_RE = /^(hsla?|hwb|hsv)\\(\\s*([-+.e\\d]+)(?:deg)?[\\s,]+([-+.e\\d]+)%[\\s,]+([-+.e\\d]+)%(?:[\\s,]+([-+.e\\d]+)(%)?)?\\s*\\)$/;\r\n\r\n    function hsl2rgbn(h, s, l) {\r\n        const a = s * Math.min(l, 1 - l);\r\n        const f = (n, k = (n + h / 30) % 12) => l - a * Math.max(Math.min(k - 3, 9 - k, 1), -1);\r\n        return [f(0), f(8), f(4)];\r\n    }\r\n\r\n    function hsv2rgbn(h, s, v) {\r\n        const f = (n, k = (n + h / 60) % 6) => v - v * s * Math.max(Math.min(k, 4 - k, 1), 0);\r\n        return [f(5), f(3), f(1)];\r\n    }\r\n\r\n    function hwb2rgbn(h, w, b) {\r\n        const rgb = hsl2rgbn(h, 1, 0.5);\r\n        let i;\r\n        if (w + b > 1) {\r\n            i = 1 / (w + b);\r\n            w *= i;\r\n            b *= i;\r\n        }\r\n        for (i = 0; i < 3; i++) {\r\n            rgb[i] *= 1 - w - b;\r\n            rgb[i] += w;\r\n        }\r\n        return rgb;\r\n    }\r\n\r\n    function rgb2hsl(v) {\r\n        const range = 255;\r\n        const r = v.r / range;\r\n        const g = v.g / range;\r\n        const b = v.b / range;\r\n        const max = Math.max(r, g, b);\r\n        const min = Math.min(r, g, b);\r\n        const l = (max + min) / 2;\r\n        let h, s, d;\r\n        if (max !== min) {\r\n            d = max - min;\r\n            s = l > 0.5 ? d / (2 - max - min) : d / (max + min);\r\n            h = max === r\r\n                ? ((g - b) / d) + (g < b ? 6 : 0)\r\n                : max === g\r\n                    ? (b - r) / d + 2\r\n                    : (r - g) / d + 4;\r\n            h = h * 60 + 0.5;\r\n        }\r\n        return [h | 0, s || 0, l];\r\n    }\r\n\r\n    function calln(f, a, b, c) {\r\n        return (\r\n            Array.isArray(a)\r\n                ? f(a[0], a[1], a[2])\r\n                : f(a, b, c)\r\n        ).map(n2b);\r\n    }\r\n\r\n    function hsl2rgb(h, s, l) {\r\n        return calln(hsl2rgbn, h, s, l);\r\n    }\r\n\r\n    function hwb2rgb(h, w, b) {\r\n        return calln(hwb2rgbn, h, w, b);\r\n    }\r\n\r\n    function hsv2rgb(h, s, v) {\r\n        return calln(hsv2rgbn, h, s, v);\r\n    }\r\n\r\n    function hue(h) {\r\n        return (h % 360 + 360) % 360;\r\n    }\r\n\r\n    function hueParse(str) {\r\n        const m = HUE_RE.exec(str);\r\n        let a = 255;\r\n        let v;\r\n        if (!m) {\r\n            return;\r\n        }\r\n        if (m[5] !== v) {\r\n            a = m[6] ? p2b(+m[5]) : n2b(+m[5]);\r\n        }\r\n        const h = hue(+m[2]);\r\n        const p1 = +m[3] / 100;\r\n        const p2 = +m[4] / 100;\r\n        if (m[1] === 'hwb') {\r\n            v = hwb2rgb(h, p1, p2);\r\n        } else if (m[1] === 'hsv') {\r\n            v = hsv2rgb(h, p1, p2);\r\n        } else {\r\n            v = hsl2rgb(h, p1, p2);\r\n        }\r\n        return {\r\n            r: v[0],\r\n            g: v[1],\r\n            b: v[2],\r\n            a: a\r\n        };\r\n    }\r\n\r\n    function rotate(v, deg) {\r\n        var h = rgb2hsl(v);\r\n        h[0] = hue(h[0] + deg);\r\n        h = hsl2rgb(h);\r\n        v.r = h[0];\r\n        v.g = h[1];\r\n        v.b = h[2];\r\n    }\r\n\r\n    function hslString(v) {\r\n        if (!v) {\r\n            return;\r\n        }\r\n        const a = rgb2hsl(v);\r\n        const h = a[0];\r\n        const s = n2p(a[1]);\r\n        const l = n2p(a[2]);\r\n        return v.a < 255\r\n            ? `hsla(${h}, ${s}%, ${l}%, ${b2n(v.a)})`\r\n            : `hsl(${h}, ${s}%, ${l}%)`;\r\n    }\r\n\r\n    const map$1 = {\r\n        x: 'dark',\r\n        Z: 'light',\r\n        Y: 're',\r\n        X: 'blu',\r\n        W: 'gr',\r\n        V: 'medium',\r\n        U: 'slate',\r\n        A: 'ee',\r\n        T: 'ol',\r\n        S: 'or',\r\n        B: 'ra',\r\n        C: 'lateg',\r\n        D: 'ights',\r\n        R: 'in',\r\n        Q: 'turquois',\r\n        E: 'hi',\r\n        P: 'ro',\r\n        O: 'al',\r\n        N: 'le',\r\n        M: 'de',\r\n        L: 'yello',\r\n        F: 'en',\r\n        K: 'ch',\r\n        G: 'arks',\r\n        H: 'ea',\r\n        I: 'ightg',\r\n        J: 'wh'\r\n    };\r\n    const names = {\r\n        OiceXe: 'f0f8ff',\r\n        antiquewEte: 'faebd7',\r\n        aqua: 'ffff',\r\n        aquamarRe: '7fffd4',\r\n        azuY: 'f0ffff',\r\n        beige: 'f5f5dc',\r\n        bisque: 'ffe4c4',\r\n        black: '0',\r\n        blanKedOmond: 'ffebcd',\r\n        Xe: 'ff',\r\n        XeviTet: '8a2be2',\r\n        bPwn: 'a52a2a',\r\n        burlywood: 'deb887',\r\n        caMtXe: '5f9ea0',\r\n        KartYuse: '7fff00',\r\n        KocTate: 'd2691e',\r\n        cSO: 'ff7f50',\r\n        cSnflowerXe: '6495ed',\r\n        cSnsilk: 'fff8dc',\r\n        crimson: 'dc143c',\r\n        cyan: 'ffff',\r\n        xXe: '8b',\r\n        xcyan: '8b8b',\r\n        xgTMnPd: 'b8860b',\r\n        xWay: 'a9a9a9',\r\n        xgYF: '6400',\r\n        xgYy: 'a9a9a9',\r\n        xkhaki: 'bdb76b',\r\n        xmagFta: '8b008b',\r\n        xTivegYF: '556b2f',\r\n        xSange: 'ff8c00',\r\n        xScEd: '9932cc',\r\n        xYd: '8b0000',\r\n        xsOmon: 'e9967a',\r\n        xsHgYF: '8fbc8f',\r\n        xUXe: '483d8b',\r\n        xUWay: '2f4f4f',\r\n        xUgYy: '2f4f4f',\r\n        xQe: 'ced1',\r\n        xviTet: '9400d3',\r\n        dAppRk: 'ff1493',\r\n        dApskyXe: 'bfff',\r\n        dimWay: '696969',\r\n        dimgYy: '696969',\r\n        dodgerXe: '1e90ff',\r\n        fiYbrick: 'b22222',\r\n        flSOwEte: 'fffaf0',\r\n        foYstWAn: '228b22',\r\n        fuKsia: 'ff00ff',\r\n        gaRsbSo: 'dcdcdc',\r\n        ghostwEte: 'f8f8ff',\r\n        gTd: 'ffd700',\r\n        gTMnPd: 'daa520',\r\n        Way: '808080',\r\n        gYF: '8000',\r\n        gYFLw: 'adff2f',\r\n        gYy: '808080',\r\n        honeyMw: 'f0fff0',\r\n        hotpRk: 'ff69b4',\r\n        RdianYd: 'cd5c5c',\r\n        Rdigo: '4b0082',\r\n        ivSy: 'fffff0',\r\n        khaki: 'f0e68c',\r\n        lavFMr: 'e6e6fa',\r\n        lavFMrXsh: 'fff0f5',\r\n        lawngYF: '7cfc00',\r\n        NmoncEffon: 'fffacd',\r\n        ZXe: 'add8e6',\r\n        ZcSO: 'f08080',\r\n        Zcyan: 'e0ffff',\r\n        ZgTMnPdLw: 'fafad2',\r\n        ZWay: 'd3d3d3',\r\n        ZgYF: '90ee90',\r\n        ZgYy: 'd3d3d3',\r\n        ZpRk: 'ffb6c1',\r\n        ZsOmon: 'ffa07a',\r\n        ZsHgYF: '20b2aa',\r\n        ZskyXe: '87cefa',\r\n        ZUWay: '778899',\r\n        ZUgYy: '778899',\r\n        ZstAlXe: 'b0c4de',\r\n        ZLw: 'ffffe0',\r\n        lime: 'ff00',\r\n        limegYF: '32cd32',\r\n        lRF: 'faf0e6',\r\n        magFta: 'ff00ff',\r\n        maPon: '800000',\r\n        VaquamarRe: '66cdaa',\r\n        VXe: 'cd',\r\n        VScEd: 'ba55d3',\r\n        VpurpN: '9370db',\r\n        VsHgYF: '3cb371',\r\n        VUXe: '7b68ee',\r\n        VsprRggYF: 'fa9a',\r\n        VQe: '48d1cc',\r\n        VviTetYd: 'c71585',\r\n        midnightXe: '191970',\r\n        mRtcYam: 'f5fffa',\r\n        mistyPse: 'ffe4e1',\r\n        moccasR: 'ffe4b5',\r\n        navajowEte: 'ffdead',\r\n        navy: '80',\r\n        Tdlace: 'fdf5e6',\r\n        Tive: '808000',\r\n        TivedBb: '6b8e23',\r\n        Sange: 'ffa500',\r\n        SangeYd: 'ff4500',\r\n        ScEd: 'da70d6',\r\n        pOegTMnPd: 'eee8aa',\r\n        pOegYF: '98fb98',\r\n        pOeQe: 'afeeee',\r\n        pOeviTetYd: 'db7093',\r\n        papayawEp: 'ffefd5',\r\n        pHKpuff: 'ffdab9',\r\n        peru: 'cd853f',\r\n        pRk: 'ffc0cb',\r\n        plum: 'dda0dd',\r\n        powMrXe: 'b0e0e6',\r\n        purpN: '800080',\r\n        YbeccapurpN: '663399',\r\n        Yd: 'ff0000',\r\n        Psybrown: 'bc8f8f',\r\n        PyOXe: '4169e1',\r\n        saddNbPwn: '8b4513',\r\n        sOmon: 'fa8072',\r\n        sandybPwn: 'f4a460',\r\n        sHgYF: '2e8b57',\r\n        sHshell: 'fff5ee',\r\n        siFna: 'a0522d',\r\n        silver: 'c0c0c0',\r\n        skyXe: '87ceeb',\r\n        UXe: '6a5acd',\r\n        UWay: '708090',\r\n        UgYy: '708090',\r\n        snow: 'fffafa',\r\n        sprRggYF: 'ff7f',\r\n        stAlXe: '4682b4',\r\n        tan: 'd2b48c',\r\n        teO: '8080',\r\n        tEstN: 'd8bfd8',\r\n        tomato: 'ff6347',\r\n        Qe: '40e0d0',\r\n        viTet: 'ee82ee',\r\n        JHt: 'f5deb3',\r\n        wEte: 'ffffff',\r\n        wEtesmoke: 'f5f5f5',\r\n        Lw: 'ffff00',\r\n        LwgYF: '9acd32'\r\n    };\r\n\r\n    function unpack() {\r\n        const unpacked = {};\r\n        const keys = Object.keys(names);\r\n        const tkeys = Object.keys(map$1);\r\n        let i, j, k, ok, nk;\r\n        for (i = 0; i < keys.length; i++) {\r\n            ok = nk = keys[i];\r\n            for (j = 0; j < tkeys.length; j++) {\r\n                k = tkeys[j];\r\n                nk = nk.replace(k, map$1[k]);\r\n            }\r\n            k = parseInt(names[ok], 16);\r\n            unpacked[nk] = [k >> 16 & 0xFF, k >> 8 & 0xFF, k & 0xFF];\r\n        }\r\n        return unpacked;\r\n    }\r\n\r\n    let names$1;\r\n\r\n    function nameParse(str) {\r\n        if (!names$1) {\r\n            names$1 = unpack();\r\n            names$1.transparent = [0, 0, 0, 0];\r\n        }\r\n        const a = names$1[str.toLowerCase()];\r\n        return a && {\r\n            r: a[0],\r\n            g: a[1],\r\n            b: a[2],\r\n            a: a.length === 4 ? a[3] : 255\r\n        };\r\n    }\r\n\r\n    function modHSL(v, i, ratio) {\r\n        if (v) {\r\n            let tmp = rgb2hsl(v);\r\n            tmp[i] = Math.max(0, Math.min(tmp[i] + tmp[i] * ratio, i === 0 ? 360 : 1));\r\n            tmp = hsl2rgb(tmp);\r\n            v.r = tmp[0];\r\n            v.g = tmp[1];\r\n            v.b = tmp[2];\r\n        }\r\n    }\r\n\r\n    function clone$1(v, proto) {\r\n        return v ? Object.assign(proto || {}, v) : v;\r\n    }\r\n\r\n    function fromObject(input) {\r\n        var v = {r: 0, g: 0, b: 0, a: 255};\r\n        if (Array.isArray(input)) {\r\n            if (input.length >= 3) {\r\n                v = {r: input[0], g: input[1], b: input[2], a: 255};\r\n                if (input.length > 3) {\r\n                    v.a = n2b(input[3]);\r\n                }\r\n            }\r\n        } else {\r\n            v = clone$1(input, {r: 0, g: 0, b: 0, a: 1});\r\n            v.a = n2b(v.a);\r\n        }\r\n        return v;\r\n    }\r\n\r\n    function functionParse(str) {\r\n        if (str.charAt(0) === 'r') {\r\n            return rgbParse(str);\r\n        }\r\n        return hueParse(str);\r\n    }\r\n\r\n    class Color {\r\n        constructor(input) {\r\n            if (input instanceof Color) {\r\n                return input;\r\n            }\r\n            const type = typeof input;\r\n            let v;\r\n            if (type === 'object') {\r\n                v = fromObject(input);\r\n            } else if (type === 'string') {\r\n                v = hexParse(input) || nameParse(input) || functionParse(input);\r\n            }\r\n            this._rgb = v;\r\n            this._valid = !!v;\r\n        }\r\n\r\n        get valid() {\r\n            return this._valid;\r\n        }\r\n\r\n        get rgb() {\r\n            var v = clone$1(this._rgb);\r\n            if (v) {\r\n                v.a = b2n(v.a);\r\n            }\r\n            return v;\r\n        }\r\n\r\n        set rgb(obj) {\r\n            this._rgb = fromObject(obj);\r\n        }\r\n\r\n        rgbString() {\r\n            return this._valid ? rgbString(this._rgb) : this._rgb;\r\n        }\r\n\r\n        hexString() {\r\n            return this._valid ? hexString(this._rgb) : this._rgb;\r\n        }\r\n\r\n        hslString() {\r\n            return this._valid ? hslString(this._rgb) : this._rgb;\r\n        }\r\n\r\n        mix(color, weight) {\r\n            const me = this;\r\n            if (color) {\r\n                const c1 = me.rgb;\r\n                const c2 = color.rgb;\r\n                let w2;\r\n                const p = weight === w2 ? 0.5 : weight;\r\n                const w = 2 * p - 1;\r\n                const a = c1.a - c2.a;\r\n                const w1 = ((w * a === -1 ? w : (w + a) / (1 + w * a)) + 1) / 2.0;\r\n                w2 = 1 - w1;\r\n                c1.r = 0xFF & w1 * c1.r + w2 * c2.r + 0.5;\r\n                c1.g = 0xFF & w1 * c1.g + w2 * c2.g + 0.5;\r\n                c1.b = 0xFF & w1 * c1.b + w2 * c2.b + 0.5;\r\n                c1.a = p * c1.a + (1 - p) * c2.a;\r\n                me.rgb = c1;\r\n            }\r\n            return me;\r\n        }\r\n\r\n        clone() {\r\n            return new Color(this.rgb);\r\n        }\r\n\r\n        alpha(a) {\r\n            this._rgb.a = n2b(a);\r\n            return this;\r\n        }\r\n\r\n        clearer(ratio) {\r\n            const rgb = this._rgb;\r\n            rgb.a *= 1 - ratio;\r\n            return this;\r\n        }\r\n\r\n        greyscale() {\r\n            const rgb = this._rgb;\r\n            const val = round(rgb.r * 0.3 + rgb.g * 0.59 + rgb.b * 0.11);\r\n            rgb.r = rgb.g = rgb.b = val;\r\n            return this;\r\n        }\r\n\r\n        opaquer(ratio) {\r\n            const rgb = this._rgb;\r\n            rgb.a *= 1 + ratio;\r\n            return this;\r\n        }\r\n\r\n        negate() {\r\n            const v = this._rgb;\r\n            v.r = 255 - v.r;\r\n            v.g = 255 - v.g;\r\n            v.b = 255 - v.b;\r\n            return this;\r\n        }\r\n\r\n        lighten(ratio) {\r\n            modHSL(this._rgb, 2, ratio);\r\n            return this;\r\n        }\r\n\r\n        darken(ratio) {\r\n            modHSL(this._rgb, 2, -ratio);\r\n            return this;\r\n        }\r\n\r\n        saturate(ratio) {\r\n            modHSL(this._rgb, 1, ratio);\r\n            return this;\r\n        }\r\n\r\n        desaturate(ratio) {\r\n            modHSL(this._rgb, 1, -ratio);\r\n            return this;\r\n        }\r\n\r\n        rotate(deg) {\r\n            rotate(this._rgb, deg);\r\n            return this;\r\n        }\r\n    }\r\n\r\n    function index_esm(input) {\r\n        return new Color(input);\r\n    }\r\n\r\n    const isPatternOrGradient = (value) => value instanceof CanvasGradient || value instanceof CanvasPattern;\r\n\r\n    function color(value) {\r\n        return isPatternOrGradient(value) ? value : index_esm(value);\r\n    }\r\n\r\n    function getHoverColor(value) {\r\n        return isPatternOrGradient(value)\r\n            ? value\r\n            : index_esm(value).saturate(0.5).darken(0.1).hexString();\r\n    }\r\n\r\n    function noop() {\r\n    }\r\n\r\n    const uid = (function () {\r\n        let id = 0;\r\n        return function () {\r\n            return id++;\r\n        };\r\n    }());\r\n\r\n    function isNullOrUndef(value) {\r\n        return value === null || typeof value === 'undefined';\r\n    }\r\n\r\n    function isArray(value) {\r\n        if (Array.isArray && Array.isArray(value)) {\r\n            return true;\r\n        }\r\n        const type = Object.prototype.toString.call(value);\r\n        if (type.substr(0, 7) === '[object' && type.substr(-6) === 'Array]') {\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    function isObject(value) {\r\n        return value !== null && Object.prototype.toString.call(value) === '[object Object]';\r\n    }\r\n\r\n    const isNumberFinite = (value) => (typeof value === 'number' || value instanceof Number) && isFinite(+value);\r\n\r\n    function finiteOrDefault(value, defaultValue) {\r\n        return isNumberFinite(value) ? value : defaultValue;\r\n    }\r\n\r\n    function valueOrDefault(value, defaultValue) {\r\n        return typeof value === 'undefined' ? defaultValue : value;\r\n    }\r\n\r\n    const toPercentage = (value, dimension) =>\r\n        typeof value === 'string' && value.endsWith('%') ?\r\n            parseFloat(value) / 100\r\n            : value / dimension;\r\n    const toDimension = (value, dimension) =>\r\n        typeof value === 'string' && value.endsWith('%') ?\r\n            parseFloat(value) / 100 * dimension\r\n            : +value;\r\n\r\n    function callback(fn, args, thisArg) {\r\n        if (fn && typeof fn.call === 'function') {\r\n            return fn.apply(thisArg, args);\r\n        }\r\n    }\r\n\r\n    function each(loopable, fn, thisArg, reverse) {\r\n        let i, len, keys;\r\n        if (isArray(loopable)) {\r\n            len = loopable.length;\r\n            if (reverse) {\r\n                for (i = len - 1; i >= 0; i--) {\r\n                    fn.call(thisArg, loopable[i], i);\r\n                }\r\n            } else {\r\n                for (i = 0; i < len; i++) {\r\n                    fn.call(thisArg, loopable[i], i);\r\n                }\r\n            }\r\n        } else if (isObject(loopable)) {\r\n            keys = Object.keys(loopable);\r\n            len = keys.length;\r\n            for (i = 0; i < len; i++) {\r\n                fn.call(thisArg, loopable[keys[i]], keys[i]);\r\n            }\r\n        }\r\n    }\r\n\r\n    function _elementsEqual(a0, a1) {\r\n        let i, ilen, v0, v1;\r\n        if (!a0 || !a1 || a0.length !== a1.length) {\r\n            return false;\r\n        }\r\n        for (i = 0, ilen = a0.length; i < ilen; ++i) {\r\n            v0 = a0[i];\r\n            v1 = a1[i];\r\n            if (v0.datasetIndex !== v1.datasetIndex || v0.index !== v1.index) {\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n\r\n    function clone(source) {\r\n        if (isArray(source)) {\r\n            return source.map(clone);\r\n        }\r\n        if (isObject(source)) {\r\n            const target = Object.create(null);\r\n            const keys = Object.keys(source);\r\n            const klen = keys.length;\r\n            let k = 0;\r\n            for (; k < klen; ++k) {\r\n                target[keys[k]] = clone(source[keys[k]]);\r\n            }\r\n            return target;\r\n        }\r\n        return source;\r\n    }\r\n\r\n    function isValidKey(key) {\r\n        return ['__proto__', 'prototype', 'constructor'].indexOf(key) === -1;\r\n    }\r\n\r\n    function _merger(key, target, source, options) {\r\n        if (!isValidKey(key)) {\r\n            return;\r\n        }\r\n        const tval = target[key];\r\n        const sval = source[key];\r\n        if (isObject(tval) && isObject(sval)) {\r\n            merge(tval, sval, options);\r\n        } else {\r\n            target[key] = clone(sval);\r\n        }\r\n    }\r\n\r\n    function merge(target, source, options) {\r\n        const sources = isArray(source) ? source : [source];\r\n        const ilen = sources.length;\r\n        if (!isObject(target)) {\r\n            return target;\r\n        }\r\n        options = options || {};\r\n        const merger = options.merger || _merger;\r\n        for (let i = 0; i < ilen; ++i) {\r\n            source = sources[i];\r\n            if (!isObject(source)) {\r\n                continue;\r\n            }\r\n            const keys = Object.keys(source);\r\n            for (let k = 0, klen = keys.length; k < klen; ++k) {\r\n                merger(keys[k], target, source, options);\r\n            }\r\n        }\r\n        return target;\r\n    }\r\n\r\n    function mergeIf(target, source) {\r\n        return merge(target, source, {merger: _mergerIf});\r\n    }\r\n\r\n    function _mergerIf(key, target, source) {\r\n        if (!isValidKey(key)) {\r\n            return;\r\n        }\r\n        const tval = target[key];\r\n        const sval = source[key];\r\n        if (isObject(tval) && isObject(sval)) {\r\n            mergeIf(tval, sval);\r\n        } else if (!Object.prototype.hasOwnProperty.call(target, key)) {\r\n            target[key] = clone(sval);\r\n        }\r\n    }\r\n\r\n    function _deprecated(scope, value, previous, current) {\r\n        if (value !== undefined) {\r\n            console.warn(scope + ': \"' + previous +\r\n                '\" is deprecated. Please use \"' + current + '\" instead');\r\n        }\r\n    }\r\n\r\n    const emptyString = '';\r\n    const dot = '.';\r\n\r\n    function indexOfDotOrLength(key, start) {\r\n        const idx = key.indexOf(dot, start);\r\n        return idx === -1 ? key.length : idx;\r\n    }\r\n\r\n    function resolveObjectKey(obj, key) {\r\n        if (key === emptyString) {\r\n            return obj;\r\n        }\r\n        let pos = 0;\r\n        let idx = indexOfDotOrLength(key, pos);\r\n        while (obj && idx > pos) {\r\n            obj = obj[key.substr(pos, idx - pos)];\r\n            pos = idx + 1;\r\n            idx = indexOfDotOrLength(key, pos);\r\n        }\r\n        return obj;\r\n    }\r\n\r\n    function _capitalize(str) {\r\n        return str.charAt(0).toUpperCase() + str.slice(1);\r\n    }\r\n\r\n    const defined = (value) => typeof value !== 'undefined';\r\n    const isFunction = (value) => typeof value === 'function';\r\n\r\n    const overrides = Object.create(null);\r\n    const descriptors = Object.create(null);\r\n\r\n    function getScope$1(node, key) {\r\n        if (!key) {\r\n            return node;\r\n        }\r\n        const keys = key.split('.');\r\n        for (let i = 0, n = keys.length; i < n; ++i) {\r\n            const k = keys[i];\r\n            node = node[k] || (node[k] = Object.create(null));\r\n        }\r\n        return node;\r\n    }\r\n\r\n    function set(root, scope, values) {\r\n        if (typeof scope === 'string') {\r\n            return merge(getScope$1(root, scope), values);\r\n        }\r\n        return merge(getScope$1(root, ''), scope);\r\n    }\r\n\r\n    class Defaults {\r\n        constructor(_descriptors) {\r\n            this.animation = undefined;\r\n            this.backgroundColor = 'rgba(0,0,0,0.1)';\r\n            this.borderColor = 'rgba(0,0,0,0.1)';\r\n            this.color = '#666';\r\n            this.datasets = {};\r\n            this.devicePixelRatio = (context) => context.chart.platform.getDevicePixelRatio();\r\n            this.elements = {};\r\n            this.events = [\r\n                'mousemove',\r\n                'mouseout',\r\n                'click',\r\n                'touchstart',\r\n                'touchmove'\r\n            ];\r\n            this.font = {\r\n                family: \"'Helvetica Neue', 'Helvetica', 'Arial', sans-serif\",\r\n                size: 12,\r\n                style: 'normal',\r\n                lineHeight: 1.2,\r\n                weight: null\r\n            };\r\n            this.hover = {};\r\n            this.hoverBackgroundColor = (ctx, options) => getHoverColor(options.backgroundColor);\r\n            this.hoverBorderColor = (ctx, options) => getHoverColor(options.borderColor);\r\n            this.hoverColor = (ctx, options) => getHoverColor(options.color);\r\n            this.indexAxis = 'x';\r\n            this.interaction = {\r\n                mode: 'nearest',\r\n                intersect: true\r\n            };\r\n            this.maintainAspectRatio = true;\r\n            this.onHover = null;\r\n            this.onClick = null;\r\n            this.parsing = true;\r\n            this.plugins = {};\r\n            this.responsive = true;\r\n            this.scale = undefined;\r\n            this.scales = {};\r\n            this.showLine = true;\r\n            this.describe(_descriptors);\r\n        }\r\n\r\n        set(scope, values) {\r\n            return set(this, scope, values);\r\n        }\r\n\r\n        get(scope) {\r\n            return getScope$1(this, scope);\r\n        }\r\n\r\n        describe(scope, values) {\r\n            return set(descriptors, scope, values);\r\n        }\r\n\r\n        override(scope, values) {\r\n            return set(overrides, scope, values);\r\n        }\r\n\r\n        route(scope, name, targetScope, targetName) {\r\n            const scopeObject = getScope$1(this, scope);\r\n            const targetScopeObject = getScope$1(this, targetScope);\r\n            const privateName = '_' + name;\r\n            Object.defineProperties(scopeObject, {\r\n                [privateName]: {\r\n                    value: scopeObject[name],\r\n                    writable: true\r\n                },\r\n                [name]: {\r\n                    enumerable: true,\r\n                    get() {\r\n                        const local = this[privateName];\r\n                        const target = targetScopeObject[targetName];\r\n                        if (isObject(local)) {\r\n                            return Object.assign({}, target, local);\r\n                        }\r\n                        return valueOrDefault(local, target);\r\n                    },\r\n                    set(value) {\r\n                        this[privateName] = value;\r\n                    }\r\n                }\r\n            });\r\n        }\r\n    }\r\n\r\n    var defaults = new Defaults({\r\n        _scriptable: (name) => !name.startsWith('on'),\r\n        _indexable: (name) => name !== 'events',\r\n        hover: {\r\n            _fallback: 'interaction'\r\n        },\r\n        interaction: {\r\n            _scriptable: false,\r\n            _indexable: false,\r\n        }\r\n    });\r\n\r\n    const PI = Math.PI;\r\n    const TAU = 2 * PI;\r\n    const PITAU = TAU + PI;\r\n    const INFINITY = Number.POSITIVE_INFINITY;\r\n    const RAD_PER_DEG = PI / 180;\r\n    const HALF_PI = PI / 2;\r\n    const QUARTER_PI = PI / 4;\r\n    const TWO_THIRDS_PI = PI * 2 / 3;\r\n    const log10 = Math.log10;\r\n    const sign = Math.sign;\r\n\r\n    function niceNum(range) {\r\n        const niceRange = Math.pow(10, Math.floor(log10(range)));\r\n        const fraction = range / niceRange;\r\n        const niceFraction = fraction <= 1 ? 1 : fraction <= 2 ? 2 : fraction <= 5 ? 5 : 10;\r\n        return niceFraction * niceRange;\r\n    }\r\n\r\n    function _factorize(value) {\r\n        const result = [];\r\n        const sqrt = Math.sqrt(value);\r\n        let i;\r\n        for (i = 1; i < sqrt; i++) {\r\n            if (value % i === 0) {\r\n                result.push(i);\r\n                result.push(value / i);\r\n            }\r\n        }\r\n        if (sqrt === (sqrt | 0)) {\r\n            result.push(sqrt);\r\n        }\r\n        result.sort((a, b) => a - b).pop();\r\n        return result;\r\n    }\r\n\r\n    function isNumber(n) {\r\n        return !isNaN(parseFloat(n)) && isFinite(n);\r\n    }\r\n\r\n    function almostEquals(x, y, epsilon) {\r\n        return Math.abs(x - y) < epsilon;\r\n    }\r\n\r\n    function almostWhole(x, epsilon) {\r\n        const rounded = Math.round(x);\r\n        return ((rounded - epsilon) <= x) && ((rounded + epsilon) >= x);\r\n    }\r\n\r\n    function _setMinAndMaxByKey(array, target, property) {\r\n        let i, ilen, value;\r\n        for (i = 0, ilen = array.length; i < ilen; i++) {\r\n            value = array[i][property];\r\n            if (!isNaN(value)) {\r\n                target.min = Math.min(target.min, value);\r\n                target.max = Math.max(target.max, value);\r\n            }\r\n        }\r\n    }\r\n\r\n    function toRadians(degrees) {\r\n        return degrees * (PI / 180);\r\n    }\r\n\r\n    function toDegrees(radians) {\r\n        return radians * (180 / PI);\r\n    }\r\n\r\n    function _decimalPlaces(x) {\r\n        if (!isNumberFinite(x)) {\r\n            return;\r\n        }\r\n        let e = 1;\r\n        let p = 0;\r\n        while (Math.round(x * e) / e !== x) {\r\n            e *= 10;\r\n            p++;\r\n        }\r\n        return p;\r\n    }\r\n\r\n    function getAngleFromPoint(centrePoint, anglePoint) {\r\n        const distanceFromXCenter = anglePoint.x - centrePoint.x;\r\n        const distanceFromYCenter = anglePoint.y - centrePoint.y;\r\n        const radialDistanceFromCenter = Math.sqrt(distanceFromXCenter * distanceFromXCenter + distanceFromYCenter * distanceFromYCenter);\r\n        let angle = Math.atan2(distanceFromYCenter, distanceFromXCenter);\r\n        if (angle < (-0.5 * PI)) {\r\n            angle += TAU;\r\n        }\r\n        return {\r\n            angle,\r\n            distance: radialDistanceFromCenter\r\n        };\r\n    }\r\n\r\n    function distanceBetweenPoints(pt1, pt2) {\r\n        return Math.sqrt(Math.pow(pt2.x - pt1.x, 2) + Math.pow(pt2.y - pt1.y, 2));\r\n    }\r\n\r\n    function _angleDiff(a, b) {\r\n        return (a - b + PITAU) % TAU - PI;\r\n    }\r\n\r\n    function _normalizeAngle(a) {\r\n        return (a % TAU + TAU) % TAU;\r\n    }\r\n\r\n    function _angleBetween(angle, start, end) {\r\n        const a = _normalizeAngle(angle);\r\n        const s = _normalizeAngle(start);\r\n        const e = _normalizeAngle(end);\r\n        const angleToStart = _normalizeAngle(s - a);\r\n        const angleToEnd = _normalizeAngle(e - a);\r\n        const startToAngle = _normalizeAngle(a - s);\r\n        const endToAngle = _normalizeAngle(a - e);\r\n        return a === s || a === e || (angleToStart > angleToEnd && startToAngle < endToAngle);\r\n    }\r\n\r\n    function _limitValue(value, min, max) {\r\n        return Math.max(min, Math.min(max, value));\r\n    }\r\n\r\n    function _int16Range(value) {\r\n        return _limitValue(value, -32768, 32767);\r\n    }\r\n\r\n    function toFontString(font) {\r\n        if (!font || isNullOrUndef(font.size) || isNullOrUndef(font.family)) {\r\n            return null;\r\n        }\r\n        return (font.style ? font.style + ' ' : '')\r\n            + (font.weight ? font.weight + ' ' : '')\r\n            + font.size + 'px '\r\n            + font.family;\r\n    }\r\n\r\n    function _measureText(ctx, data, gc, longest, string) {\r\n        let textWidth = data[string];\r\n        if (!textWidth) {\r\n            textWidth = data[string] = ctx.measureText(string).width;\r\n            gc.push(string);\r\n        }\r\n        if (textWidth > longest) {\r\n            longest = textWidth;\r\n        }\r\n        return longest;\r\n    }\r\n\r\n    function _longestText(ctx, font, arrayOfThings, cache) {\r\n        cache = cache || {};\r\n        let data = cache.data = cache.data || {};\r\n        let gc = cache.garbageCollect = cache.garbageCollect || [];\r\n        if (cache.font !== font) {\r\n            data = cache.data = {};\r\n            gc = cache.garbageCollect = [];\r\n            cache.font = font;\r\n        }\r\n        ctx.save();\r\n        ctx.font = font;\r\n        let longest = 0;\r\n        const ilen = arrayOfThings.length;\r\n        let i, j, jlen, thing, nestedThing;\r\n        for (i = 0; i < ilen; i++) {\r\n            thing = arrayOfThings[i];\r\n            if (thing !== undefined && thing !== null && isArray(thing) !== true) {\r\n                longest = _measureText(ctx, data, gc, longest, thing);\r\n            } else if (isArray(thing)) {\r\n                for (j = 0, jlen = thing.length; j < jlen; j++) {\r\n                    nestedThing = thing[j];\r\n                    if (nestedThing !== undefined && nestedThing !== null && !isArray(nestedThing)) {\r\n                        longest = _measureText(ctx, data, gc, longest, nestedThing);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        ctx.restore();\r\n        const gcLen = gc.length / 2;\r\n        if (gcLen > arrayOfThings.length) {\r\n            for (i = 0; i < gcLen; i++) {\r\n                delete data[gc[i]];\r\n            }\r\n            gc.splice(0, gcLen);\r\n        }\r\n        return longest;\r\n    }\r\n\r\n    function _alignPixel(chart, pixel, width) {\r\n        const devicePixelRatio = chart.currentDevicePixelRatio;\r\n        const halfWidth = width !== 0 ? Math.max(width / 2, 0.5) : 0;\r\n        return Math.round((pixel - halfWidth) * devicePixelRatio) / devicePixelRatio + halfWidth;\r\n    }\r\n\r\n    function clearCanvas(canvas, ctx) {\r\n        ctx = ctx || canvas.getContext('2d');\r\n        ctx.save();\r\n        ctx.resetTransform();\r\n        ctx.clearRect(0, 0, canvas.width, canvas.height);\r\n        ctx.restore();\r\n    }\r\n\r\n    function drawPoint(ctx, options, x, y) {\r\n        let type, xOffset, yOffset, size, cornerRadius;\r\n        const style = options.pointStyle;\r\n        const rotation = options.rotation;\r\n        const radius = options.radius;\r\n        let rad = (rotation || 0) * RAD_PER_DEG;\r\n        if (style && typeof style === 'object') {\r\n            type = style.toString();\r\n            if (type === '[object HTMLImageElement]' || type === '[object HTMLCanvasElement]') {\r\n                ctx.save();\r\n                ctx.translate(x, y);\r\n                ctx.rotate(rad);\r\n                ctx.drawImage(style, -style.width / 2, -style.height / 2, style.width, style.height);\r\n                ctx.restore();\r\n                return;\r\n            }\r\n        }\r\n        if (isNaN(radius) || radius <= 0) {\r\n            return;\r\n        }\r\n        ctx.beginPath();\r\n        switch (style) {\r\n            default:\r\n                ctx.arc(x, y, radius, 0, TAU);\r\n                ctx.closePath();\r\n                break;\r\n            case 'triangle':\r\n                ctx.moveTo(x + Math.sin(rad) * radius, y - Math.cos(rad) * radius);\r\n                rad += TWO_THIRDS_PI;\r\n                ctx.lineTo(x + Math.sin(rad) * radius, y - Math.cos(rad) * radius);\r\n                rad += TWO_THIRDS_PI;\r\n                ctx.lineTo(x + Math.sin(rad) * radius, y - Math.cos(rad) * radius);\r\n                ctx.closePath();\r\n                break;\r\n            case 'rectRounded':\r\n                cornerRadius = radius * 0.516;\r\n                size = radius - cornerRadius;\r\n                xOffset = Math.cos(rad + QUARTER_PI) * size;\r\n                yOffset = Math.sin(rad + QUARTER_PI) * size;\r\n                ctx.arc(x - xOffset, y - yOffset, cornerRadius, rad - PI, rad - HALF_PI);\r\n                ctx.arc(x + yOffset, y - xOffset, cornerRadius, rad - HALF_PI, rad);\r\n                ctx.arc(x + xOffset, y + yOffset, cornerRadius, rad, rad + HALF_PI);\r\n                ctx.arc(x - yOffset, y + xOffset, cornerRadius, rad + HALF_PI, rad + PI);\r\n                ctx.closePath();\r\n                break;\r\n            case 'rect':\r\n                if (!rotation) {\r\n                    size = Math.SQRT1_2 * radius;\r\n                    ctx.rect(x - size, y - size, 2 * size, 2 * size);\r\n                    break;\r\n                }\r\n                rad += QUARTER_PI;\r\n            case 'rectRot':\r\n                xOffset = Math.cos(rad) * radius;\r\n                yOffset = Math.sin(rad) * radius;\r\n                ctx.moveTo(x - xOffset, y - yOffset);\r\n                ctx.lineTo(x + yOffset, y - xOffset);\r\n                ctx.lineTo(x + xOffset, y + yOffset);\r\n                ctx.lineTo(x - yOffset, y + xOffset);\r\n                ctx.closePath();\r\n                break;\r\n            case 'crossRot':\r\n                rad += QUARTER_PI;\r\n            case 'cross':\r\n                xOffset = Math.cos(rad) * radius;\r\n                yOffset = Math.sin(rad) * radius;\r\n                ctx.moveTo(x - xOffset, y - yOffset);\r\n                ctx.lineTo(x + xOffset, y + yOffset);\r\n                ctx.moveTo(x + yOffset, y - xOffset);\r\n                ctx.lineTo(x - yOffset, y + xOffset);\r\n                break;\r\n            case 'star':\r\n                xOffset = Math.cos(rad) * radius;\r\n                yOffset = Math.sin(rad) * radius;\r\n                ctx.moveTo(x - xOffset, y - yOffset);\r\n                ctx.lineTo(x + xOffset, y + yOffset);\r\n                ctx.moveTo(x + yOffset, y - xOffset);\r\n                ctx.lineTo(x - yOffset, y + xOffset);\r\n                rad += QUARTER_PI;\r\n                xOffset = Math.cos(rad) * radius;\r\n                yOffset = Math.sin(rad) * radius;\r\n                ctx.moveTo(x - xOffset, y - yOffset);\r\n                ctx.lineTo(x + xOffset, y + yOffset);\r\n                ctx.moveTo(x + yOffset, y - xOffset);\r\n                ctx.lineTo(x - yOffset, y + xOffset);\r\n                break;\r\n            case 'line':\r\n                xOffset = Math.cos(rad) * radius;\r\n                yOffset = Math.sin(rad) * radius;\r\n                ctx.moveTo(x - xOffset, y - yOffset);\r\n                ctx.lineTo(x + xOffset, y + yOffset);\r\n                break;\r\n            case 'dash':\r\n                ctx.moveTo(x, y);\r\n                ctx.lineTo(x + Math.cos(rad) * radius, y + Math.sin(rad) * radius);\r\n                break;\r\n        }\r\n        ctx.fill();\r\n        if (options.borderWidth > 0) {\r\n            ctx.stroke();\r\n        }\r\n    }\r\n\r\n    function _isPointInArea(point, area, margin) {\r\n        margin = margin || 0.5;\r\n        return point && point.x > area.left - margin && point.x < area.right + margin &&\r\n            point.y > area.top - margin && point.y < area.bottom + margin;\r\n    }\r\n\r\n    function clipArea(ctx, area) {\r\n        ctx.save();\r\n        ctx.beginPath();\r\n        ctx.rect(area.left, area.top, area.right - area.left, area.bottom - area.top);\r\n        ctx.clip();\r\n    }\r\n\r\n    function unclipArea(ctx) {\r\n        ctx.restore();\r\n    }\r\n\r\n    function _steppedLineTo(ctx, previous, target, flip, mode) {\r\n        if (!previous) {\r\n            return ctx.lineTo(target.x, target.y);\r\n        }\r\n        if (mode === 'middle') {\r\n            const midpoint = (previous.x + target.x) / 2.0;\r\n            ctx.lineTo(midpoint, previous.y);\r\n            ctx.lineTo(midpoint, target.y);\r\n        } else if (mode === 'after' !== !!flip) {\r\n            ctx.lineTo(previous.x, target.y);\r\n        } else {\r\n            ctx.lineTo(target.x, previous.y);\r\n        }\r\n        ctx.lineTo(target.x, target.y);\r\n    }\r\n\r\n    function _bezierCurveTo(ctx, previous, target, flip) {\r\n        if (!previous) {\r\n            return ctx.lineTo(target.x, target.y);\r\n        }\r\n        ctx.bezierCurveTo(\r\n            flip ? previous.cp1x : previous.cp2x,\r\n            flip ? previous.cp1y : previous.cp2y,\r\n            flip ? target.cp2x : target.cp1x,\r\n            flip ? target.cp2y : target.cp1y,\r\n            target.x,\r\n            target.y);\r\n    }\r\n\r\n    function renderText(ctx, text, x, y, font, opts = {}) {\r\n        const lines = isArray(text) ? text : [text];\r\n        const stroke = opts.strokeWidth > 0 && opts.strokeColor !== '';\r\n        let i, line;\r\n        ctx.save();\r\n        if (opts.translation) {\r\n            ctx.translate(opts.translation[0], opts.translation[1]);\r\n        }\r\n        if (!isNullOrUndef(opts.rotation)) {\r\n            ctx.rotate(opts.rotation);\r\n        }\r\n        ctx.font = font.string;\r\n        if (opts.color) {\r\n            ctx.fillStyle = opts.color;\r\n        }\r\n        if (opts.textAlign) {\r\n            ctx.textAlign = opts.textAlign;\r\n        }\r\n        if (opts.textBaseline) {\r\n            ctx.textBaseline = opts.textBaseline;\r\n        }\r\n        for (i = 0; i < lines.length; ++i) {\r\n            line = lines[i];\r\n            if (stroke) {\r\n                if (opts.strokeColor) {\r\n                    ctx.strokeStyle = opts.strokeColor;\r\n                }\r\n                if (!isNullOrUndef(opts.strokeWidth)) {\r\n                    ctx.lineWidth = opts.strokeWidth;\r\n                }\r\n                ctx.strokeText(line, x, y, opts.maxWidth);\r\n            }\r\n            ctx.fillText(line, x, y, opts.maxWidth);\r\n            if (opts.strikethrough || opts.underline) {\r\n                const metrics = ctx.measureText(line);\r\n                const left = x - metrics.actualBoundingBoxLeft;\r\n                const right = x + metrics.actualBoundingBoxRight;\r\n                const top = y - metrics.actualBoundingBoxAscent;\r\n                const bottom = y + metrics.actualBoundingBoxDescent;\r\n                const yDecoration = opts.strikethrough ? (top + bottom) / 2 : bottom;\r\n                ctx.strokeStyle = ctx.fillStyle;\r\n                ctx.beginPath();\r\n                ctx.lineWidth = opts.decorationWidth || 2;\r\n                ctx.moveTo(left, yDecoration);\r\n                ctx.lineTo(right, yDecoration);\r\n                ctx.stroke();\r\n            }\r\n            y += font.lineHeight;\r\n        }\r\n        ctx.restore();\r\n    }\r\n\r\n    function _lookup(table, value, cmp) {\r\n        cmp = cmp || ((index) => table[index] < value);\r\n        let hi = table.length - 1;\r\n        let lo = 0;\r\n        let mid;\r\n        while (hi - lo > 1) {\r\n            mid = (lo + hi) >> 1;\r\n            if (cmp(mid)) {\r\n                lo = mid;\r\n            } else {\r\n                hi = mid;\r\n            }\r\n        }\r\n        return {lo, hi};\r\n    }\r\n\r\n    const _lookupByKey = (table, key, value) =>\r\n        _lookup(table, value, index => table[index][key] < value);\r\n    const _rlookupByKey = (table, key, value) =>\r\n        _lookup(table, value, index => table[index][key] >= value);\r\n\r\n    function _filterBetween(values, min, max) {\r\n        let start = 0;\r\n        let end = values.length;\r\n        while (start < end && values[start] < min) {\r\n            start++;\r\n        }\r\n        while (end > start && values[end - 1] > max) {\r\n            end--;\r\n        }\r\n        return start > 0 || end < values.length\r\n            ? values.slice(start, end)\r\n            : values;\r\n    }\r\n\r\n    const arrayEvents = ['push', 'pop', 'shift', 'splice', 'unshift'];\r\n\r\n    function listenArrayEvents(array, listener) {\r\n        if (array._chartjs) {\r\n            array._chartjs.listeners.push(listener);\r\n            return;\r\n        }\r\n        Object.defineProperty(array, '_chartjs', {\r\n            configurable: true,\r\n            enumerable: false,\r\n            value: {\r\n                listeners: [listener]\r\n            }\r\n        });\r\n        arrayEvents.forEach((key) => {\r\n            const method = '_onData' + _capitalize(key);\r\n            const base = array[key];\r\n            Object.defineProperty(array, key, {\r\n                configurable: true,\r\n                enumerable: false,\r\n                value(...args) {\r\n                    const res = base.apply(this, args);\r\n                    array._chartjs.listeners.forEach((object) => {\r\n                        if (typeof object[method] === 'function') {\r\n                            object[method](...args);\r\n                        }\r\n                    });\r\n                    return res;\r\n                }\r\n            });\r\n        });\r\n    }\r\n\r\n    function unlistenArrayEvents(array, listener) {\r\n        const stub = array._chartjs;\r\n        if (!stub) {\r\n            return;\r\n        }\r\n        const listeners = stub.listeners;\r\n        const index = listeners.indexOf(listener);\r\n        if (index !== -1) {\r\n            listeners.splice(index, 1);\r\n        }\r\n        if (listeners.length > 0) {\r\n            return;\r\n        }\r\n        arrayEvents.forEach((key) => {\r\n            delete array[key];\r\n        });\r\n        delete array._chartjs;\r\n    }\r\n\r\n    function _arrayUnique(items) {\r\n        const set = new Set();\r\n        let i, ilen;\r\n        for (i = 0, ilen = items.length; i < ilen; ++i) {\r\n            set.add(items[i]);\r\n        }\r\n        if (set.size === ilen) {\r\n            return items;\r\n        }\r\n        const result = [];\r\n        set.forEach(item => {\r\n            result.push(item);\r\n        });\r\n        return result;\r\n    }\r\n\r\n    function _getParentNode(domNode) {\r\n        let parent = domNode.parentNode;\r\n        if (parent && parent.toString() === '[object ShadowRoot]') {\r\n            parent = parent.host;\r\n        }\r\n        return parent;\r\n    }\r\n\r\n    function parseMaxStyle(styleValue, node, parentProperty) {\r\n        let valueInPixels;\r\n        if (typeof styleValue === 'string') {\r\n            valueInPixels = parseInt(styleValue, 10);\r\n            if (styleValue.indexOf('%') !== -1) {\r\n                valueInPixels = valueInPixels / 100 * node.parentNode[parentProperty];\r\n            }\r\n        } else {\r\n            valueInPixels = styleValue;\r\n        }\r\n        return valueInPixels;\r\n    }\r\n\r\n    const getComputedStyle = (element) => window.getComputedStyle(element, null);\r\n\r\n    function getStyle(el, property) {\r\n        return getComputedStyle(el).getPropertyValue(property);\r\n    }\r\n\r\n    const positions = ['top', 'right', 'bottom', 'left'];\r\n\r\n    function getPositionedStyle(styles, style, suffix) {\r\n        const result = {};\r\n        suffix = suffix ? '-' + suffix : '';\r\n        for (let i = 0; i < 4; i++) {\r\n            const pos = positions[i];\r\n            result[pos] = parseFloat(styles[style + '-' + pos + suffix]) || 0;\r\n        }\r\n        result.width = result.left + result.right;\r\n        result.height = result.top + result.bottom;\r\n        return result;\r\n    }\r\n\r\n    const useOffsetPos = (x, y, target) => (x > 0 || y > 0) && (!target || !target.shadowRoot);\r\n\r\n    function getCanvasPosition(evt, canvas) {\r\n        const e = evt.native || evt;\r\n        const touches = e.touches;\r\n        const source = touches && touches.length ? touches[0] : e;\r\n        const {offsetX, offsetY} = source;\r\n        let box = false;\r\n        let x, y;\r\n        if (useOffsetPos(offsetX, offsetY, e.target)) {\r\n            x = offsetX;\r\n            y = offsetY;\r\n        } else {\r\n            const rect = canvas.getBoundingClientRect();\r\n            x = source.clientX - rect.left;\r\n            y = source.clientY - rect.top;\r\n            box = true;\r\n        }\r\n        return {x, y, box};\r\n    }\r\n\r\n    function getRelativePosition$1(evt, chart) {\r\n        const {canvas, currentDevicePixelRatio} = chart;\r\n        const style = getComputedStyle(canvas);\r\n        const borderBox = style.boxSizing === 'border-box';\r\n        const paddings = getPositionedStyle(style, 'padding');\r\n        const borders = getPositionedStyle(style, 'border', 'width');\r\n        const {x, y, box} = getCanvasPosition(evt, canvas);\r\n        const xOffset = paddings.left + (box && borders.left);\r\n        const yOffset = paddings.top + (box && borders.top);\r\n        let {width, height} = chart;\r\n        if (borderBox) {\r\n            width -= paddings.width + borders.width;\r\n            height -= paddings.height + borders.height;\r\n        }\r\n        return {\r\n            x: Math.round((x - xOffset) / width * canvas.width / currentDevicePixelRatio),\r\n            y: Math.round((y - yOffset) / height * canvas.height / currentDevicePixelRatio)\r\n        };\r\n    }\r\n\r\n    function getContainerSize(canvas, width, height) {\r\n        let maxWidth, maxHeight;\r\n        if (width === undefined || height === undefined) {\r\n            const container = _getParentNode(canvas);\r\n            if (!container) {\r\n                width = canvas.clientWidth;\r\n                height = canvas.clientHeight;\r\n            } else {\r\n                const rect = container.getBoundingClientRect();\r\n                const containerStyle = getComputedStyle(container);\r\n                const containerBorder = getPositionedStyle(containerStyle, 'border', 'width');\r\n                const containerPadding = getPositionedStyle(containerStyle, 'padding');\r\n                width = rect.width - containerPadding.width - containerBorder.width;\r\n                height = rect.height - containerPadding.height - containerBorder.height;\r\n                maxWidth = parseMaxStyle(containerStyle.maxWidth, container, 'clientWidth');\r\n                maxHeight = parseMaxStyle(containerStyle.maxHeight, container, 'clientHeight');\r\n            }\r\n        }\r\n        return {\r\n            width,\r\n            height,\r\n            maxWidth: maxWidth || INFINITY,\r\n            maxHeight: maxHeight || INFINITY\r\n        };\r\n    }\r\n\r\n    const round1 = v => Math.round(v * 10) / 10;\r\n\r\n    function getMaximumSize(canvas, bbWidth, bbHeight, aspectRatio) {\r\n        const style = getComputedStyle(canvas);\r\n        const margins = getPositionedStyle(style, 'margin');\r\n        const maxWidth = parseMaxStyle(style.maxWidth, canvas, 'clientWidth') || INFINITY;\r\n        const maxHeight = parseMaxStyle(style.maxHeight, canvas, 'clientHeight') || INFINITY;\r\n        const containerSize = getContainerSize(canvas, bbWidth, bbHeight);\r\n        let {width, height} = containerSize;\r\n        if (style.boxSizing === 'content-box') {\r\n            const borders = getPositionedStyle(style, 'border', 'width');\r\n            const paddings = getPositionedStyle(style, 'padding');\r\n            width -= paddings.width + borders.width;\r\n            height -= paddings.height + borders.height;\r\n        }\r\n        width = Math.max(0, width - margins.width);\r\n        height = Math.max(0, aspectRatio ? Math.floor(width / aspectRatio) : height - margins.height);\r\n        width = round1(Math.min(width, maxWidth, containerSize.maxWidth));\r\n        height = round1(Math.min(height, maxHeight, containerSize.maxHeight));\r\n        if (width && !height) {\r\n            height = round1(width / 2);\r\n        }\r\n        return {\r\n            width,\r\n            height\r\n        };\r\n    }\r\n\r\n    function retinaScale(chart, forceRatio, forceStyle) {\r\n        const pixelRatio = chart.currentDevicePixelRatio = forceRatio || 1;\r\n        const {canvas, width, height} = chart;\r\n        canvas.height = height * pixelRatio;\r\n        canvas.width = width * pixelRatio;\r\n        chart.ctx.setTransform(pixelRatio, 0, 0, pixelRatio, 0, 0);\r\n        if (canvas.style && (forceStyle || (!canvas.style.height && !canvas.style.width))) {\r\n            canvas.style.height = height + 'px';\r\n            canvas.style.width = width + 'px';\r\n        }\r\n    }\r\n\r\n    const supportsEventListenerOptions = (function () {\r\n        let passiveSupported = false;\r\n        try {\r\n            const options = {\r\n                get passive() {\r\n                    passiveSupported = true;\r\n                    return false;\r\n                }\r\n            };\r\n            window.addEventListener('test', null, options);\r\n            window.removeEventListener('test', null, options);\r\n        } catch (e) {\r\n        }\r\n        return passiveSupported;\r\n    }());\r\n\r\n    function readUsedSize(element, property) {\r\n        const value = getStyle(element, property);\r\n        const matches = value && value.match(/^(\\d+)(\\.\\d+)?px$/);\r\n        return matches ? +matches[1] : undefined;\r\n    }\r\n\r\n    function getRelativePosition(e, chart) {\r\n        if ('native' in e) {\r\n            return {\r\n                x: e.x,\r\n                y: e.y\r\n            };\r\n        }\r\n        return getRelativePosition$1(e, chart);\r\n    }\r\n\r\n    function evaluateAllVisibleItems(chart, handler) {\r\n        const metasets = chart.getSortedVisibleDatasetMetas();\r\n        let index, data, element;\r\n        for (let i = 0, ilen = metasets.length; i < ilen; ++i) {\r\n            ({index, data} = metasets[i]);\r\n            for (let j = 0, jlen = data.length; j < jlen; ++j) {\r\n                element = data[j];\r\n                if (!element.skip) {\r\n                    handler(element, index, j);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    function binarySearch(metaset, axis, value, intersect) {\r\n        const {controller, data, _sorted} = metaset;\r\n        const iScale = controller._cachedMeta.iScale;\r\n        if (iScale && axis === iScale.axis && _sorted && data.length) {\r\n            const lookupMethod = iScale._reversePixels ? _rlookupByKey : _lookupByKey;\r\n            if (!intersect) {\r\n                return lookupMethod(data, axis, value);\r\n            } else if (controller._sharedOptions) {\r\n                const el = data[0];\r\n                const range = typeof el.getRange === 'function' && el.getRange(axis);\r\n                if (range) {\r\n                    const start = lookupMethod(data, axis, value - range);\r\n                    const end = lookupMethod(data, axis, value + range);\r\n                    return {lo: start.lo, hi: end.hi};\r\n                }\r\n            }\r\n        }\r\n        return {lo: 0, hi: data.length - 1};\r\n    }\r\n\r\n    function optimizedEvaluateItems(chart, axis, position, handler, intersect) {\r\n        const metasets = chart.getSortedVisibleDatasetMetas();\r\n        const value = position[axis];\r\n        for (let i = 0, ilen = metasets.length; i < ilen; ++i) {\r\n            const {index, data} = metasets[i];\r\n            const {lo, hi} = binarySearch(metasets[i], axis, value, intersect);\r\n            for (let j = lo; j <= hi; ++j) {\r\n                const element = data[j];\r\n                if (!element.skip) {\r\n                    handler(element, index, j);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    function getDistanceMetricForAxis(axis) {\r\n        const useX = axis.indexOf('x') !== -1;\r\n        const useY = axis.indexOf('y') !== -1;\r\n        return function (pt1, pt2) {\r\n            const deltaX = useX ? Math.abs(pt1.x - pt2.x) : 0;\r\n            const deltaY = useY ? Math.abs(pt1.y - pt2.y) : 0;\r\n            return Math.sqrt(Math.pow(deltaX, 2) + Math.pow(deltaY, 2));\r\n        };\r\n    }\r\n\r\n    function getIntersectItems(chart, position, axis, useFinalPosition) {\r\n        const items = [];\r\n        if (!_isPointInArea(position, chart.chartArea, chart._minPadding)) {\r\n            return items;\r\n        }\r\n        const evaluationFunc = function (element, datasetIndex, index) {\r\n            if (element.inRange(position.x, position.y, useFinalPosition)) {\r\n                items.push({element, datasetIndex, index});\r\n            }\r\n        };\r\n        optimizedEvaluateItems(chart, axis, position, evaluationFunc, true);\r\n        return items;\r\n    }\r\n\r\n    function getNearestItems(chart, position, axis, intersect, useFinalPosition) {\r\n        const distanceMetric = getDistanceMetricForAxis(axis);\r\n        let minDistance = Number.POSITIVE_INFINITY;\r\n        let items = [];\r\n        if (!_isPointInArea(position, chart.chartArea, chart._minPadding)) {\r\n            return items;\r\n        }\r\n        const evaluationFunc = function (element, datasetIndex, index) {\r\n            if (intersect && !element.inRange(position.x, position.y, useFinalPosition)) {\r\n                return;\r\n            }\r\n            const center = element.getCenterPoint(useFinalPosition);\r\n            const distance = distanceMetric(position, center);\r\n            if (distance < minDistance) {\r\n                items = [{element, datasetIndex, index}];\r\n                minDistance = distance;\r\n            } else if (distance === minDistance) {\r\n                items.push({element, datasetIndex, index});\r\n            }\r\n        };\r\n        optimizedEvaluateItems(chart, axis, position, evaluationFunc);\r\n        return items;\r\n    }\r\n\r\n    function getAxisItems(chart, e, options, useFinalPosition) {\r\n        const position = getRelativePosition(e, chart);\r\n        const items = [];\r\n        const axis = options.axis;\r\n        const rangeMethod = axis === 'x' ? 'inXRange' : 'inYRange';\r\n        let intersectsItem = false;\r\n        evaluateAllVisibleItems(chart, (element, datasetIndex, index) => {\r\n            if (element[rangeMethod](position[axis], useFinalPosition)) {\r\n                items.push({element, datasetIndex, index});\r\n            }\r\n            if (element.inRange(position.x, position.y, useFinalPosition)) {\r\n                intersectsItem = true;\r\n            }\r\n        });\r\n        if (options.intersect && !intersectsItem) {\r\n            return [];\r\n        }\r\n        return items;\r\n    }\r\n\r\n    var Interaction = {\r\n        modes: {\r\n            index(chart, e, options, useFinalPosition) {\r\n                const position = getRelativePosition(e, chart);\r\n                const axis = options.axis || 'x';\r\n                const items = options.intersect\r\n                    ? getIntersectItems(chart, position, axis, useFinalPosition)\r\n                    : getNearestItems(chart, position, axis, false, useFinalPosition);\r\n                const elements = [];\r\n                if (!items.length) {\r\n                    return [];\r\n                }\r\n                chart.getSortedVisibleDatasetMetas().forEach((meta) => {\r\n                    const index = items[0].index;\r\n                    const element = meta.data[index];\r\n                    if (element && !element.skip) {\r\n                        elements.push({element, datasetIndex: meta.index, index});\r\n                    }\r\n                });\r\n                return elements;\r\n            },\r\n            dataset(chart, e, options, useFinalPosition) {\r\n                const position = getRelativePosition(e, chart);\r\n                const axis = options.axis || 'xy';\r\n                let items = options.intersect\r\n                    ? getIntersectItems(chart, position, axis, useFinalPosition) :\r\n                    getNearestItems(chart, position, axis, false, useFinalPosition);\r\n                if (items.length > 0) {\r\n                    const datasetIndex = items[0].datasetIndex;\r\n                    const data = chart.getDatasetMeta(datasetIndex).data;\r\n                    items = [];\r\n                    for (let i = 0; i < data.length; ++i) {\r\n                        items.push({element: data[i], datasetIndex, index: i});\r\n                    }\r\n                }\r\n                return items;\r\n            },\r\n            point(chart, e, options, useFinalPosition) {\r\n                const position = getRelativePosition(e, chart);\r\n                const axis = options.axis || 'xy';\r\n                return getIntersectItems(chart, position, axis, useFinalPosition);\r\n            },\r\n            nearest(chart, e, options, useFinalPosition) {\r\n                const position = getRelativePosition(e, chart);\r\n                const axis = options.axis || 'xy';\r\n                return getNearestItems(chart, position, axis, options.intersect, useFinalPosition);\r\n            },\r\n            x(chart, e, options, useFinalPosition) {\r\n                options.axis = 'x';\r\n                return getAxisItems(chart, e, options, useFinalPosition);\r\n            },\r\n            y(chart, e, options, useFinalPosition) {\r\n                options.axis = 'y';\r\n                return getAxisItems(chart, e, options, useFinalPosition);\r\n            }\r\n        }\r\n    };\r\n\r\n    const LINE_HEIGHT = new RegExp(/^(normal|(\\d+(?:\\.\\d+)?)(px|em|%)?)$/);\r\n\r\n    function toLineHeight(value, size) {\r\n        const matches = ('' + value).match(LINE_HEIGHT);\r\n        if (!matches || matches[1] === 'normal') {\r\n            return size * 1.2;\r\n        }\r\n        value = +matches[2];\r\n        switch (matches[3]) {\r\n            case 'px':\r\n                return value;\r\n            case '%':\r\n                value /= 100;\r\n                break;\r\n        }\r\n        return size * value;\r\n    }\r\n\r\n    const numberOrZero$1 = v => +v || 0;\r\n\r\n    function readValueToProps(value, props) {\r\n        const ret = {};\r\n        const objProps = isObject(props);\r\n        const keys = objProps ? Object.keys(props) : props;\r\n        const read = isObject(value)\r\n            ? objProps\r\n                ? prop => valueOrDefault(value[prop], value[props[prop]])\r\n                : prop => value[prop]\r\n            : () => value;\r\n        for (const prop of keys) {\r\n            ret[prop] = numberOrZero$1(read(prop));\r\n        }\r\n        return ret;\r\n    }\r\n\r\n    function toTRBL(value) {\r\n        return readValueToProps(value, {top: 'y', right: 'x', bottom: 'y', left: 'x'});\r\n    }\r\n\r\n    function toTRBLCorners(value) {\r\n        return readValueToProps(value, ['topLeft', 'topRight', 'bottomLeft', 'bottomRight']);\r\n    }\r\n\r\n    function toPadding(value) {\r\n        const obj = toTRBL(value);\r\n        obj.width = obj.left + obj.right;\r\n        obj.height = obj.top + obj.bottom;\r\n        return obj;\r\n    }\r\n\r\n    function toFont(options, fallback) {\r\n        options = options || {};\r\n        fallback = fallback || defaults.font;\r\n        let size = valueOrDefault(options.size, fallback.size);\r\n        if (typeof size === 'string') {\r\n            size = parseInt(size, 10);\r\n        }\r\n        const font = {\r\n            family: valueOrDefault(options.family, fallback.family),\r\n            lineHeight: toLineHeight(valueOrDefault(options.lineHeight, fallback.lineHeight), size),\r\n            size,\r\n            style: valueOrDefault(options.style, fallback.style),\r\n            weight: valueOrDefault(options.weight, fallback.weight),\r\n            string: ''\r\n        };\r\n        font.string = toFontString(font);\r\n        return font;\r\n    }\r\n\r\n    function resolve(inputs, context, index, info) {\r\n        let cacheable = true;\r\n        let i, ilen, value;\r\n        for (i = 0, ilen = inputs.length; i < ilen; ++i) {\r\n            value = inputs[i];\r\n            if (value === undefined) {\r\n                continue;\r\n            }\r\n            if (context !== undefined && typeof value === 'function') {\r\n                value = value(context);\r\n                cacheable = false;\r\n            }\r\n            if (index !== undefined && isArray(value)) {\r\n                value = value[index % value.length];\r\n                cacheable = false;\r\n            }\r\n            if (value !== undefined) {\r\n                if (info && !cacheable) {\r\n                    info.cacheable = false;\r\n                }\r\n                return value;\r\n            }\r\n        }\r\n    }\r\n\r\n    function _addGrace(minmax, grace) {\r\n        const {min, max} = minmax;\r\n        return {\r\n            min: min - Math.abs(toDimension(grace, min)),\r\n            max: max + toDimension(grace, max)\r\n        };\r\n    }\r\n\r\n    const STATIC_POSITIONS = ['left', 'top', 'right', 'bottom'];\r\n\r\n    function filterByPosition(array, position) {\r\n        return array.filter(v => v.pos === position);\r\n    }\r\n\r\n    function filterDynamicPositionByAxis(array, axis) {\r\n        return array.filter(v => STATIC_POSITIONS.indexOf(v.pos) === -1 && v.box.axis === axis);\r\n    }\r\n\r\n    function sortByWeight(array, reverse) {\r\n        return array.sort((a, b) => {\r\n            const v0 = reverse ? b : a;\r\n            const v1 = reverse ? a : b;\r\n            return v0.weight === v1.weight ?\r\n                v0.index - v1.index :\r\n                v0.weight - v1.weight;\r\n        });\r\n    }\r\n\r\n    function wrapBoxes(boxes) {\r\n        const layoutBoxes = [];\r\n        let i, ilen, box;\r\n        for (i = 0, ilen = (boxes || []).length; i < ilen; ++i) {\r\n            box = boxes[i];\r\n            layoutBoxes.push({\r\n                index: i,\r\n                box,\r\n                pos: box.position,\r\n                horizontal: box.isHorizontal(),\r\n                weight: box.weight\r\n            });\r\n        }\r\n        return layoutBoxes;\r\n    }\r\n\r\n    function setLayoutDims(layouts, params) {\r\n        let i, ilen, layout;\r\n        for (i = 0, ilen = layouts.length; i < ilen; ++i) {\r\n            layout = layouts[i];\r\n            if (layout.horizontal) {\r\n                layout.width = layout.box.fullSize && params.availableWidth;\r\n                layout.height = params.hBoxMaxHeight;\r\n            } else {\r\n                layout.width = params.vBoxMaxWidth;\r\n                layout.height = layout.box.fullSize && params.availableHeight;\r\n            }\r\n        }\r\n    }\r\n\r\n    function buildLayoutBoxes(boxes) {\r\n        const layoutBoxes = wrapBoxes(boxes);\r\n        const fullSize = sortByWeight(layoutBoxes.filter(wrap => wrap.box.fullSize), true);\r\n        const left = sortByWeight(filterByPosition(layoutBoxes, 'left'), true);\r\n        const right = sortByWeight(filterByPosition(layoutBoxes, 'right'));\r\n        const top = sortByWeight(filterByPosition(layoutBoxes, 'top'), true);\r\n        const bottom = sortByWeight(filterByPosition(layoutBoxes, 'bottom'));\r\n        const centerHorizontal = filterDynamicPositionByAxis(layoutBoxes, 'x');\r\n        const centerVertical = filterDynamicPositionByAxis(layoutBoxes, 'y');\r\n        return {\r\n            fullSize,\r\n            leftAndTop: left.concat(top),\r\n            rightAndBottom: right.concat(centerVertical).concat(bottom).concat(centerHorizontal),\r\n            chartArea: filterByPosition(layoutBoxes, 'chartArea'),\r\n            vertical: left.concat(right).concat(centerVertical),\r\n            horizontal: top.concat(bottom).concat(centerHorizontal)\r\n        };\r\n    }\r\n\r\n    function getCombinedMax(maxPadding, chartArea, a, b) {\r\n        return Math.max(maxPadding[a], chartArea[a]) + Math.max(maxPadding[b], chartArea[b]);\r\n    }\r\n\r\n    function updateMaxPadding(maxPadding, boxPadding) {\r\n        maxPadding.top = Math.max(maxPadding.top, boxPadding.top);\r\n        maxPadding.left = Math.max(maxPadding.left, boxPadding.left);\r\n        maxPadding.bottom = Math.max(maxPadding.bottom, boxPadding.bottom);\r\n        maxPadding.right = Math.max(maxPadding.right, boxPadding.right);\r\n    }\r\n\r\n    function updateDims(chartArea, params, layout) {\r\n        const box = layout.box;\r\n        const maxPadding = chartArea.maxPadding;\r\n        if (isObject(layout.pos)) {\r\n            return {same: false, other: false};\r\n        }\r\n        if (layout.size) {\r\n            chartArea[layout.pos] -= layout.size;\r\n        }\r\n        layout.size = layout.horizontal ? box.height : box.width;\r\n        chartArea[layout.pos] += layout.size;\r\n        if (box.getPadding) {\r\n            updateMaxPadding(maxPadding, box.getPadding());\r\n        }\r\n        const newWidth = Math.max(0, params.outerWidth - getCombinedMax(maxPadding, chartArea, 'left', 'right'));\r\n        const newHeight = Math.max(0, params.outerHeight - getCombinedMax(maxPadding, chartArea, 'top', 'bottom'));\r\n        const widthChanged = newWidth !== chartArea.w;\r\n        const heightChanged = newHeight !== chartArea.h;\r\n        chartArea.w = newWidth;\r\n        chartArea.h = newHeight;\r\n        return layout.horizontal\r\n            ? {same: widthChanged, other: heightChanged}\r\n            : {same: heightChanged, other: widthChanged};\r\n    }\r\n\r\n    function handleMaxPadding(chartArea) {\r\n        const maxPadding = chartArea.maxPadding;\r\n\r\n        function updatePos(pos) {\r\n            const change = Math.max(maxPadding[pos] - chartArea[pos], 0);\r\n            chartArea[pos] += change;\r\n            return change;\r\n        }\r\n\r\n        chartArea.y += updatePos('top');\r\n        chartArea.x += updatePos('left');\r\n        updatePos('right');\r\n        updatePos('bottom');\r\n    }\r\n\r\n    function getMargins(horizontal, chartArea) {\r\n        const maxPadding = chartArea.maxPadding;\r\n\r\n        function marginForPositions(positions) {\r\n            const margin = {left: 0, top: 0, right: 0, bottom: 0};\r\n            positions.forEach((pos) => {\r\n                margin[pos] = Math.max(chartArea[pos], maxPadding[pos]);\r\n            });\r\n            return margin;\r\n        }\r\n\r\n        return horizontal\r\n            ? marginForPositions(['left', 'right'])\r\n            : marginForPositions(['top', 'bottom']);\r\n    }\r\n\r\n    function fitBoxes(boxes, chartArea, params) {\r\n        const refitBoxes = [];\r\n        let i, ilen, layout, box, refit, changed;\r\n        for (i = 0, ilen = boxes.length, refit = 0; i < ilen; ++i) {\r\n            layout = boxes[i];\r\n            box = layout.box;\r\n            box.update(\r\n                layout.width || chartArea.w,\r\n                layout.height || chartArea.h,\r\n                getMargins(layout.horizontal, chartArea)\r\n            );\r\n            const {same, other} = updateDims(chartArea, params, layout);\r\n            refit |= same && refitBoxes.length;\r\n            changed = changed || other;\r\n            if (!box.fullSize) {\r\n                refitBoxes.push(layout);\r\n            }\r\n        }\r\n        return refit && fitBoxes(refitBoxes, chartArea, params) || changed;\r\n    }\r\n\r\n    function placeBoxes(boxes, chartArea, params) {\r\n        const userPadding = params.padding;\r\n        let x = chartArea.x;\r\n        let y = chartArea.y;\r\n        let i, ilen, layout, box;\r\n        for (i = 0, ilen = boxes.length; i < ilen; ++i) {\r\n            layout = boxes[i];\r\n            box = layout.box;\r\n            if (layout.horizontal) {\r\n                box.left = box.fullSize ? userPadding.left : chartArea.left;\r\n                box.right = box.fullSize ? params.outerWidth - userPadding.right : chartArea.left + chartArea.w;\r\n                box.top = y;\r\n                box.bottom = y + box.height;\r\n                box.width = box.right - box.left;\r\n                y = box.bottom;\r\n            } else {\r\n                box.left = x;\r\n                box.right = x + box.width;\r\n                box.top = box.fullSize ? userPadding.top : chartArea.top;\r\n                box.bottom = box.fullSize ? params.outerHeight - userPadding.right : chartArea.top + chartArea.h;\r\n                box.height = box.bottom - box.top;\r\n                x = box.right;\r\n            }\r\n        }\r\n        chartArea.x = x;\r\n        chartArea.y = y;\r\n    }\r\n\r\n    defaults.set('layout', {\r\n        padding: {\r\n            top: 0,\r\n            right: 0,\r\n            bottom: 0,\r\n            left: 0\r\n        }\r\n    });\r\n    var layouts = {\r\n        addBox(chart, item) {\r\n            if (!chart.boxes) {\r\n                chart.boxes = [];\r\n            }\r\n            item.fullSize = item.fullSize || false;\r\n            item.position = item.position || 'top';\r\n            item.weight = item.weight || 0;\r\n            item._layers = item._layers || function () {\r\n                return [{\r\n                    z: 0,\r\n                    draw(chartArea) {\r\n                        item.draw(chartArea);\r\n                    }\r\n                }];\r\n            };\r\n            chart.boxes.push(item);\r\n        },\r\n        removeBox(chart, layoutItem) {\r\n            const index = chart.boxes ? chart.boxes.indexOf(layoutItem) : -1;\r\n            if (index !== -1) {\r\n                chart.boxes.splice(index, 1);\r\n            }\r\n        },\r\n        configure(chart, item, options) {\r\n            item.fullSize = options.fullSize;\r\n            item.position = options.position;\r\n            item.weight = options.weight;\r\n        },\r\n        update(chart, width, height, minPadding) {\r\n            if (!chart) {\r\n                return;\r\n            }\r\n            const padding = toPadding(chart.options.layout.padding);\r\n            const availableWidth = width - padding.width;\r\n            const availableHeight = height - padding.height;\r\n            const boxes = buildLayoutBoxes(chart.boxes);\r\n            const verticalBoxes = boxes.vertical;\r\n            const horizontalBoxes = boxes.horizontal;\r\n            each(chart.boxes, box => {\r\n                if (typeof box.beforeLayout === 'function') {\r\n                    box.beforeLayout();\r\n                }\r\n            });\r\n            const visibleVerticalBoxCount = verticalBoxes.reduce((total, wrap) =>\r\n                wrap.box.options && wrap.box.options.display === false ? total : total + 1, 0) || 1;\r\n            const params = Object.freeze({\r\n                outerWidth: width,\r\n                outerHeight: height,\r\n                padding,\r\n                availableWidth,\r\n                availableHeight,\r\n                vBoxMaxWidth: availableWidth / 2 / visibleVerticalBoxCount,\r\n                hBoxMaxHeight: availableHeight / 2\r\n            });\r\n            const maxPadding = Object.assign({}, padding);\r\n            updateMaxPadding(maxPadding, toPadding(minPadding));\r\n            const chartArea = Object.assign({\r\n                maxPadding,\r\n                w: availableWidth,\r\n                h: availableHeight,\r\n                x: padding.left,\r\n                y: padding.top\r\n            }, padding);\r\n            setLayoutDims(verticalBoxes.concat(horizontalBoxes), params);\r\n            fitBoxes(boxes.fullSize, chartArea, params);\r\n            fitBoxes(verticalBoxes, chartArea, params);\r\n            if (fitBoxes(horizontalBoxes, chartArea, params)) {\r\n                fitBoxes(verticalBoxes, chartArea, params);\r\n            }\r\n            handleMaxPadding(chartArea);\r\n            placeBoxes(boxes.leftAndTop, chartArea, params);\r\n            chartArea.x += chartArea.w;\r\n            chartArea.y += chartArea.h;\r\n            placeBoxes(boxes.rightAndBottom, chartArea, params);\r\n            chart.chartArea = {\r\n                left: chartArea.left,\r\n                top: chartArea.top,\r\n                right: chartArea.left + chartArea.w,\r\n                bottom: chartArea.top + chartArea.h,\r\n                height: chartArea.h,\r\n                width: chartArea.w,\r\n            };\r\n            each(boxes.chartArea, (layout) => {\r\n                const box = layout.box;\r\n                Object.assign(box, chart.chartArea);\r\n                box.update(chartArea.w, chartArea.h);\r\n            });\r\n        }\r\n    };\r\n\r\n    class BasePlatform {\r\n        acquireContext(canvas, aspectRatio) {\r\n        }\r\n\r\n        releaseContext(context) {\r\n            return false;\r\n        }\r\n\r\n        addEventListener(chart, type, listener) {\r\n        }\r\n\r\n        removeEventListener(chart, type, listener) {\r\n        }\r\n\r\n        getDevicePixelRatio() {\r\n            return 1;\r\n        }\r\n\r\n        getMaximumSize(element, width, height, aspectRatio) {\r\n            width = Math.max(0, width || element.width);\r\n            height = height || element.height;\r\n            return {\r\n                width,\r\n                height: Math.max(0, aspectRatio ? Math.floor(width / aspectRatio) : height)\r\n            };\r\n        }\r\n\r\n        isAttached(canvas) {\r\n            return true;\r\n        }\r\n    }\r\n\r\n    class BasicPlatform extends BasePlatform {\r\n        acquireContext(item) {\r\n            return item && item.getContext && item.getContext('2d') || null;\r\n        }\r\n    }\r\n\r\n    const EXPANDO_KEY = '$chartjs';\r\n    const EVENT_TYPES = {\r\n        touchstart: 'mousedown',\r\n        touchmove: 'mousemove',\r\n        touchend: 'mouseup',\r\n        pointerenter: 'mouseenter',\r\n        pointerdown: 'mousedown',\r\n        pointermove: 'mousemove',\r\n        pointerup: 'mouseup',\r\n        pointerleave: 'mouseout',\r\n        pointerout: 'mouseout'\r\n    };\r\n    const isNullOrEmpty = value => value === null || value === '';\r\n\r\n    function initCanvas(canvas, aspectRatio) {\r\n        const style = canvas.style;\r\n        const renderHeight = canvas.getAttribute('height');\r\n        const renderWidth = canvas.getAttribute('width');\r\n        canvas[EXPANDO_KEY] = {\r\n            initial: {\r\n                height: renderHeight,\r\n                width: renderWidth,\r\n                style: {\r\n                    display: style.display,\r\n                    height: style.height,\r\n                    width: style.width\r\n                }\r\n            }\r\n        };\r\n        style.display = style.display || 'block';\r\n        style.boxSizing = style.boxSizing || 'border-box';\r\n        if (isNullOrEmpty(renderWidth)) {\r\n            const displayWidth = readUsedSize(canvas, 'width');\r\n            if (displayWidth !== undefined) {\r\n                canvas.width = displayWidth;\r\n            }\r\n        }\r\n        if (isNullOrEmpty(renderHeight)) {\r\n            if (canvas.style.height === '') {\r\n                canvas.height = canvas.width / (aspectRatio || 2);\r\n            } else {\r\n                const displayHeight = readUsedSize(canvas, 'height');\r\n                if (displayHeight !== undefined) {\r\n                    canvas.height = displayHeight;\r\n                }\r\n            }\r\n        }\r\n        return canvas;\r\n    }\r\n\r\n    const eventListenerOptions = supportsEventListenerOptions ? {passive: true} : false;\r\n\r\n    function addListener(node, type, listener) {\r\n        node.addEventListener(type, listener, eventListenerOptions);\r\n    }\r\n\r\n    function removeListener(chart, type, listener) {\r\n        chart.canvas.removeEventListener(type, listener, eventListenerOptions);\r\n    }\r\n\r\n    function fromNativeEvent(event, chart) {\r\n        const type = EVENT_TYPES[event.type] || event.type;\r\n        const {x, y} = getRelativePosition$1(event, chart);\r\n        return {\r\n            type,\r\n            chart,\r\n            native: event,\r\n            x: x !== undefined ? x : null,\r\n            y: y !== undefined ? y : null,\r\n        };\r\n    }\r\n\r\n    function createAttachObserver(chart, type, listener) {\r\n        const canvas = chart.canvas;\r\n        const container = canvas && _getParentNode(canvas);\r\n        const element = container || canvas;\r\n        const observer = new MutationObserver(entries => {\r\n            const parent = _getParentNode(element);\r\n            entries.forEach(entry => {\r\n                for (let i = 0; i < entry.addedNodes.length; i++) {\r\n                    const added = entry.addedNodes[i];\r\n                    if (added === element || added === parent) {\r\n                        listener(entry.target);\r\n                    }\r\n                }\r\n            });\r\n        });\r\n        observer.observe(document, {childList: true, subtree: true});\r\n        return observer;\r\n    }\r\n\r\n    function createDetachObserver(chart, type, listener) {\r\n        const canvas = chart.canvas;\r\n        const container = canvas && _getParentNode(canvas);\r\n        if (!container) {\r\n            return;\r\n        }\r\n        const observer = new MutationObserver(entries => {\r\n            entries.forEach(entry => {\r\n                for (let i = 0; i < entry.removedNodes.length; i++) {\r\n                    if (entry.removedNodes[i] === canvas) {\r\n                        listener();\r\n                        break;\r\n                    }\r\n                }\r\n            });\r\n        });\r\n        observer.observe(container, {childList: true});\r\n        return observer;\r\n    }\r\n\r\n    const drpListeningCharts = new Map();\r\n    let oldDevicePixelRatio = 0;\r\n\r\n    function onWindowResize() {\r\n        const dpr = window.devicePixelRatio;\r\n        if (dpr === oldDevicePixelRatio) {\r\n            return;\r\n        }\r\n        oldDevicePixelRatio = dpr;\r\n        drpListeningCharts.forEach((resize, chart) => {\r\n            if (chart.currentDevicePixelRatio !== dpr) {\r\n                resize();\r\n            }\r\n        });\r\n    }\r\n\r\n    function listenDevicePixelRatioChanges(chart, resize) {\r\n        if (!drpListeningCharts.size) {\r\n            window.addEventListener('resize', onWindowResize);\r\n        }\r\n        drpListeningCharts.set(chart, resize);\r\n    }\r\n\r\n    function unlistenDevicePixelRatioChanges(chart) {\r\n        drpListeningCharts.delete(chart);\r\n        if (!drpListeningCharts.size) {\r\n            window.removeEventListener('resize', onWindowResize);\r\n        }\r\n    }\r\n\r\n    function createResizeObserver(chart, type, listener) {\r\n        const canvas = chart.canvas;\r\n        const container = canvas && _getParentNode(canvas);\r\n        if (!container) {\r\n            return;\r\n        }\r\n        const resize = throttled((width, height) => {\r\n            const w = container.clientWidth;\r\n            listener(width, height);\r\n            if (w < container.clientWidth) {\r\n                listener();\r\n            }\r\n        }, window);\r\n        const observer = new ResizeObserver(entries => {\r\n            const entry = entries[0];\r\n            const width = entry.contentRect.width;\r\n            const height = entry.contentRect.height;\r\n            if (width === 0 && height === 0) {\r\n                return;\r\n            }\r\n            resize(width, height);\r\n        });\r\n        observer.observe(container);\r\n        listenDevicePixelRatioChanges(chart, resize);\r\n        return observer;\r\n    }\r\n\r\n    function releaseObserver(chart, type, observer) {\r\n        if (observer) {\r\n            observer.disconnect();\r\n        }\r\n        if (type === 'resize') {\r\n            unlistenDevicePixelRatioChanges(chart);\r\n        }\r\n    }\r\n\r\n    function createProxyAndListen(chart, type, listener) {\r\n        const canvas = chart.canvas;\r\n        const proxy = throttled((event) => {\r\n            if (chart.ctx !== null) {\r\n                listener(fromNativeEvent(event, chart));\r\n            }\r\n        }, chart, (args) => {\r\n            const event = args[0];\r\n            return [event, event.offsetX, event.offsetY];\r\n        });\r\n        addListener(canvas, type, proxy);\r\n        return proxy;\r\n    }\r\n\r\n    class DomPlatform extends BasePlatform {\r\n        acquireContext(canvas, aspectRatio) {\r\n            const context = canvas && canvas.getContext && canvas.getContext('2d');\r\n            if (context && context.canvas === canvas) {\r\n                initCanvas(canvas, aspectRatio);\r\n                return context;\r\n            }\r\n            return null;\r\n        }\r\n\r\n        releaseContext(context) {\r\n            const canvas = context.canvas;\r\n            if (!canvas[EXPANDO_KEY]) {\r\n                return false;\r\n            }\r\n            const initial = canvas[EXPANDO_KEY].initial;\r\n            ['height', 'width'].forEach((prop) => {\r\n                const value = initial[prop];\r\n                if (isNullOrUndef(value)) {\r\n                    canvas.removeAttribute(prop);\r\n                } else {\r\n                    canvas.setAttribute(prop, value);\r\n                }\r\n            });\r\n            const style = initial.style || {};\r\n            Object.keys(style).forEach((key) => {\r\n                canvas.style[key] = style[key];\r\n            });\r\n            canvas.width = canvas.width;\r\n            delete canvas[EXPANDO_KEY];\r\n            return true;\r\n        }\r\n\r\n        addEventListener(chart, type, listener) {\r\n            this.removeEventListener(chart, type);\r\n            const proxies = chart.$proxies || (chart.$proxies = {});\r\n            const handlers = {\r\n                attach: createAttachObserver,\r\n                detach: createDetachObserver,\r\n                resize: createResizeObserver\r\n            };\r\n            const handler = handlers[type] || createProxyAndListen;\r\n            proxies[type] = handler(chart, type, listener);\r\n        }\r\n\r\n        removeEventListener(chart, type) {\r\n            const proxies = chart.$proxies || (chart.$proxies = {});\r\n            const proxy = proxies[type];\r\n            if (!proxy) {\r\n                return;\r\n            }\r\n            const handlers = {\r\n                attach: releaseObserver,\r\n                detach: releaseObserver,\r\n                resize: releaseObserver\r\n            };\r\n            const handler = handlers[type] || removeListener;\r\n            handler(chart, type, proxy);\r\n            proxies[type] = undefined;\r\n        }\r\n\r\n        getDevicePixelRatio() {\r\n            return window.devicePixelRatio;\r\n        }\r\n\r\n        getMaximumSize(canvas, width, height, aspectRatio) {\r\n            return getMaximumSize(canvas, width, height, aspectRatio);\r\n        }\r\n\r\n        isAttached(canvas) {\r\n            const container = _getParentNode(canvas);\r\n            return !!(container && _getParentNode(container));\r\n        }\r\n    }\r\n\r\n    var platforms = /*#__PURE__*/Object.freeze({\r\n        __proto__: null,\r\n        BasePlatform: BasePlatform,\r\n        BasicPlatform: BasicPlatform,\r\n        DomPlatform: DomPlatform\r\n    });\r\n\r\n    const atEdge = (t) => t === 0 || t === 1;\r\n    const elasticIn = (t, s, p) => -(Math.pow(2, 10 * (t -= 1)) * Math.sin((t - s) * TAU / p));\r\n    const elasticOut = (t, s, p) => Math.pow(2, -10 * t) * Math.sin((t - s) * TAU / p) + 1;\r\n    const effects = {\r\n        linear: t => t,\r\n        easeInQuad: t => t * t,\r\n        easeOutQuad: t => -t * (t - 2),\r\n        easeInOutQuad: t => ((t /= 0.5) < 1)\r\n            ? 0.5 * t * t\r\n            : -0.5 * ((--t) * (t - 2) - 1),\r\n        easeInCubic: t => t * t * t,\r\n        easeOutCubic: t => (t -= 1) * t * t + 1,\r\n        easeInOutCubic: t => ((t /= 0.5) < 1)\r\n            ? 0.5 * t * t * t\r\n            : 0.5 * ((t -= 2) * t * t + 2),\r\n        easeInQuart: t => t * t * t * t,\r\n        easeOutQuart: t => -((t -= 1) * t * t * t - 1),\r\n        easeInOutQuart: t => ((t /= 0.5) < 1)\r\n            ? 0.5 * t * t * t * t\r\n            : -0.5 * ((t -= 2) * t * t * t - 2),\r\n        easeInQuint: t => t * t * t * t * t,\r\n        easeOutQuint: t => (t -= 1) * t * t * t * t + 1,\r\n        easeInOutQuint: t => ((t /= 0.5) < 1)\r\n            ? 0.5 * t * t * t * t * t\r\n            : 0.5 * ((t -= 2) * t * t * t * t + 2),\r\n        easeInSine: t => -Math.cos(t * HALF_PI) + 1,\r\n        easeOutSine: t => Math.sin(t * HALF_PI),\r\n        easeInOutSine: t => -0.5 * (Math.cos(PI * t) - 1),\r\n        easeInExpo: t => (t === 0) ? 0 : Math.pow(2, 10 * (t - 1)),\r\n        easeOutExpo: t => (t === 1) ? 1 : -Math.pow(2, -10 * t) + 1,\r\n        easeInOutExpo: t => atEdge(t) ? t : t < 0.5\r\n            ? 0.5 * Math.pow(2, 10 * (t * 2 - 1))\r\n            : 0.5 * (-Math.pow(2, -10 * (t * 2 - 1)) + 2),\r\n        easeInCirc: t => (t >= 1) ? t : -(Math.sqrt(1 - t * t) - 1),\r\n        easeOutCirc: t => Math.sqrt(1 - (t -= 1) * t),\r\n        easeInOutCirc: t => ((t /= 0.5) < 1)\r\n            ? -0.5 * (Math.sqrt(1 - t * t) - 1)\r\n            : 0.5 * (Math.sqrt(1 - (t -= 2) * t) + 1),\r\n        easeInElastic: t => atEdge(t) ? t : elasticIn(t, 0.075, 0.3),\r\n        easeOutElastic: t => atEdge(t) ? t : elasticOut(t, 0.075, 0.3),\r\n        easeInOutElastic(t) {\r\n            const s = 0.1125;\r\n            const p = 0.45;\r\n            return atEdge(t) ? t :\r\n                t < 0.5\r\n                    ? 0.5 * elasticIn(t * 2, s, p)\r\n                    : 0.5 + 0.5 * elasticOut(t * 2 - 1, s, p);\r\n        },\r\n        easeInBack(t) {\r\n            const s = 1.70158;\r\n            return t * t * ((s + 1) * t - s);\r\n        },\r\n        easeOutBack(t) {\r\n            const s = 1.70158;\r\n            return (t -= 1) * t * ((s + 1) * t + s) + 1;\r\n        },\r\n        easeInOutBack(t) {\r\n            let s = 1.70158;\r\n            if ((t /= 0.5) < 1) {\r\n                return 0.5 * (t * t * (((s *= (1.525)) + 1) * t - s));\r\n            }\r\n            return 0.5 * ((t -= 2) * t * (((s *= (1.525)) + 1) * t + s) + 2);\r\n        },\r\n        easeInBounce: t => 1 - effects.easeOutBounce(1 - t),\r\n        easeOutBounce(t) {\r\n            const m = 7.5625;\r\n            const d = 2.75;\r\n            if (t < (1 / d)) {\r\n                return m * t * t;\r\n            }\r\n            if (t < (2 / d)) {\r\n                return m * (t -= (1.5 / d)) * t + 0.75;\r\n            }\r\n            if (t < (2.5 / d)) {\r\n                return m * (t -= (2.25 / d)) * t + 0.9375;\r\n            }\r\n            return m * (t -= (2.625 / d)) * t + 0.984375;\r\n        },\r\n        easeInOutBounce: t => (t < 0.5)\r\n            ? effects.easeInBounce(t * 2) * 0.5\r\n            : effects.easeOutBounce(t * 2 - 1) * 0.5 + 0.5,\r\n    };\r\n\r\n    const transparent = 'transparent';\r\n    const interpolators = {\r\n        boolean(from, to, factor) {\r\n            return factor > 0.5 ? to : from;\r\n        },\r\n        color(from, to, factor) {\r\n            const c0 = color(from || transparent);\r\n            const c1 = c0.valid && color(to || transparent);\r\n            return c1 && c1.valid\r\n                ? c1.mix(c0, factor).hexString()\r\n                : to;\r\n        },\r\n        number(from, to, factor) {\r\n            return from + (to - from) * factor;\r\n        }\r\n    };\r\n\r\n    class Animation {\r\n        constructor(cfg, target, prop, to) {\r\n            const currentValue = target[prop];\r\n            to = resolve([cfg.to, to, currentValue, cfg.from]);\r\n            const from = resolve([cfg.from, currentValue, to]);\r\n            this._active = true;\r\n            this._fn = cfg.fn || interpolators[cfg.type || typeof from];\r\n            this._easing = effects[cfg.easing] || effects.linear;\r\n            this._start = Math.floor(Date.now() + (cfg.delay || 0));\r\n            this._duration = this._total = Math.floor(cfg.duration);\r\n            this._loop = !!cfg.loop;\r\n            this._target = target;\r\n            this._prop = prop;\r\n            this._from = from;\r\n            this._to = to;\r\n            this._promises = undefined;\r\n        }\r\n\r\n        active() {\r\n            return this._active;\r\n        }\r\n\r\n        update(cfg, to, date) {\r\n            const me = this;\r\n            if (me._active) {\r\n                me._notify(false);\r\n                const currentValue = me._target[me._prop];\r\n                const elapsed = date - me._start;\r\n                const remain = me._duration - elapsed;\r\n                me._start = date;\r\n                me._duration = Math.floor(Math.max(remain, cfg.duration));\r\n                me._total += elapsed;\r\n                me._loop = !!cfg.loop;\r\n                me._to = resolve([cfg.to, to, currentValue, cfg.from]);\r\n                me._from = resolve([cfg.from, currentValue, to]);\r\n            }\r\n        }\r\n\r\n        cancel() {\r\n            const me = this;\r\n            if (me._active) {\r\n                me.tick(Date.now());\r\n                me._active = false;\r\n                me._notify(false);\r\n            }\r\n        }\r\n\r\n        tick(date) {\r\n            const me = this;\r\n            const elapsed = date - me._start;\r\n            const duration = me._duration;\r\n            const prop = me._prop;\r\n            const from = me._from;\r\n            const loop = me._loop;\r\n            const to = me._to;\r\n            let factor;\r\n            me._active = from !== to && (loop || (elapsed < duration));\r\n            if (!me._active) {\r\n                me._target[prop] = to;\r\n                me._notify(true);\r\n                return;\r\n            }\r\n            if (elapsed < 0) {\r\n                me._target[prop] = from;\r\n                return;\r\n            }\r\n            factor = (elapsed / duration) % 2;\r\n            factor = loop && factor > 1 ? 2 - factor : factor;\r\n            factor = me._easing(Math.min(1, Math.max(0, factor)));\r\n            me._target[prop] = me._fn(from, to, factor);\r\n        }\r\n\r\n        wait() {\r\n            const promises = this._promises || (this._promises = []);\r\n            return new Promise((res, rej) => {\r\n                promises.push({res, rej});\r\n            });\r\n        }\r\n\r\n        _notify(resolved) {\r\n            const method = resolved ? 'res' : 'rej';\r\n            const promises = this._promises || [];\r\n            for (let i = 0; i < promises.length; i++) {\r\n                promises[i][method]();\r\n            }\r\n        }\r\n    }\r\n\r\n    const numbers = ['x', 'y', 'borderWidth', 'radius', 'tension'];\r\n    const colors = ['color', 'borderColor', 'backgroundColor'];\r\n    defaults.set('animation', {\r\n        delay: undefined,\r\n        duration: 1000,\r\n        easing: 'easeOutQuart',\r\n        fn: undefined,\r\n        from: undefined,\r\n        loop: undefined,\r\n        to: undefined,\r\n        type: undefined,\r\n    });\r\n    const animationOptions = Object.keys(defaults.animation);\r\n    defaults.describe('animation', {\r\n        _fallback: false,\r\n        _indexable: false,\r\n        _scriptable: (name) => name !== 'onProgress' && name !== 'onComplete' && name !== 'fn',\r\n    });\r\n    defaults.set('animations', {\r\n        colors: {\r\n            type: 'color',\r\n            properties: colors\r\n        },\r\n        numbers: {\r\n            type: 'number',\r\n            properties: numbers\r\n        },\r\n    });\r\n    defaults.describe('animations', {\r\n        _fallback: 'animation',\r\n    });\r\n    defaults.set('transitions', {\r\n        active: {\r\n            animation: {\r\n                duration: 400\r\n            }\r\n        },\r\n        resize: {\r\n            animation: {\r\n                duration: 0\r\n            }\r\n        },\r\n        show: {\r\n            animations: {\r\n                colors: {\r\n                    from: 'transparent'\r\n                },\r\n                visible: {\r\n                    type: 'boolean',\r\n                    duration: 0\r\n                },\r\n            }\r\n        },\r\n        hide: {\r\n            animations: {\r\n                colors: {\r\n                    to: 'transparent'\r\n                },\r\n                visible: {\r\n                    type: 'boolean',\r\n                    easing: 'linear',\r\n                    fn: v => v | 0\r\n                },\r\n            }\r\n        }\r\n    });\r\n\r\n    class Animations {\r\n        constructor(chart, config) {\r\n            this._chart = chart;\r\n            this._properties = new Map();\r\n            this.configure(config);\r\n        }\r\n\r\n        configure(config) {\r\n            if (!isObject(config)) {\r\n                return;\r\n            }\r\n            const animatedProps = this._properties;\r\n            Object.getOwnPropertyNames(config).forEach(key => {\r\n                const cfg = config[key];\r\n                if (!isObject(cfg)) {\r\n                    return;\r\n                }\r\n                const resolved = {};\r\n                for (const option of animationOptions) {\r\n                    resolved[option] = cfg[option];\r\n                }\r\n                (isArray(cfg.properties) && cfg.properties || [key]).forEach((prop) => {\r\n                    if (prop === key || !animatedProps.has(prop)) {\r\n                        animatedProps.set(prop, resolved);\r\n                    }\r\n                });\r\n            });\r\n        }\r\n\r\n        _animateOptions(target, values) {\r\n            const newOptions = values.options;\r\n            const options = resolveTargetOptions(target, newOptions);\r\n            if (!options) {\r\n                return [];\r\n            }\r\n            const animations = this._createAnimations(options, newOptions);\r\n            if (newOptions.$shared) {\r\n                awaitAll(target.options.$animations, newOptions).then(() => {\r\n                    target.options = newOptions;\r\n                }, () => {\r\n                });\r\n            }\r\n            return animations;\r\n        }\r\n\r\n        _createAnimations(target, values) {\r\n            const animatedProps = this._properties;\r\n            const animations = [];\r\n            const running = target.$animations || (target.$animations = {});\r\n            const props = Object.keys(values);\r\n            const date = Date.now();\r\n            let i;\r\n            for (i = props.length - 1; i >= 0; --i) {\r\n                const prop = props[i];\r\n                if (prop.charAt(0) === '$') {\r\n                    continue;\r\n                }\r\n                if (prop === 'options') {\r\n                    animations.push(...this._animateOptions(target, values));\r\n                    continue;\r\n                }\r\n                const value = values[prop];\r\n                let animation = running[prop];\r\n                const cfg = animatedProps.get(prop);\r\n                if (animation) {\r\n                    if (cfg && animation.active()) {\r\n                        animation.update(cfg, value, date);\r\n                        continue;\r\n                    } else {\r\n                        animation.cancel();\r\n                    }\r\n                }\r\n                if (!cfg || !cfg.duration) {\r\n                    target[prop] = value;\r\n                    continue;\r\n                }\r\n                running[prop] = animation = new Animation(cfg, target, prop, value);\r\n                animations.push(animation);\r\n            }\r\n            return animations;\r\n        }\r\n\r\n        update(target, values) {\r\n            if (this._properties.size === 0) {\r\n                Object.assign(target, values);\r\n                return;\r\n            }\r\n            const animations = this._createAnimations(target, values);\r\n            if (animations.length) {\r\n                animator.add(this._chart, animations);\r\n                return true;\r\n            }\r\n        }\r\n    }\r\n\r\n    function awaitAll(animations, properties) {\r\n        const running = [];\r\n        const keys = Object.keys(properties);\r\n        for (let i = 0; i < keys.length; i++) {\r\n            const anim = animations[keys[i]];\r\n            if (anim && anim.active()) {\r\n                running.push(anim.wait());\r\n            }\r\n        }\r\n        return Promise.all(running);\r\n    }\r\n\r\n    function resolveTargetOptions(target, newOptions) {\r\n        if (!newOptions) {\r\n            return;\r\n        }\r\n        let options = target.options;\r\n        if (!options) {\r\n            target.options = newOptions;\r\n            return;\r\n        }\r\n        if (options.$shared) {\r\n            target.options = options = Object.assign({}, options, {$shared: false, $animations: {}});\r\n        }\r\n        return options;\r\n    }\r\n\r\n    function scaleClip(scale, allowedOverflow) {\r\n        const opts = scale && scale.options || {};\r\n        const reverse = opts.reverse;\r\n        const min = opts.min === undefined ? allowedOverflow : 0;\r\n        const max = opts.max === undefined ? allowedOverflow : 0;\r\n        return {\r\n            start: reverse ? max : min,\r\n            end: reverse ? min : max\r\n        };\r\n    }\r\n\r\n    function defaultClip(xScale, yScale, allowedOverflow) {\r\n        if (allowedOverflow === false) {\r\n            return false;\r\n        }\r\n        const x = scaleClip(xScale, allowedOverflow);\r\n        const y = scaleClip(yScale, allowedOverflow);\r\n        return {\r\n            top: y.end,\r\n            right: x.end,\r\n            bottom: y.start,\r\n            left: x.start\r\n        };\r\n    }\r\n\r\n    function toClip(value) {\r\n        let t, r, b, l;\r\n        if (isObject(value)) {\r\n            t = value.top;\r\n            r = value.right;\r\n            b = value.bottom;\r\n            l = value.left;\r\n        } else {\r\n            t = r = b = l = value;\r\n        }\r\n        return {\r\n            top: t,\r\n            right: r,\r\n            bottom: b,\r\n            left: l\r\n        };\r\n    }\r\n\r\n    function getSortedDatasetIndices(chart, filterVisible) {\r\n        const keys = [];\r\n        const metasets = chart._getSortedDatasetMetas(filterVisible);\r\n        let i, ilen;\r\n        for (i = 0, ilen = metasets.length; i < ilen; ++i) {\r\n            keys.push(metasets[i].index);\r\n        }\r\n        return keys;\r\n    }\r\n\r\n    function applyStack(stack, value, dsIndex, options) {\r\n        const keys = stack.keys;\r\n        const singleMode = options.mode === 'single';\r\n        let i, ilen, datasetIndex, otherValue;\r\n        if (value === null) {\r\n            return;\r\n        }\r\n        for (i = 0, ilen = keys.length; i < ilen; ++i) {\r\n            datasetIndex = +keys[i];\r\n            if (datasetIndex === dsIndex) {\r\n                if (options.all) {\r\n                    continue;\r\n                }\r\n                break;\r\n            }\r\n            otherValue = stack.values[datasetIndex];\r\n            if (isNumberFinite(otherValue) && (singleMode || (value === 0 || sign(value) === sign(otherValue)))) {\r\n                value += otherValue;\r\n            }\r\n        }\r\n        return value;\r\n    }\r\n\r\n    function convertObjectDataToArray(data) {\r\n        const keys = Object.keys(data);\r\n        const adata = new Array(keys.length);\r\n        let i, ilen, key;\r\n        for (i = 0, ilen = keys.length; i < ilen; ++i) {\r\n            key = keys[i];\r\n            adata[i] = {\r\n                x: key,\r\n                y: data[key]\r\n            };\r\n        }\r\n        return adata;\r\n    }\r\n\r\n    function isStacked(scale, meta) {\r\n        const stacked = scale && scale.options.stacked;\r\n        return stacked || (stacked === undefined && meta.stack !== undefined);\r\n    }\r\n\r\n    function getStackKey(indexScale, valueScale, meta) {\r\n        return indexScale.id + '.' + valueScale.id + '.' + meta.stack + '.' + meta.type;\r\n    }\r\n\r\n    function getUserBounds(scale) {\r\n        const {min, max, minDefined, maxDefined} = scale.getUserBounds();\r\n        return {\r\n            min: minDefined ? min : Number.NEGATIVE_INFINITY,\r\n            max: maxDefined ? max : Number.POSITIVE_INFINITY\r\n        };\r\n    }\r\n\r\n    function getOrCreateStack(stacks, stackKey, indexValue) {\r\n        const subStack = stacks[stackKey] || (stacks[stackKey] = {});\r\n        return subStack[indexValue] || (subStack[indexValue] = {});\r\n    }\r\n\r\n    function updateStacks(controller, parsed) {\r\n        const {chart, _cachedMeta: meta} = controller;\r\n        const stacks = chart._stacks || (chart._stacks = {});\r\n        const {iScale, vScale, index: datasetIndex} = meta;\r\n        const iAxis = iScale.axis;\r\n        const vAxis = vScale.axis;\r\n        const key = getStackKey(iScale, vScale, meta);\r\n        const ilen = parsed.length;\r\n        let stack;\r\n        for (let i = 0; i < ilen; ++i) {\r\n            const item = parsed[i];\r\n            const {[iAxis]: index, [vAxis]: value} = item;\r\n            const itemStacks = item._stacks || (item._stacks = {});\r\n            stack = itemStacks[vAxis] = getOrCreateStack(stacks, key, index);\r\n            stack[datasetIndex] = value;\r\n        }\r\n    }\r\n\r\n    function getFirstScaleId(chart, axis) {\r\n        const scales = chart.scales;\r\n        return Object.keys(scales).filter(key => scales[key].axis === axis).shift();\r\n    }\r\n\r\n    function createDatasetContext(parent, index) {\r\n        return Object.assign(Object.create(parent),\r\n            {\r\n                active: false,\r\n                dataset: undefined,\r\n                datasetIndex: index,\r\n                index,\r\n                mode: 'default',\r\n                type: 'dataset'\r\n            }\r\n        );\r\n    }\r\n\r\n    function createDataContext(parent, index, element) {\r\n        return Object.assign(Object.create(parent), {\r\n            active: false,\r\n            dataIndex: index,\r\n            parsed: undefined,\r\n            raw: undefined,\r\n            element,\r\n            index,\r\n            mode: 'default',\r\n            type: 'data'\r\n        });\r\n    }\r\n\r\n    function clearStacks(meta, items) {\r\n        items = items || meta._parsed;\r\n        for (const parsed of items) {\r\n            const stacks = parsed._stacks;\r\n            if (!stacks || stacks[meta.vScale.id] === undefined || stacks[meta.vScale.id][meta.index] === undefined) {\r\n                return;\r\n            }\r\n            delete stacks[meta.vScale.id][meta.index];\r\n        }\r\n    }\r\n\r\n    const isDirectUpdateMode = (mode) => mode === 'reset' || mode === 'none';\r\n    const cloneIfNotShared = (cached, shared) => shared ? cached : Object.assign({}, cached);\r\n\r\n    class DatasetController {\r\n        constructor(chart, datasetIndex) {\r\n            this.chart = chart;\r\n            this._ctx = chart.ctx;\r\n            this.index = datasetIndex;\r\n            this._cachedDataOpts = {};\r\n            this._cachedMeta = this.getMeta();\r\n            this._type = this._cachedMeta.type;\r\n            this.options = undefined;\r\n            this._parsing = false;\r\n            this._data = undefined;\r\n            this._objectData = undefined;\r\n            this._sharedOptions = undefined;\r\n            this._drawStart = undefined;\r\n            this._drawCount = undefined;\r\n            this.enableOptionSharing = false;\r\n            this.$context = undefined;\r\n            this.initialize();\r\n        }\r\n\r\n        initialize() {\r\n            const me = this;\r\n            const meta = me._cachedMeta;\r\n            me.configure();\r\n            me.linkScales();\r\n            meta._stacked = isStacked(meta.vScale, meta);\r\n            me.addElements();\r\n        }\r\n\r\n        updateIndex(datasetIndex) {\r\n            this.index = datasetIndex;\r\n        }\r\n\r\n        linkScales() {\r\n            const me = this;\r\n            const chart = me.chart;\r\n            const meta = me._cachedMeta;\r\n            const dataset = me.getDataset();\r\n            const chooseId = (axis, x, y, r) => axis === 'x' ? x : axis === 'r' ? r : y;\r\n            const xid = meta.xAxisID = valueOrDefault(dataset.xAxisID, getFirstScaleId(chart, 'x'));\r\n            const yid = meta.yAxisID = valueOrDefault(dataset.yAxisID, getFirstScaleId(chart, 'y'));\r\n            const rid = meta.rAxisID = valueOrDefault(dataset.rAxisID, getFirstScaleId(chart, 'r'));\r\n            const indexAxis = meta.indexAxis;\r\n            const iid = meta.iAxisID = chooseId(indexAxis, xid, yid, rid);\r\n            const vid = meta.vAxisID = chooseId(indexAxis, yid, xid, rid);\r\n            meta.xScale = me.getScaleForId(xid);\r\n            meta.yScale = me.getScaleForId(yid);\r\n            meta.rScale = me.getScaleForId(rid);\r\n            meta.iScale = me.getScaleForId(iid);\r\n            meta.vScale = me.getScaleForId(vid);\r\n        }\r\n\r\n        getDataset() {\r\n            return this.chart.data.datasets[this.index];\r\n        }\r\n\r\n        getMeta() {\r\n            return this.chart.getDatasetMeta(this.index);\r\n        }\r\n\r\n        getScaleForId(scaleID) {\r\n            return this.chart.scales[scaleID];\r\n        }\r\n\r\n        _getOtherScale(scale) {\r\n            const meta = this._cachedMeta;\r\n            return scale === meta.iScale\r\n                ? meta.vScale\r\n                : meta.iScale;\r\n        }\r\n\r\n        reset() {\r\n            this._update('reset');\r\n        }\r\n\r\n        _destroy() {\r\n            const meta = this._cachedMeta;\r\n            if (this._data) {\r\n                unlistenArrayEvents(this._data, this);\r\n            }\r\n            if (meta._stacked) {\r\n                clearStacks(meta);\r\n            }\r\n        }\r\n\r\n        _dataCheck() {\r\n            const me = this;\r\n            const dataset = me.getDataset();\r\n            const data = dataset.data || (dataset.data = []);\r\n            if (isObject(data)) {\r\n                me._data = convertObjectDataToArray(data);\r\n            } else if (me._data !== data) {\r\n                if (me._data) {\r\n                    unlistenArrayEvents(me._data, me);\r\n                    clearStacks(me._cachedMeta);\r\n                }\r\n                if (data && Object.isExtensible(data)) {\r\n                    listenArrayEvents(data, me);\r\n                }\r\n                me._data = data;\r\n            }\r\n        }\r\n\r\n        addElements() {\r\n            const me = this;\r\n            const meta = me._cachedMeta;\r\n            me._dataCheck();\r\n            if (me.datasetElementType) {\r\n                meta.dataset = new me.datasetElementType();\r\n            }\r\n        }\r\n\r\n        buildOrUpdateElements(resetNewElements) {\r\n            const me = this;\r\n            const meta = me._cachedMeta;\r\n            const dataset = me.getDataset();\r\n            let stackChanged = false;\r\n            me._dataCheck();\r\n            meta._stacked = isStacked(meta.vScale, meta);\r\n            if (meta.stack !== dataset.stack) {\r\n                stackChanged = true;\r\n                clearStacks(meta);\r\n                meta.stack = dataset.stack;\r\n            }\r\n            me._resyncElements(resetNewElements);\r\n            if (stackChanged) {\r\n                updateStacks(me, meta._parsed);\r\n            }\r\n        }\r\n\r\n        configure() {\r\n            const me = this;\r\n            const config = me.chart.config;\r\n            const scopeKeys = config.datasetScopeKeys(me._type);\r\n            const scopes = config.getOptionScopes(me.getDataset(), scopeKeys, true);\r\n            me.options = config.createResolver(scopes, me.getContext());\r\n            me._parsing = me.options.parsing;\r\n        }\r\n\r\n        parse(start, count) {\r\n            const me = this;\r\n            const {_cachedMeta: meta, _data: data} = me;\r\n            const {iScale, _stacked} = meta;\r\n            const iAxis = iScale.axis;\r\n            let sorted = start === 0 && count === data.length ? true : meta._sorted;\r\n            let prev = start > 0 && meta._parsed[start - 1];\r\n            let i, cur, parsed;\r\n            if (me._parsing === false) {\r\n                meta._parsed = data;\r\n                meta._sorted = true;\r\n            } else {\r\n                if (isArray(data[start])) {\r\n                    parsed = me.parseArrayData(meta, data, start, count);\r\n                } else if (isObject(data[start])) {\r\n                    parsed = me.parseObjectData(meta, data, start, count);\r\n                } else {\r\n                    parsed = me.parsePrimitiveData(meta, data, start, count);\r\n                }\r\n                const isNotInOrderComparedToPrev = () => cur[iAxis] === null || (prev && cur[iAxis] < prev[iAxis]);\r\n                for (i = 0; i < count; ++i) {\r\n                    meta._parsed[i + start] = cur = parsed[i];\r\n                    if (sorted) {\r\n                        if (isNotInOrderComparedToPrev()) {\r\n                            sorted = false;\r\n                        }\r\n                        prev = cur;\r\n                    }\r\n                }\r\n                meta._sorted = sorted;\r\n            }\r\n            if (_stacked) {\r\n                updateStacks(me, parsed);\r\n            }\r\n        }\r\n\r\n        parsePrimitiveData(meta, data, start, count) {\r\n            const {iScale, vScale} = meta;\r\n            const iAxis = iScale.axis;\r\n            const vAxis = vScale.axis;\r\n            const labels = iScale.getLabels();\r\n            const singleScale = iScale === vScale;\r\n            const parsed = new Array(count);\r\n            let i, ilen, index;\r\n            for (i = 0, ilen = count; i < ilen; ++i) {\r\n                index = i + start;\r\n                parsed[i] = {\r\n                    [iAxis]: singleScale || iScale.parse(labels[index], index),\r\n                    [vAxis]: vScale.parse(data[index], index)\r\n                };\r\n            }\r\n            return parsed;\r\n        }\r\n\r\n        parseArrayData(meta, data, start, count) {\r\n            const {xScale, yScale} = meta;\r\n            const parsed = new Array(count);\r\n            let i, ilen, index, item;\r\n            for (i = 0, ilen = count; i < ilen; ++i) {\r\n                index = i + start;\r\n                item = data[index];\r\n                parsed[i] = {\r\n                    x: xScale.parse(item[0], index),\r\n                    y: yScale.parse(item[1], index)\r\n                };\r\n            }\r\n            return parsed;\r\n        }\r\n\r\n        parseObjectData(meta, data, start, count) {\r\n            const {xScale, yScale} = meta;\r\n            const {xAxisKey = 'x', yAxisKey = 'y'} = this._parsing;\r\n            const parsed = new Array(count);\r\n            let i, ilen, index, item;\r\n            for (i = 0, ilen = count; i < ilen; ++i) {\r\n                index = i + start;\r\n                item = data[index];\r\n                parsed[i] = {\r\n                    x: xScale.parse(resolveObjectKey(item, xAxisKey), index),\r\n                    y: yScale.parse(resolveObjectKey(item, yAxisKey), index)\r\n                };\r\n            }\r\n            return parsed;\r\n        }\r\n\r\n        getParsed(index) {\r\n            return this._cachedMeta._parsed[index];\r\n        }\r\n\r\n        getDataElement(index) {\r\n            return this._cachedMeta.data[index];\r\n        }\r\n\r\n        applyStack(scale, parsed, mode) {\r\n            const chart = this.chart;\r\n            const meta = this._cachedMeta;\r\n            const value = parsed[scale.axis];\r\n            const stack = {\r\n                keys: getSortedDatasetIndices(chart, true),\r\n                values: parsed._stacks[scale.axis]\r\n            };\r\n            return applyStack(stack, value, meta.index, {mode});\r\n        }\r\n\r\n        updateRangeFromParsed(range, scale, parsed, stack) {\r\n            const parsedValue = parsed[scale.axis];\r\n            let value = parsedValue === null ? NaN : parsedValue;\r\n            const values = stack && parsed._stacks[scale.axis];\r\n            if (stack && values) {\r\n                stack.values = values;\r\n                range.min = Math.min(range.min, value);\r\n                range.max = Math.max(range.max, value);\r\n                value = applyStack(stack, parsedValue, this._cachedMeta.index, {all: true});\r\n            }\r\n            range.min = Math.min(range.min, value);\r\n            range.max = Math.max(range.max, value);\r\n        }\r\n\r\n        getMinMax(scale, canStack) {\r\n            const me = this;\r\n            const meta = me._cachedMeta;\r\n            const _parsed = meta._parsed;\r\n            const sorted = meta._sorted && scale === meta.iScale;\r\n            const ilen = _parsed.length;\r\n            const otherScale = me._getOtherScale(scale);\r\n            const stack = canStack && meta._stacked && {keys: getSortedDatasetIndices(me.chart, true), values: null};\r\n            const range = {min: Number.POSITIVE_INFINITY, max: Number.NEGATIVE_INFINITY};\r\n            const {min: otherMin, max: otherMax} = getUserBounds(otherScale);\r\n            let i, value, parsed, otherValue;\r\n\r\n            function _skip() {\r\n                parsed = _parsed[i];\r\n                value = parsed[scale.axis];\r\n                otherValue = parsed[otherScale.axis];\r\n                return !isNumberFinite(value) || otherMin > otherValue || otherMax < otherValue;\r\n            }\r\n\r\n            for (i = 0; i < ilen; ++i) {\r\n                if (_skip()) {\r\n                    continue;\r\n                }\r\n                me.updateRangeFromParsed(range, scale, parsed, stack);\r\n                if (sorted) {\r\n                    break;\r\n                }\r\n            }\r\n            if (sorted) {\r\n                for (i = ilen - 1; i >= 0; --i) {\r\n                    if (_skip()) {\r\n                        continue;\r\n                    }\r\n                    me.updateRangeFromParsed(range, scale, parsed, stack);\r\n                    break;\r\n                }\r\n            }\r\n            return range;\r\n        }\r\n\r\n        getAllParsedValues(scale) {\r\n            const parsed = this._cachedMeta._parsed;\r\n            const values = [];\r\n            let i, ilen, value;\r\n            for (i = 0, ilen = parsed.length; i < ilen; ++i) {\r\n                value = parsed[i][scale.axis];\r\n                if (isNumberFinite(value)) {\r\n                    values.push(value);\r\n                }\r\n            }\r\n            return values;\r\n        }\r\n\r\n        getMaxOverflow() {\r\n            return false;\r\n        }\r\n\r\n        getLabelAndValue(index) {\r\n            const me = this;\r\n            const meta = me._cachedMeta;\r\n            const iScale = meta.iScale;\r\n            const vScale = meta.vScale;\r\n            const parsed = me.getParsed(index);\r\n            return {\r\n                label: iScale ? '' + iScale.getLabelForValue(parsed[iScale.axis]) : '',\r\n                value: vScale ? '' + vScale.getLabelForValue(parsed[vScale.axis]) : ''\r\n            };\r\n        }\r\n\r\n        _update(mode) {\r\n            const me = this;\r\n            const meta = me._cachedMeta;\r\n            me.configure();\r\n            me._cachedDataOpts = {};\r\n            me.update(mode || 'default');\r\n            meta._clip = toClip(valueOrDefault(me.options.clip, defaultClip(meta.xScale, meta.yScale, me.getMaxOverflow())));\r\n        }\r\n\r\n        update(mode) {\r\n        }\r\n\r\n        draw() {\r\n            const me = this;\r\n            const ctx = me._ctx;\r\n            const chart = me.chart;\r\n            const meta = me._cachedMeta;\r\n            const elements = meta.data || [];\r\n            const area = chart.chartArea;\r\n            const active = [];\r\n            const start = me._drawStart || 0;\r\n            const count = me._drawCount || (elements.length - start);\r\n            let i;\r\n            if (meta.dataset) {\r\n                meta.dataset.draw(ctx, area, start, count);\r\n            }\r\n            for (i = start; i < start + count; ++i) {\r\n                const element = elements[i];\r\n                if (element.active) {\r\n                    active.push(element);\r\n                } else {\r\n                    element.draw(ctx, area);\r\n                }\r\n            }\r\n            for (i = 0; i < active.length; ++i) {\r\n                active[i].draw(ctx, area);\r\n            }\r\n        }\r\n\r\n        getStyle(index, active) {\r\n            const mode = active ? 'active' : 'default';\r\n            return index === undefined && this._cachedMeta.dataset\r\n                ? this.resolveDatasetElementOptions(mode)\r\n                : this.resolveDataElementOptions(index || 0, mode);\r\n        }\r\n\r\n        getContext(index, active, mode) {\r\n            const me = this;\r\n            const dataset = me.getDataset();\r\n            let context;\r\n            if (index >= 0 && index < me._cachedMeta.data.length) {\r\n                const element = me._cachedMeta.data[index];\r\n                context = element.$context ||\r\n                    (element.$context = createDataContext(me.getContext(), index, element));\r\n                context.parsed = me.getParsed(index);\r\n                context.raw = dataset.data[index];\r\n            } else {\r\n                context = me.$context ||\r\n                    (me.$context = createDatasetContext(me.chart.getContext(), me.index));\r\n                context.dataset = dataset;\r\n            }\r\n            context.active = !!active;\r\n            context.mode = mode;\r\n            return context;\r\n        }\r\n\r\n        resolveDatasetElementOptions(mode) {\r\n            return this._resolveElementOptions(this.datasetElementType.id, mode);\r\n        }\r\n\r\n        resolveDataElementOptions(index, mode) {\r\n            return this._resolveElementOptions(this.dataElementType.id, mode, index);\r\n        }\r\n\r\n        _resolveElementOptions(elementType, mode = 'default', index) {\r\n            const me = this;\r\n            const active = mode === 'active';\r\n            const cache = me._cachedDataOpts;\r\n            const cacheKey = elementType + '-' + mode;\r\n            const cached = cache[cacheKey];\r\n            const sharing = me.enableOptionSharing && defined(index);\r\n            if (cached) {\r\n                return cloneIfNotShared(cached, sharing);\r\n            }\r\n            const config = me.chart.config;\r\n            const scopeKeys = config.datasetElementScopeKeys(me._type, elementType);\r\n            const prefixes = active ? [`${elementType}Hover`, 'hover', elementType, ''] : [elementType, ''];\r\n            const scopes = config.getOptionScopes(me.getDataset(), scopeKeys);\r\n            const names = Object.keys(defaults.elements[elementType]);\r\n            const context = () => me.getContext(index, active);\r\n            const values = config.resolveNamedOptions(scopes, names, context, prefixes);\r\n            if (values.$shared) {\r\n                values.$shared = sharing;\r\n                cache[cacheKey] = Object.freeze(cloneIfNotShared(values, sharing));\r\n            }\r\n            return values;\r\n        }\r\n\r\n        _resolveAnimations(index, transition, active) {\r\n            const me = this;\r\n            const chart = me.chart;\r\n            const cache = me._cachedDataOpts;\r\n            const cacheKey = `animation-${transition}`;\r\n            const cached = cache[cacheKey];\r\n            if (cached) {\r\n                return cached;\r\n            }\r\n            let options;\r\n            if (chart.options.animation !== false) {\r\n                const config = me.chart.config;\r\n                const scopeKeys = config.datasetAnimationScopeKeys(me._type, transition);\r\n                const scopes = config.getOptionScopes(me.getDataset(), scopeKeys);\r\n                options = config.createResolver(scopes, me.getContext(index, active, transition));\r\n            }\r\n            const animations = new Animations(chart, options && options.animations);\r\n            if (options && options._cacheable) {\r\n                cache[cacheKey] = Object.freeze(animations);\r\n            }\r\n            return animations;\r\n        }\r\n\r\n        getSharedOptions(options) {\r\n            if (!options.$shared) {\r\n                return;\r\n            }\r\n            return this._sharedOptions || (this._sharedOptions = Object.assign({}, options));\r\n        }\r\n\r\n        includeOptions(mode, sharedOptions) {\r\n            return !sharedOptions || isDirectUpdateMode(mode) || this.chart._animationsDisabled;\r\n        }\r\n\r\n        updateElement(element, index, properties, mode) {\r\n            if (isDirectUpdateMode(mode)) {\r\n                Object.assign(element, properties);\r\n            } else {\r\n                this._resolveAnimations(index, mode).update(element, properties);\r\n            }\r\n        }\r\n\r\n        updateSharedOptions(sharedOptions, mode, newOptions) {\r\n            if (sharedOptions && !isDirectUpdateMode(mode)) {\r\n                this._resolveAnimations(undefined, mode).update(sharedOptions, newOptions);\r\n            }\r\n        }\r\n\r\n        _setStyle(element, index, mode, active) {\r\n            element.active = active;\r\n            const options = this.getStyle(index, active);\r\n            this._resolveAnimations(index, mode, active).update(element, {\r\n                options: (!active && this.getSharedOptions(options)) || options\r\n            });\r\n        }\r\n\r\n        removeHoverStyle(element, datasetIndex, index) {\r\n            this._setStyle(element, index, 'active', false);\r\n        }\r\n\r\n        setHoverStyle(element, datasetIndex, index) {\r\n            this._setStyle(element, index, 'active', true);\r\n        }\r\n\r\n        _removeDatasetHoverStyle() {\r\n            const element = this._cachedMeta.dataset;\r\n            if (element) {\r\n                this._setStyle(element, undefined, 'active', false);\r\n            }\r\n        }\r\n\r\n        _setDatasetHoverStyle() {\r\n            const element = this._cachedMeta.dataset;\r\n            if (element) {\r\n                this._setStyle(element, undefined, 'active', true);\r\n            }\r\n        }\r\n\r\n        _resyncElements(resetNewElements) {\r\n            const me = this;\r\n            const numMeta = me._cachedMeta.data.length;\r\n            const numData = me._data.length;\r\n            if (numData > numMeta) {\r\n                me._insertElements(numMeta, numData - numMeta, resetNewElements);\r\n            } else if (numData < numMeta) {\r\n                me._removeElements(numData, numMeta - numData);\r\n            }\r\n            const count = Math.min(numData, numMeta);\r\n            if (count) {\r\n                me.parse(0, count);\r\n            }\r\n        }\r\n\r\n        _insertElements(start, count, resetNewElements = true) {\r\n            const me = this;\r\n            const meta = me._cachedMeta;\r\n            const data = meta.data;\r\n            const end = start + count;\r\n            let i;\r\n            const move = (arr) => {\r\n                arr.length += count;\r\n                for (i = arr.length - 1; i >= end; i--) {\r\n                    arr[i] = arr[i - count];\r\n                }\r\n            };\r\n            move(data);\r\n            for (i = start; i < end; ++i) {\r\n                data[i] = new me.dataElementType();\r\n            }\r\n            if (me._parsing) {\r\n                move(meta._parsed);\r\n            }\r\n            me.parse(start, count);\r\n            if (resetNewElements) {\r\n                me.updateElements(data, start, count, 'reset');\r\n            }\r\n        }\r\n\r\n        updateElements(element, start, count, mode) {\r\n        }\r\n\r\n        _removeElements(start, count) {\r\n            const me = this;\r\n            const meta = me._cachedMeta;\r\n            if (me._parsing) {\r\n                const removed = meta._parsed.splice(start, count);\r\n                if (meta._stacked) {\r\n                    clearStacks(meta, removed);\r\n                }\r\n            }\r\n            meta.data.splice(start, count);\r\n        }\r\n\r\n        _onDataPush() {\r\n            const count = arguments.length;\r\n            this._insertElements(this.getDataset().data.length - count, count);\r\n        }\r\n\r\n        _onDataPop() {\r\n            this._removeElements(this._cachedMeta.data.length - 1, 1);\r\n        }\r\n\r\n        _onDataShift() {\r\n            this._removeElements(0, 1);\r\n        }\r\n\r\n        _onDataSplice(start, count) {\r\n            this._removeElements(start, count);\r\n            this._insertElements(start, arguments.length - 2);\r\n        }\r\n\r\n        _onDataUnshift() {\r\n            this._insertElements(0, arguments.length);\r\n        }\r\n    }\r\n\r\n    DatasetController.defaults = {};\r\n    DatasetController.prototype.datasetElementType = null;\r\n    DatasetController.prototype.dataElementType = null;\r\n\r\n    class Element {\r\n        constructor() {\r\n            this.x = undefined;\r\n            this.y = undefined;\r\n            this.active = false;\r\n            this.options = undefined;\r\n            this.$animations = undefined;\r\n        }\r\n\r\n        tooltipPosition(useFinalPosition) {\r\n            const {x, y} = this.getProps(['x', 'y'], useFinalPosition);\r\n            return {x, y};\r\n        }\r\n\r\n        hasValue() {\r\n            return isNumber(this.x) && isNumber(this.y);\r\n        }\r\n\r\n        getProps(props, final) {\r\n            const me = this;\r\n            const anims = this.$animations;\r\n            if (!final || !anims) {\r\n                return me;\r\n            }\r\n            const ret = {};\r\n            props.forEach(prop => {\r\n                ret[prop] = anims[prop] && anims[prop].active() ? anims[prop]._to : me[prop];\r\n            });\r\n            return ret;\r\n        }\r\n    }\r\n\r\n    Element.defaults = {};\r\n    Element.defaultRoutes = undefined;\r\n\r\n    const intlCache = new Map();\r\n\r\n    function getNumberFormat(locale, options) {\r\n        options = options || {};\r\n        const cacheKey = locale + JSON.stringify(options);\r\n        let formatter = intlCache.get(cacheKey);\r\n        if (!formatter) {\r\n            formatter = new Intl.NumberFormat(locale, options);\r\n            intlCache.set(cacheKey, formatter);\r\n        }\r\n        return formatter;\r\n    }\r\n\r\n    function formatNumber(num, locale, options) {\r\n        return getNumberFormat(locale, options).format(num);\r\n    }\r\n\r\n    const formatters = {\r\n        values(value) {\r\n            return isArray(value) ? value : '' + value;\r\n        },\r\n        numeric(tickValue, index, ticks) {\r\n            if (tickValue === 0) {\r\n                return '0';\r\n            }\r\n            const locale = this.chart.options.locale;\r\n            let notation;\r\n            let delta = tickValue;\r\n            if (ticks.length > 1) {\r\n                const maxTick = Math.max(Math.abs(ticks[0].value), Math.abs(ticks[ticks.length - 1].value));\r\n                if (maxTick < 1e-4 || maxTick > 1e+15) {\r\n                    notation = 'scientific';\r\n                }\r\n                delta = calculateDelta(tickValue, ticks);\r\n            }\r\n            const logDelta = log10(Math.abs(delta));\r\n            const numDecimal = Math.max(Math.min(-1 * Math.floor(logDelta), 20), 0);\r\n            const options = {notation, minimumFractionDigits: numDecimal, maximumFractionDigits: numDecimal};\r\n            Object.assign(options, this.options.ticks.format);\r\n            return formatNumber(tickValue, locale, options);\r\n        },\r\n        logarithmic(tickValue, index, ticks) {\r\n            if (tickValue === 0) {\r\n                return '0';\r\n            }\r\n            const remain = tickValue / (Math.pow(10, Math.floor(log10(tickValue))));\r\n            if (remain === 1 || remain === 2 || remain === 5) {\r\n                return formatters.numeric.call(this, tickValue, index, ticks);\r\n            }\r\n            return '';\r\n        }\r\n    };\r\n\r\n    function calculateDelta(tickValue, ticks) {\r\n        let delta = ticks.length > 3 ? ticks[2].value - ticks[1].value : ticks[1].value - ticks[0].value;\r\n        if (Math.abs(delta) > 1 && tickValue !== Math.floor(tickValue)) {\r\n            delta = tickValue - Math.floor(tickValue);\r\n        }\r\n        return delta;\r\n    }\r\n\r\n    var Ticks = {formatters};\r\n\r\n    defaults.set('scale', {\r\n        display: true,\r\n        offset: false,\r\n        reverse: false,\r\n        beginAtZero: false,\r\n        bounds: 'ticks',\r\n        grace: 0,\r\n        grid: {\r\n            display: true,\r\n            lineWidth: 1,\r\n            drawBorder: true,\r\n            drawOnChartArea: true,\r\n            drawTicks: true,\r\n            tickLength: 8,\r\n            tickWidth: (_ctx, options) => options.lineWidth,\r\n            tickColor: (_ctx, options) => options.color,\r\n            offset: false,\r\n            borderDash: [],\r\n            borderDashOffset: 0.0,\r\n            borderColor: (_ctx, options) => options.color,\r\n            borderWidth: (_ctx, options) => options.lineWidth\r\n        },\r\n        title: {\r\n            display: false,\r\n            text: '',\r\n            padding: {\r\n                top: 4,\r\n                bottom: 4\r\n            }\r\n        },\r\n        ticks: {\r\n            minRotation: 0,\r\n            maxRotation: 50,\r\n            mirror: false,\r\n            textStrokeWidth: 0,\r\n            textStrokeColor: '',\r\n            padding: 3,\r\n            display: true,\r\n            autoSkip: true,\r\n            autoSkipPadding: 3,\r\n            labelOffset: 0,\r\n            callback: Ticks.formatters.values,\r\n            minor: {},\r\n            major: {},\r\n            align: 'center',\r\n            crossAlign: 'near',\r\n        }\r\n    });\r\n    defaults.route('scale.ticks', 'color', '', 'color');\r\n    defaults.route('scale.grid', 'color', '', 'borderColor');\r\n    defaults.route('scale.title', 'color', '', 'color');\r\n    defaults.describe('scale', {\r\n        _fallback: false,\r\n        _scriptable: (name) => !name.startsWith('before') && !name.startsWith('after') && name !== 'callback' && name !== 'parser',\r\n        _indexable: (name) => name !== 'borderDash' && name !== 'tickBorderDash',\r\n    });\r\n    defaults.describe('scales', {\r\n        _fallback: 'scale',\r\n    });\r\n\r\n    function autoSkip(scale, ticks) {\r\n        const tickOpts = scale.options.ticks;\r\n        const ticksLimit = tickOpts.maxTicksLimit || determineMaxTicks(scale);\r\n        const majorIndices = tickOpts.major.enabled ? getMajorIndices(ticks) : [];\r\n        const numMajorIndices = majorIndices.length;\r\n        const first = majorIndices[0];\r\n        const last = majorIndices[numMajorIndices - 1];\r\n        const newTicks = [];\r\n        if (numMajorIndices > ticksLimit) {\r\n            skipMajors(ticks, newTicks, majorIndices, numMajorIndices / ticksLimit);\r\n            return newTicks;\r\n        }\r\n        const spacing = calculateSpacing(majorIndices, ticks, ticksLimit);\r\n        if (numMajorIndices > 0) {\r\n            let i, ilen;\r\n            const avgMajorSpacing = numMajorIndices > 1 ? Math.round((last - first) / (numMajorIndices - 1)) : null;\r\n            skip(ticks, newTicks, spacing, isNullOrUndef(avgMajorSpacing) ? 0 : first - avgMajorSpacing, first);\r\n            for (i = 0, ilen = numMajorIndices - 1; i < ilen; i++) {\r\n                skip(ticks, newTicks, spacing, majorIndices[i], majorIndices[i + 1]);\r\n            }\r\n            skip(ticks, newTicks, spacing, last, isNullOrUndef(avgMajorSpacing) ? ticks.length : last + avgMajorSpacing);\r\n            return newTicks;\r\n        }\r\n        skip(ticks, newTicks, spacing);\r\n        return newTicks;\r\n    }\r\n\r\n    function determineMaxTicks(scale) {\r\n        const offset = scale.options.offset;\r\n        const tickLength = scale._tickSize();\r\n        const maxScale = scale._length / tickLength + (offset ? 0 : 1);\r\n        const maxChart = scale._maxLength / tickLength;\r\n        return Math.floor(Math.min(maxScale, maxChart));\r\n    }\r\n\r\n    function calculateSpacing(majorIndices, ticks, ticksLimit) {\r\n        const evenMajorSpacing = getEvenSpacing(majorIndices);\r\n        const spacing = ticks.length / ticksLimit;\r\n        if (!evenMajorSpacing) {\r\n            return Math.max(spacing, 1);\r\n        }\r\n        const factors = _factorize(evenMajorSpacing);\r\n        for (let i = 0, ilen = factors.length - 1; i < ilen; i++) {\r\n            const factor = factors[i];\r\n            if (factor > spacing) {\r\n                return factor;\r\n            }\r\n        }\r\n        return Math.max(spacing, 1);\r\n    }\r\n\r\n    function getMajorIndices(ticks) {\r\n        const result = [];\r\n        let i, ilen;\r\n        for (i = 0, ilen = ticks.length; i < ilen; i++) {\r\n            if (ticks[i].major) {\r\n                result.push(i);\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n\r\n    function skipMajors(ticks, newTicks, majorIndices, spacing) {\r\n        let count = 0;\r\n        let next = majorIndices[0];\r\n        let i;\r\n        spacing = Math.ceil(spacing);\r\n        for (i = 0; i < ticks.length; i++) {\r\n            if (i === next) {\r\n                newTicks.push(ticks[i]);\r\n                count++;\r\n                next = majorIndices[count * spacing];\r\n            }\r\n        }\r\n    }\r\n\r\n    function skip(ticks, newTicks, spacing, majorStart, majorEnd) {\r\n        const start = valueOrDefault(majorStart, 0);\r\n        const end = Math.min(valueOrDefault(majorEnd, ticks.length), ticks.length);\r\n        let count = 0;\r\n        let length, i, next;\r\n        spacing = Math.ceil(spacing);\r\n        if (majorEnd) {\r\n            length = majorEnd - majorStart;\r\n            spacing = length / Math.floor(length / spacing);\r\n        }\r\n        next = start;\r\n        while (next < 0) {\r\n            count++;\r\n            next = Math.round(start + count * spacing);\r\n        }\r\n        for (i = Math.max(start, 0); i < end; i++) {\r\n            if (i === next) {\r\n                newTicks.push(ticks[i]);\r\n                count++;\r\n                next = Math.round(start + count * spacing);\r\n            }\r\n        }\r\n    }\r\n\r\n    function getEvenSpacing(arr) {\r\n        const len = arr.length;\r\n        let i, diff;\r\n        if (len < 2) {\r\n            return false;\r\n        }\r\n        for (diff = arr[0], i = 1; i < len; ++i) {\r\n            if (arr[i] - arr[i - 1] !== diff) {\r\n                return false;\r\n            }\r\n        }\r\n        return diff;\r\n    }\r\n\r\n    const reverseAlign = (align) => align === 'left' ? 'right' : align === 'right' ? 'left' : align;\r\n    const offsetFromEdge = (scale, edge, offset) => edge === 'top' || edge === 'left' ? scale[edge] + offset : scale[edge] - offset;\r\n\r\n    function sample(arr, numItems) {\r\n        const result = [];\r\n        const increment = arr.length / numItems;\r\n        const len = arr.length;\r\n        let i = 0;\r\n        for (; i < len; i += increment) {\r\n            result.push(arr[Math.floor(i)]);\r\n        }\r\n        return result;\r\n    }\r\n\r\n    function getPixelForGridLine(scale, index, offsetGridLines) {\r\n        const length = scale.ticks.length;\r\n        const validIndex = Math.min(index, length - 1);\r\n        const start = scale._startPixel;\r\n        const end = scale._endPixel;\r\n        const epsilon = 1e-6;\r\n        let lineValue = scale.getPixelForTick(validIndex);\r\n        let offset;\r\n        if (offsetGridLines) {\r\n            if (length === 1) {\r\n                offset = Math.max(lineValue - start, end - lineValue);\r\n            } else if (index === 0) {\r\n                offset = (scale.getPixelForTick(1) - lineValue) / 2;\r\n            } else {\r\n                offset = (lineValue - scale.getPixelForTick(validIndex - 1)) / 2;\r\n            }\r\n            lineValue += validIndex < index ? offset : -offset;\r\n            if (lineValue < start - epsilon || lineValue > end + epsilon) {\r\n                return;\r\n            }\r\n        }\r\n        return lineValue;\r\n    }\r\n\r\n    function garbageCollect(caches, length) {\r\n        each(caches, (cache) => {\r\n            const gc = cache.gc;\r\n            const gcLen = gc.length / 2;\r\n            let i;\r\n            if (gcLen > length) {\r\n                for (i = 0; i < gcLen; ++i) {\r\n                    delete cache.data[gc[i]];\r\n                }\r\n                gc.splice(0, gcLen);\r\n            }\r\n        });\r\n    }\r\n\r\n    function getTickMarkLength(options) {\r\n        return options.drawTicks ? options.tickLength : 0;\r\n    }\r\n\r\n    function getTitleHeight(options, fallback) {\r\n        if (!options.display) {\r\n            return 0;\r\n        }\r\n        const font = toFont(options.font, fallback);\r\n        const padding = toPadding(options.padding);\r\n        const lines = isArray(options.text) ? options.text.length : 1;\r\n        return (lines * font.lineHeight) + padding.height;\r\n    }\r\n\r\n    function createScaleContext(parent, scale) {\r\n        return Object.assign(Object.create(parent), {\r\n            scale,\r\n            type: 'scale'\r\n        });\r\n    }\r\n\r\n    function createTickContext(parent, index, tick) {\r\n        return Object.assign(Object.create(parent), {\r\n            tick,\r\n            index,\r\n            type: 'tick'\r\n        });\r\n    }\r\n\r\n    function titleAlign(align, position, reverse) {\r\n        let ret = _toLeftRightCenter(align);\r\n        if ((reverse && position !== 'right') || (!reverse && position === 'right')) {\r\n            ret = reverseAlign(ret);\r\n        }\r\n        return ret;\r\n    }\r\n\r\n    function titleArgs(scale, offset, position, align) {\r\n        const {top, left, bottom, right} = scale;\r\n        let rotation = 0;\r\n        let maxWidth, titleX, titleY;\r\n        if (scale.isHorizontal()) {\r\n            titleX = _alignStartEnd(align, left, right);\r\n            titleY = offsetFromEdge(scale, position, offset);\r\n            maxWidth = right - left;\r\n        } else {\r\n            titleX = offsetFromEdge(scale, position, offset);\r\n            titleY = _alignStartEnd(align, bottom, top);\r\n            rotation = position === 'left' ? -HALF_PI : HALF_PI;\r\n        }\r\n        return {titleX, titleY, maxWidth, rotation};\r\n    }\r\n\r\n    class Scale extends Element {\r\n        constructor(cfg) {\r\n            super();\r\n            this.id = cfg.id;\r\n            this.type = cfg.type;\r\n            this.options = undefined;\r\n            this.ctx = cfg.ctx;\r\n            this.chart = cfg.chart;\r\n            this.top = undefined;\r\n            this.bottom = undefined;\r\n            this.left = undefined;\r\n            this.right = undefined;\r\n            this.width = undefined;\r\n            this.height = undefined;\r\n            this._margins = {\r\n                left: 0,\r\n                right: 0,\r\n                top: 0,\r\n                bottom: 0\r\n            };\r\n            this.maxWidth = undefined;\r\n            this.maxHeight = undefined;\r\n            this.paddingTop = undefined;\r\n            this.paddingBottom = undefined;\r\n            this.paddingLeft = undefined;\r\n            this.paddingRight = undefined;\r\n            this.axis = undefined;\r\n            this.labelRotation = undefined;\r\n            this.min = undefined;\r\n            this.max = undefined;\r\n            this.ticks = [];\r\n            this._gridLineItems = null;\r\n            this._labelItems = null;\r\n            this._labelSizes = null;\r\n            this._length = 0;\r\n            this._maxLength = 0;\r\n            this._longestTextCache = {};\r\n            this._startPixel = undefined;\r\n            this._endPixel = undefined;\r\n            this._reversePixels = false;\r\n            this._userMax = undefined;\r\n            this._userMin = undefined;\r\n            this._suggestedMax = undefined;\r\n            this._suggestedMin = undefined;\r\n            this._ticksLength = 0;\r\n            this._borderValue = 0;\r\n            this._cache = {};\r\n            this._dataLimitsCached = false;\r\n            this.$context = undefined;\r\n        }\r\n\r\n        init(options) {\r\n            const me = this;\r\n            me.options = options;\r\n            me.axis = options.axis;\r\n            me._userMin = me.parse(options.min);\r\n            me._userMax = me.parse(options.max);\r\n            me._suggestedMin = me.parse(options.suggestedMin);\r\n            me._suggestedMax = me.parse(options.suggestedMax);\r\n        }\r\n\r\n        parse(raw, index) {\r\n            return raw;\r\n        }\r\n\r\n        getUserBounds() {\r\n            let {_userMin, _userMax, _suggestedMin, _suggestedMax} = this;\r\n            _userMin = finiteOrDefault(_userMin, Number.POSITIVE_INFINITY);\r\n            _userMax = finiteOrDefault(_userMax, Number.NEGATIVE_INFINITY);\r\n            _suggestedMin = finiteOrDefault(_suggestedMin, Number.POSITIVE_INFINITY);\r\n            _suggestedMax = finiteOrDefault(_suggestedMax, Number.NEGATIVE_INFINITY);\r\n            return {\r\n                min: finiteOrDefault(_userMin, _suggestedMin),\r\n                max: finiteOrDefault(_userMax, _suggestedMax),\r\n                minDefined: isNumberFinite(_userMin),\r\n                maxDefined: isNumberFinite(_userMax)\r\n            };\r\n        }\r\n\r\n        getMinMax(canStack) {\r\n            const me = this;\r\n            let {min, max, minDefined, maxDefined} = me.getUserBounds();\r\n            let range;\r\n            if (minDefined && maxDefined) {\r\n                return {min, max};\r\n            }\r\n            const metas = me.getMatchingVisibleMetas();\r\n            for (let i = 0, ilen = metas.length; i < ilen; ++i) {\r\n                range = metas[i].controller.getMinMax(me, canStack);\r\n                if (!minDefined) {\r\n                    min = Math.min(min, range.min);\r\n                }\r\n                if (!maxDefined) {\r\n                    max = Math.max(max, range.max);\r\n                }\r\n            }\r\n            return {\r\n                min: finiteOrDefault(min, finiteOrDefault(max, min)),\r\n                max: finiteOrDefault(max, finiteOrDefault(min, max))\r\n            };\r\n        }\r\n\r\n        getPadding() {\r\n            const me = this;\r\n            return {\r\n                left: me.paddingLeft || 0,\r\n                top: me.paddingTop || 0,\r\n                right: me.paddingRight || 0,\r\n                bottom: me.paddingBottom || 0\r\n            };\r\n        }\r\n\r\n        getTicks() {\r\n            return this.ticks;\r\n        }\r\n\r\n        getLabels() {\r\n            const data = this.chart.data;\r\n            return this.options.labels || (this.isHorizontal() ? data.xLabels : data.yLabels) || data.labels || [];\r\n        }\r\n\r\n        beforeLayout() {\r\n            this._cache = {};\r\n            this._dataLimitsCached = false;\r\n        }\r\n\r\n        beforeUpdate() {\r\n            callback(this.options.beforeUpdate, [this]);\r\n        }\r\n\r\n        update(maxWidth, maxHeight, margins) {\r\n            const me = this;\r\n            const tickOpts = me.options.ticks;\r\n            const sampleSize = tickOpts.sampleSize;\r\n            me.beforeUpdate();\r\n            me.maxWidth = maxWidth;\r\n            me.maxHeight = maxHeight;\r\n            me._margins = margins = Object.assign({\r\n                left: 0,\r\n                right: 0,\r\n                top: 0,\r\n                bottom: 0\r\n            }, margins);\r\n            me.ticks = null;\r\n            me._labelSizes = null;\r\n            me._gridLineItems = null;\r\n            me._labelItems = null;\r\n            me.beforeSetDimensions();\r\n            me.setDimensions();\r\n            me.afterSetDimensions();\r\n            me._maxLength = me.isHorizontal()\r\n                ? me.width + margins.left + margins.right\r\n                : me.height + margins.top + margins.bottom;\r\n            if (!me._dataLimitsCached) {\r\n                me.beforeDataLimits();\r\n                me.determineDataLimits();\r\n                me.afterDataLimits();\r\n                me._dataLimitsCached = true;\r\n            }\r\n            me.beforeBuildTicks();\r\n            me.ticks = me.buildTicks() || [];\r\n            me.afterBuildTicks();\r\n            const samplingEnabled = sampleSize < me.ticks.length;\r\n            me._convertTicksToLabels(samplingEnabled ? sample(me.ticks, sampleSize) : me.ticks);\r\n            me.configure();\r\n            me.beforeCalculateLabelRotation();\r\n            me.calculateLabelRotation();\r\n            me.afterCalculateLabelRotation();\r\n            if (tickOpts.display && (tickOpts.autoSkip || tickOpts.source === 'auto')) {\r\n                me.ticks = autoSkip(me, me.ticks);\r\n                me._labelSizes = null;\r\n            }\r\n            if (samplingEnabled) {\r\n                me._convertTicksToLabels(me.ticks);\r\n            }\r\n            me.beforeFit();\r\n            me.fit();\r\n            me.afterFit();\r\n            me.afterUpdate();\r\n        }\r\n\r\n        configure() {\r\n            const me = this;\r\n            let reversePixels = me.options.reverse;\r\n            let startPixel, endPixel;\r\n            if (me.isHorizontal()) {\r\n                startPixel = me.left;\r\n                endPixel = me.right;\r\n            } else {\r\n                startPixel = me.top;\r\n                endPixel = me.bottom;\r\n                reversePixels = !reversePixels;\r\n            }\r\n            me._startPixel = startPixel;\r\n            me._endPixel = endPixel;\r\n            me._reversePixels = reversePixels;\r\n            me._length = endPixel - startPixel;\r\n            me._alignToPixels = me.options.alignToPixels;\r\n        }\r\n\r\n        afterUpdate() {\r\n            callback(this.options.afterUpdate, [this]);\r\n        }\r\n\r\n        beforeSetDimensions() {\r\n            callback(this.options.beforeSetDimensions, [this]);\r\n        }\r\n\r\n        setDimensions() {\r\n            const me = this;\r\n            if (me.isHorizontal()) {\r\n                me.width = me.maxWidth;\r\n                me.left = 0;\r\n                me.right = me.width;\r\n            } else {\r\n                me.height = me.maxHeight;\r\n                me.top = 0;\r\n                me.bottom = me.height;\r\n            }\r\n            me.paddingLeft = 0;\r\n            me.paddingTop = 0;\r\n            me.paddingRight = 0;\r\n            me.paddingBottom = 0;\r\n        }\r\n\r\n        afterSetDimensions() {\r\n            callback(this.options.afterSetDimensions, [this]);\r\n        }\r\n\r\n        _callHooks(name) {\r\n            const me = this;\r\n            me.chart.notifyPlugins(name, me.getContext());\r\n            callback(me.options[name], [me]);\r\n        }\r\n\r\n        beforeDataLimits() {\r\n            this._callHooks('beforeDataLimits');\r\n        }\r\n\r\n        determineDataLimits() {\r\n        }\r\n\r\n        afterDataLimits() {\r\n            this._callHooks('afterDataLimits');\r\n        }\r\n\r\n        beforeBuildTicks() {\r\n            this._callHooks('beforeBuildTicks');\r\n        }\r\n\r\n        buildTicks() {\r\n            return [];\r\n        }\r\n\r\n        afterBuildTicks() {\r\n            this._callHooks('afterBuildTicks');\r\n        }\r\n\r\n        beforeTickToLabelConversion() {\r\n            callback(this.options.beforeTickToLabelConversion, [this]);\r\n        }\r\n\r\n        generateTickLabels(ticks) {\r\n            const me = this;\r\n            const tickOpts = me.options.ticks;\r\n            let i, ilen, tick;\r\n            for (i = 0, ilen = ticks.length; i < ilen; i++) {\r\n                tick = ticks[i];\r\n                tick.label = callback(tickOpts.callback, [tick.value, i, ticks], me);\r\n            }\r\n        }\r\n\r\n        afterTickToLabelConversion() {\r\n            callback(this.options.afterTickToLabelConversion, [this]);\r\n        }\r\n\r\n        beforeCalculateLabelRotation() {\r\n            callback(this.options.beforeCalculateLabelRotation, [this]);\r\n        }\r\n\r\n        calculateLabelRotation() {\r\n            const me = this;\r\n            const options = me.options;\r\n            const tickOpts = options.ticks;\r\n            const numTicks = me.ticks.length;\r\n            const minRotation = tickOpts.minRotation || 0;\r\n            const maxRotation = tickOpts.maxRotation;\r\n            let labelRotation = minRotation;\r\n            let tickWidth, maxHeight, maxLabelDiagonal;\r\n            if (!me._isVisible() || !tickOpts.display || minRotation >= maxRotation || numTicks <= 1 || !me.isHorizontal()) {\r\n                me.labelRotation = minRotation;\r\n                return;\r\n            }\r\n            const labelSizes = me._getLabelSizes();\r\n            const maxLabelWidth = labelSizes.widest.width;\r\n            const maxLabelHeight = labelSizes.highest.height;\r\n            const maxWidth = _limitValue(me.chart.width - maxLabelWidth, 0, me.maxWidth);\r\n            tickWidth = options.offset ? me.maxWidth / numTicks : maxWidth / (numTicks - 1);\r\n            if (maxLabelWidth + 6 > tickWidth) {\r\n                tickWidth = maxWidth / (numTicks - (options.offset ? 0.5 : 1));\r\n                maxHeight = me.maxHeight - getTickMarkLength(options.grid)\r\n                    - tickOpts.padding - getTitleHeight(options.title, me.chart.options.font);\r\n                maxLabelDiagonal = Math.sqrt(maxLabelWidth * maxLabelWidth + maxLabelHeight * maxLabelHeight);\r\n                labelRotation = toDegrees(Math.min(\r\n                    Math.asin(Math.min((labelSizes.highest.height + 6) / tickWidth, 1)),\r\n                    Math.asin(Math.min(maxHeight / maxLabelDiagonal, 1)) - Math.asin(maxLabelHeight / maxLabelDiagonal)\r\n                ));\r\n                labelRotation = Math.max(minRotation, Math.min(maxRotation, labelRotation));\r\n            }\r\n            me.labelRotation = labelRotation;\r\n        }\r\n\r\n        afterCalculateLabelRotation() {\r\n            callback(this.options.afterCalculateLabelRotation, [this]);\r\n        }\r\n\r\n        beforeFit() {\r\n            callback(this.options.beforeFit, [this]);\r\n        }\r\n\r\n        fit() {\r\n            const me = this;\r\n            const minSize = {\r\n                width: 0,\r\n                height: 0\r\n            };\r\n            const {chart, options: {ticks: tickOpts, title: titleOpts, grid: gridOpts}} = me;\r\n            const display = me._isVisible();\r\n            const isHorizontal = me.isHorizontal();\r\n            if (display) {\r\n                const titleHeight = getTitleHeight(titleOpts, chart.options.font);\r\n                if (isHorizontal) {\r\n                    minSize.width = me.maxWidth;\r\n                    minSize.height = getTickMarkLength(gridOpts) + titleHeight;\r\n                } else {\r\n                    minSize.height = me.maxHeight;\r\n                    minSize.width = getTickMarkLength(gridOpts) + titleHeight;\r\n                }\r\n                if (tickOpts.display && me.ticks.length) {\r\n                    const {first, last, widest, highest} = me._getLabelSizes();\r\n                    const tickPadding = tickOpts.padding * 2;\r\n                    const angleRadians = toRadians(me.labelRotation);\r\n                    const cos = Math.cos(angleRadians);\r\n                    const sin = Math.sin(angleRadians);\r\n                    if (isHorizontal) {\r\n                        const labelHeight = sin * widest.width + cos * highest.height;\r\n                        minSize.height = Math.min(me.maxHeight, minSize.height + labelHeight + tickPadding);\r\n                    } else {\r\n                        const labelWidth = tickOpts.mirror ? 0 : cos * widest.width + sin * highest.height;\r\n                        minSize.width = Math.min(me.maxWidth, minSize.width + labelWidth + tickPadding);\r\n                    }\r\n                    me._calculatePadding(first, last, sin, cos);\r\n                }\r\n            }\r\n            me._handleMargins();\r\n            if (isHorizontal) {\r\n                me.width = me._length = chart.width - me._margins.left - me._margins.right;\r\n                me.height = minSize.height;\r\n            } else {\r\n                me.width = minSize.width;\r\n                me.height = me._length = chart.height - me._margins.top - me._margins.bottom;\r\n            }\r\n        }\r\n\r\n        _calculatePadding(first, last, sin, cos) {\r\n            const me = this;\r\n            const {ticks: {align, padding}, position} = me.options;\r\n            const isRotated = me.labelRotation !== 0;\r\n            const labelsBelowTicks = position !== 'top' && me.axis === 'x';\r\n            if (me.isHorizontal()) {\r\n                const offsetLeft = me.getPixelForTick(0) - me.left;\r\n                const offsetRight = me.right - me.getPixelForTick(me.ticks.length - 1);\r\n                let paddingLeft = 0;\r\n                let paddingRight = 0;\r\n                if (isRotated) {\r\n                    if (labelsBelowTicks) {\r\n                        paddingLeft = cos * first.width;\r\n                        paddingRight = sin * last.height;\r\n                    } else {\r\n                        paddingLeft = sin * first.height;\r\n                        paddingRight = cos * last.width;\r\n                    }\r\n                } else if (align === 'start') {\r\n                    paddingRight = last.width;\r\n                } else if (align === 'end') {\r\n                    paddingLeft = first.width;\r\n                } else {\r\n                    paddingLeft = first.width / 2;\r\n                    paddingRight = last.width / 2;\r\n                }\r\n                me.paddingLeft = Math.max((paddingLeft - offsetLeft + padding) * me.width / (me.width - offsetLeft), 0);\r\n                me.paddingRight = Math.max((paddingRight - offsetRight + padding) * me.width / (me.width - offsetRight), 0);\r\n            } else {\r\n                let paddingTop = last.height / 2;\r\n                let paddingBottom = first.height / 2;\r\n                if (align === 'start') {\r\n                    paddingTop = 0;\r\n                    paddingBottom = first.height;\r\n                } else if (align === 'end') {\r\n                    paddingTop = last.height;\r\n                    paddingBottom = 0;\r\n                }\r\n                me.paddingTop = paddingTop + padding;\r\n                me.paddingBottom = paddingBottom + padding;\r\n            }\r\n        }\r\n\r\n        _handleMargins() {\r\n            const me = this;\r\n            if (me._margins) {\r\n                me._margins.left = Math.max(me.paddingLeft, me._margins.left);\r\n                me._margins.top = Math.max(me.paddingTop, me._margins.top);\r\n                me._margins.right = Math.max(me.paddingRight, me._margins.right);\r\n                me._margins.bottom = Math.max(me.paddingBottom, me._margins.bottom);\r\n            }\r\n        }\r\n\r\n        afterFit() {\r\n            callback(this.options.afterFit, [this]);\r\n        }\r\n\r\n        isHorizontal() {\r\n            const {axis, position} = this.options;\r\n            return position === 'top' || position === 'bottom' || axis === 'x';\r\n        }\r\n\r\n        isFullSize() {\r\n            return this.options.fullSize;\r\n        }\r\n\r\n        _convertTicksToLabels(ticks) {\r\n            const me = this;\r\n            me.beforeTickToLabelConversion();\r\n            me.generateTickLabels(ticks);\r\n            me.afterTickToLabelConversion();\r\n        }\r\n\r\n        _getLabelSizes() {\r\n            const me = this;\r\n            let labelSizes = me._labelSizes;\r\n            if (!labelSizes) {\r\n                const sampleSize = me.options.ticks.sampleSize;\r\n                let ticks = me.ticks;\r\n                if (sampleSize < ticks.length) {\r\n                    ticks = sample(ticks, sampleSize);\r\n                }\r\n                me._labelSizes = labelSizes = me._computeLabelSizes(ticks, ticks.length);\r\n            }\r\n            return labelSizes;\r\n        }\r\n\r\n        _computeLabelSizes(ticks, length) {\r\n            const {ctx, _longestTextCache: caches} = this;\r\n            const widths = [];\r\n            const heights = [];\r\n            let widestLabelSize = 0;\r\n            let highestLabelSize = 0;\r\n            let i, j, jlen, label, tickFont, fontString, cache, lineHeight, width, height, nestedLabel;\r\n            for (i = 0; i < length; ++i) {\r\n                label = ticks[i].label;\r\n                tickFont = this._resolveTickFontOptions(i);\r\n                ctx.font = fontString = tickFont.string;\r\n                cache = caches[fontString] = caches[fontString] || {data: {}, gc: []};\r\n                lineHeight = tickFont.lineHeight;\r\n                width = height = 0;\r\n                if (!isNullOrUndef(label) && !isArray(label)) {\r\n                    width = _measureText(ctx, cache.data, cache.gc, width, label);\r\n                    height = lineHeight;\r\n                } else if (isArray(label)) {\r\n                    for (j = 0, jlen = label.length; j < jlen; ++j) {\r\n                        nestedLabel = label[j];\r\n                        if (!isNullOrUndef(nestedLabel) && !isArray(nestedLabel)) {\r\n                            width = _measureText(ctx, cache.data, cache.gc, width, nestedLabel);\r\n                            height += lineHeight;\r\n                        }\r\n                    }\r\n                }\r\n                widths.push(width);\r\n                heights.push(height);\r\n                widestLabelSize = Math.max(width, widestLabelSize);\r\n                highestLabelSize = Math.max(height, highestLabelSize);\r\n            }\r\n            garbageCollect(caches, length);\r\n            const widest = widths.indexOf(widestLabelSize);\r\n            const highest = heights.indexOf(highestLabelSize);\r\n            const valueAt = (idx) => ({width: widths[idx] || 0, height: heights[idx] || 0});\r\n            return {\r\n                first: valueAt(0),\r\n                last: valueAt(length - 1),\r\n                widest: valueAt(widest),\r\n                highest: valueAt(highest)\r\n            };\r\n        }\r\n\r\n        getLabelForValue(value) {\r\n            return value;\r\n        }\r\n\r\n        getPixelForValue(value, index) {\r\n            return NaN;\r\n        }\r\n\r\n        getValueForPixel(pixel) {\r\n        }\r\n\r\n        getPixelForTick(index) {\r\n            const ticks = this.ticks;\r\n            if (index < 0 || index > ticks.length - 1) {\r\n                return null;\r\n            }\r\n            return this.getPixelForValue(ticks[index].value);\r\n        }\r\n\r\n        getPixelForDecimal(decimal) {\r\n            const me = this;\r\n            if (me._reversePixels) {\r\n                decimal = 1 - decimal;\r\n            }\r\n            const pixel = me._startPixel + decimal * me._length;\r\n            return _int16Range(me._alignToPixels ? _alignPixel(me.chart, pixel, 0) : pixel);\r\n        }\r\n\r\n        getDecimalForPixel(pixel) {\r\n            const decimal = (pixel - this._startPixel) / this._length;\r\n            return this._reversePixels ? 1 - decimal : decimal;\r\n        }\r\n\r\n        getBasePixel() {\r\n            return this.getPixelForValue(this.getBaseValue());\r\n        }\r\n\r\n        getBaseValue() {\r\n            const {min, max} = this;\r\n            return min < 0 && max < 0 ? max :\r\n                min > 0 && max > 0 ? min :\r\n                    0;\r\n        }\r\n\r\n        getContext(index) {\r\n            const me = this;\r\n            const ticks = me.ticks || [];\r\n            if (index >= 0 && index < ticks.length) {\r\n                const tick = ticks[index];\r\n                return tick.$context ||\r\n                    (tick.$context = createTickContext(me.getContext(), index, tick));\r\n            }\r\n            return me.$context ||\r\n                (me.$context = createScaleContext(me.chart.getContext(), me));\r\n        }\r\n\r\n        _tickSize() {\r\n            const me = this;\r\n            const optionTicks = me.options.ticks;\r\n            const rot = toRadians(me.labelRotation);\r\n            const cos = Math.abs(Math.cos(rot));\r\n            const sin = Math.abs(Math.sin(rot));\r\n            const labelSizes = me._getLabelSizes();\r\n            const padding = optionTicks.autoSkipPadding || 0;\r\n            const w = labelSizes ? labelSizes.widest.width + padding : 0;\r\n            const h = labelSizes ? labelSizes.highest.height + padding : 0;\r\n            return me.isHorizontal()\r\n                ? h * cos > w * sin ? w / cos : h / sin\r\n                : h * sin < w * cos ? h / cos : w / sin;\r\n        }\r\n\r\n        _isVisible() {\r\n            const display = this.options.display;\r\n            if (display !== 'auto') {\r\n                return !!display;\r\n            }\r\n            return this.getMatchingVisibleMetas().length > 0;\r\n        }\r\n\r\n        _computeGridLineItems(chartArea) {\r\n            const me = this;\r\n            const axis = me.axis;\r\n            const chart = me.chart;\r\n            const options = me.options;\r\n            const {grid, position} = options;\r\n            const offset = grid.offset;\r\n            const isHorizontal = me.isHorizontal();\r\n            const ticks = me.ticks;\r\n            const ticksLength = ticks.length + (offset ? 1 : 0);\r\n            const tl = getTickMarkLength(grid);\r\n            const items = [];\r\n            const borderOpts = grid.setContext(me.getContext(0));\r\n            const axisWidth = borderOpts.drawBorder ? borderOpts.borderWidth : 0;\r\n            const axisHalfWidth = axisWidth / 2;\r\n            const alignBorderValue = function (pixel) {\r\n                return _alignPixel(chart, pixel, axisWidth);\r\n            };\r\n            let borderValue, i, lineValue, alignedLineValue;\r\n            let tx1, ty1, tx2, ty2, x1, y1, x2, y2;\r\n            if (position === 'top') {\r\n                borderValue = alignBorderValue(me.bottom);\r\n                ty1 = me.bottom - tl;\r\n                ty2 = borderValue - axisHalfWidth;\r\n                y1 = alignBorderValue(chartArea.top) + axisHalfWidth;\r\n                y2 = chartArea.bottom;\r\n            } else if (position === 'bottom') {\r\n                borderValue = alignBorderValue(me.top);\r\n                y1 = chartArea.top;\r\n                y2 = alignBorderValue(chartArea.bottom) - axisHalfWidth;\r\n                ty1 = borderValue + axisHalfWidth;\r\n                ty2 = me.top + tl;\r\n            } else if (position === 'left') {\r\n                borderValue = alignBorderValue(me.right);\r\n                tx1 = me.right - tl;\r\n                tx2 = borderValue - axisHalfWidth;\r\n                x1 = alignBorderValue(chartArea.left) + axisHalfWidth;\r\n                x2 = chartArea.right;\r\n            } else if (position === 'right') {\r\n                borderValue = alignBorderValue(me.left);\r\n                x1 = chartArea.left;\r\n                x2 = alignBorderValue(chartArea.right) - axisHalfWidth;\r\n                tx1 = borderValue + axisHalfWidth;\r\n                tx2 = me.left + tl;\r\n            } else if (axis === 'x') {\r\n                if (position === 'center') {\r\n                    borderValue = alignBorderValue((chartArea.top + chartArea.bottom) / 2 + 0.5);\r\n                } else if (isObject(position)) {\r\n                    const positionAxisID = Object.keys(position)[0];\r\n                    const value = position[positionAxisID];\r\n                    borderValue = alignBorderValue(me.chart.scales[positionAxisID].getPixelForValue(value));\r\n                }\r\n                y1 = chartArea.top;\r\n                y2 = chartArea.bottom;\r\n                ty1 = borderValue + axisHalfWidth;\r\n                ty2 = ty1 + tl;\r\n            } else if (axis === 'y') {\r\n                if (position === 'center') {\r\n                    borderValue = alignBorderValue((chartArea.left + chartArea.right) / 2);\r\n                } else if (isObject(position)) {\r\n                    const positionAxisID = Object.keys(position)[0];\r\n                    const value = position[positionAxisID];\r\n                    borderValue = alignBorderValue(me.chart.scales[positionAxisID].getPixelForValue(value));\r\n                }\r\n                tx1 = borderValue - axisHalfWidth;\r\n                tx2 = tx1 - tl;\r\n                x1 = chartArea.left;\r\n                x2 = chartArea.right;\r\n            }\r\n            for (i = 0; i < ticksLength; ++i) {\r\n                const optsAtIndex = grid.setContext(me.getContext(i));\r\n                const lineWidth = optsAtIndex.lineWidth;\r\n                const lineColor = optsAtIndex.color;\r\n                const borderDash = grid.borderDash || [];\r\n                const borderDashOffset = optsAtIndex.borderDashOffset;\r\n                const tickWidth = optsAtIndex.tickWidth;\r\n                const tickColor = optsAtIndex.tickColor;\r\n                const tickBorderDash = optsAtIndex.tickBorderDash || [];\r\n                const tickBorderDashOffset = optsAtIndex.tickBorderDashOffset;\r\n                lineValue = getPixelForGridLine(me, i, offset);\r\n                if (lineValue === undefined) {\r\n                    continue;\r\n                }\r\n                alignedLineValue = _alignPixel(chart, lineValue, lineWidth);\r\n                if (isHorizontal) {\r\n                    tx1 = tx2 = x1 = x2 = alignedLineValue;\r\n                } else {\r\n                    ty1 = ty2 = y1 = y2 = alignedLineValue;\r\n                }\r\n                items.push({\r\n                    tx1,\r\n                    ty1,\r\n                    tx2,\r\n                    ty2,\r\n                    x1,\r\n                    y1,\r\n                    x2,\r\n                    y2,\r\n                    width: lineWidth,\r\n                    color: lineColor,\r\n                    borderDash,\r\n                    borderDashOffset,\r\n                    tickWidth,\r\n                    tickColor,\r\n                    tickBorderDash,\r\n                    tickBorderDashOffset,\r\n                });\r\n            }\r\n            me._ticksLength = ticksLength;\r\n            me._borderValue = borderValue;\r\n            return items;\r\n        }\r\n\r\n        _computeLabelItems(chartArea) {\r\n            const me = this;\r\n            const axis = me.axis;\r\n            const options = me.options;\r\n            const {position, ticks: optionTicks} = options;\r\n            const isHorizontal = me.isHorizontal();\r\n            const ticks = me.ticks;\r\n            const {align, crossAlign, padding} = optionTicks;\r\n            const tl = getTickMarkLength(options.grid);\r\n            const tickAndPadding = tl + padding;\r\n            const rotation = -toRadians(me.labelRotation);\r\n            const items = [];\r\n            let i, ilen, tick, label, x, y, textAlign, pixel, font, lineHeight, lineCount, textOffset;\r\n            let textBaseline = 'middle';\r\n            if (position === 'top') {\r\n                y = me.bottom - tickAndPadding;\r\n                textAlign = me._getXAxisLabelAlignment();\r\n            } else if (position === 'bottom') {\r\n                y = me.top + tickAndPadding;\r\n                textAlign = me._getXAxisLabelAlignment();\r\n            } else if (position === 'left') {\r\n                const ret = this._getYAxisLabelAlignment(tl);\r\n                textAlign = ret.textAlign;\r\n                x = ret.x;\r\n            } else if (position === 'right') {\r\n                const ret = this._getYAxisLabelAlignment(tl);\r\n                textAlign = ret.textAlign;\r\n                x = ret.x;\r\n            } else if (axis === 'x') {\r\n                if (position === 'center') {\r\n                    y = ((chartArea.top + chartArea.bottom) / 2) + tickAndPadding;\r\n                } else if (isObject(position)) {\r\n                    const positionAxisID = Object.keys(position)[0];\r\n                    const value = position[positionAxisID];\r\n                    y = me.chart.scales[positionAxisID].getPixelForValue(value) + tickAndPadding;\r\n                }\r\n                textAlign = me._getXAxisLabelAlignment();\r\n            } else if (axis === 'y') {\r\n                if (position === 'center') {\r\n                    x = ((chartArea.left + chartArea.right) / 2) - tickAndPadding;\r\n                } else if (isObject(position)) {\r\n                    const positionAxisID = Object.keys(position)[0];\r\n                    const value = position[positionAxisID];\r\n                    x = me.chart.scales[positionAxisID].getPixelForValue(value);\r\n                }\r\n                textAlign = this._getYAxisLabelAlignment(tl).textAlign;\r\n            }\r\n            if (axis === 'y') {\r\n                if (align === 'start') {\r\n                    textBaseline = 'top';\r\n                } else if (align === 'end') {\r\n                    textBaseline = 'bottom';\r\n                }\r\n            }\r\n            const labelSizes = me._getLabelSizes();\r\n            for (i = 0, ilen = ticks.length; i < ilen; ++i) {\r\n                tick = ticks[i];\r\n                label = tick.label;\r\n                const optsAtIndex = optionTicks.setContext(me.getContext(i));\r\n                pixel = me.getPixelForTick(i) + optionTicks.labelOffset;\r\n                font = me._resolveTickFontOptions(i);\r\n                lineHeight = font.lineHeight;\r\n                lineCount = isArray(label) ? label.length : 1;\r\n                const halfCount = lineCount / 2;\r\n                const color = optsAtIndex.color;\r\n                const strokeColor = optsAtIndex.textStrokeColor;\r\n                const strokeWidth = optsAtIndex.textStrokeWidth;\r\n                if (isHorizontal) {\r\n                    x = pixel;\r\n                    if (position === 'top') {\r\n                        if (crossAlign === 'near' || rotation !== 0) {\r\n                            textOffset = -lineCount * lineHeight + lineHeight / 2;\r\n                        } else if (crossAlign === 'center') {\r\n                            textOffset = -labelSizes.highest.height / 2 - halfCount * lineHeight + lineHeight;\r\n                        } else {\r\n                            textOffset = -labelSizes.highest.height + lineHeight / 2;\r\n                        }\r\n                    } else {\r\n                        if (crossAlign === 'near' || rotation !== 0) {\r\n                            textOffset = lineHeight / 2;\r\n                        } else if (crossAlign === 'center') {\r\n                            textOffset = labelSizes.highest.height / 2 - halfCount * lineHeight;\r\n                        } else {\r\n                            textOffset = labelSizes.highest.height - lineCount * lineHeight;\r\n                        }\r\n                    }\r\n                } else {\r\n                    y = pixel;\r\n                    textOffset = (1 - lineCount) * lineHeight / 2;\r\n                }\r\n                items.push({\r\n                    rotation,\r\n                    label,\r\n                    font,\r\n                    color,\r\n                    strokeColor,\r\n                    strokeWidth,\r\n                    textOffset,\r\n                    textAlign,\r\n                    textBaseline,\r\n                    translation: [x, y]\r\n                });\r\n            }\r\n            return items;\r\n        }\r\n\r\n        _getXAxisLabelAlignment() {\r\n            const me = this;\r\n            const {position, ticks} = me.options;\r\n            const rotation = -toRadians(me.labelRotation);\r\n            if (rotation) {\r\n                return position === 'top' ? 'left' : 'right';\r\n            }\r\n            let align = 'center';\r\n            if (ticks.align === 'start') {\r\n                align = 'left';\r\n            } else if (ticks.align === 'end') {\r\n                align = 'right';\r\n            }\r\n            return align;\r\n        }\r\n\r\n        _getYAxisLabelAlignment(tl) {\r\n            const me = this;\r\n            const {position, ticks: {crossAlign, mirror, padding}} = me.options;\r\n            const labelSizes = me._getLabelSizes();\r\n            const tickAndPadding = tl + padding;\r\n            const widest = labelSizes.widest.width;\r\n            let textAlign;\r\n            let x;\r\n            if (position === 'left') {\r\n                if (mirror) {\r\n                    textAlign = 'left';\r\n                    x = me.right - padding;\r\n                } else {\r\n                    x = me.right - tickAndPadding;\r\n                    if (crossAlign === 'near') {\r\n                        textAlign = 'right';\r\n                    } else if (crossAlign === 'center') {\r\n                        textAlign = 'center';\r\n                        x -= (widest / 2);\r\n                    } else {\r\n                        textAlign = 'left';\r\n                        x = me.left;\r\n                    }\r\n                }\r\n            } else if (position === 'right') {\r\n                if (mirror) {\r\n                    textAlign = 'right';\r\n                    x = me.left + padding;\r\n                } else {\r\n                    x = me.left + tickAndPadding;\r\n                    if (crossAlign === 'near') {\r\n                        textAlign = 'left';\r\n                    } else if (crossAlign === 'center') {\r\n                        textAlign = 'center';\r\n                        x += widest / 2;\r\n                    } else {\r\n                        textAlign = 'right';\r\n                        x = me.right;\r\n                    }\r\n                }\r\n            } else {\r\n                textAlign = 'right';\r\n            }\r\n            return {textAlign, x};\r\n        }\r\n\r\n        _computeLabelArea() {\r\n            const me = this;\r\n            if (me.options.ticks.mirror) {\r\n                return;\r\n            }\r\n            const chart = me.chart;\r\n            const position = me.options.position;\r\n            if (position === 'left' || position === 'right') {\r\n                return {top: 0, left: me.left, bottom: chart.height, right: me.right};\r\n            }\r\n            if (position === 'top' || position === 'bottom') {\r\n                return {top: me.top, left: 0, bottom: me.bottom, right: chart.width};\r\n            }\r\n        }\r\n\r\n        drawBackground() {\r\n            const {ctx, options: {backgroundColor}, left, top, width, height} = this;\r\n            if (backgroundColor) {\r\n                ctx.save();\r\n                ctx.fillStyle = backgroundColor;\r\n                ctx.fillRect(left, top, width, height);\r\n                ctx.restore();\r\n            }\r\n        }\r\n\r\n        getLineWidthForValue(value) {\r\n            const me = this;\r\n            const grid = me.options.grid;\r\n            if (!me._isVisible() || !grid.display) {\r\n                return 0;\r\n            }\r\n            const ticks = me.ticks;\r\n            const index = ticks.findIndex(t => t.value === value);\r\n            if (index >= 0) {\r\n                const opts = grid.setContext(me.getContext(index));\r\n                return opts.lineWidth;\r\n            }\r\n            return 0;\r\n        }\r\n\r\n        drawGrid(chartArea) {\r\n            const me = this;\r\n            const grid = me.options.grid;\r\n            const ctx = me.ctx;\r\n            const chart = me.chart;\r\n            const borderOpts = grid.setContext(me.getContext(0));\r\n            const axisWidth = grid.drawBorder ? borderOpts.borderWidth : 0;\r\n            const items = me._gridLineItems || (me._gridLineItems = me._computeGridLineItems(chartArea));\r\n            let i, ilen;\r\n            const drawLine = (p1, p2, style) => {\r\n                if (!style.width || !style.color) {\r\n                    return;\r\n                }\r\n                ctx.save();\r\n                ctx.lineWidth = style.width;\r\n                ctx.strokeStyle = style.color;\r\n                ctx.setLineDash(style.borderDash || []);\r\n                ctx.lineDashOffset = style.borderDashOffset;\r\n                ctx.beginPath();\r\n                ctx.moveTo(p1.x, p1.y);\r\n                ctx.lineTo(p2.x, p2.y);\r\n                ctx.stroke();\r\n                ctx.restore();\r\n            };\r\n            if (grid.display) {\r\n                for (i = 0, ilen = items.length; i < ilen; ++i) {\r\n                    const item = items[i];\r\n                    if (grid.drawOnChartArea) {\r\n                        drawLine(\r\n                            {x: item.x1, y: item.y1},\r\n                            {x: item.x2, y: item.y2},\r\n                            item\r\n                        );\r\n                    }\r\n                    if (grid.drawTicks) {\r\n                        drawLine(\r\n                            {x: item.tx1, y: item.ty1},\r\n                            {x: item.tx2, y: item.ty2},\r\n                            {\r\n                                color: item.tickColor,\r\n                                width: item.tickWidth,\r\n                                borderDash: item.tickBorderDash,\r\n                                borderDashOffset: item.tickBorderDashOffset\r\n                            }\r\n                        );\r\n                    }\r\n                }\r\n            }\r\n            if (axisWidth) {\r\n                const edgeOpts = grid.setContext(me.getContext(me._ticksLength - 1));\r\n                const lastLineWidth = edgeOpts.lineWidth;\r\n                const borderValue = me._borderValue;\r\n                let x1, x2, y1, y2;\r\n                if (me.isHorizontal()) {\r\n                    x1 = _alignPixel(chart, me.left, axisWidth) - axisWidth / 2;\r\n                    x2 = _alignPixel(chart, me.right, lastLineWidth) + lastLineWidth / 2;\r\n                    y1 = y2 = borderValue;\r\n                } else {\r\n                    y1 = _alignPixel(chart, me.top, axisWidth) - axisWidth / 2;\r\n                    y2 = _alignPixel(chart, me.bottom, lastLineWidth) + lastLineWidth / 2;\r\n                    x1 = x2 = borderValue;\r\n                }\r\n                drawLine(\r\n                    {x: x1, y: y1},\r\n                    {x: x2, y: y2},\r\n                    {width: axisWidth, color: edgeOpts.borderColor});\r\n            }\r\n        }\r\n\r\n        drawLabels(chartArea) {\r\n            const me = this;\r\n            const optionTicks = me.options.ticks;\r\n            if (!optionTicks.display) {\r\n                return;\r\n            }\r\n            const ctx = me.ctx;\r\n            const area = me._computeLabelArea();\r\n            if (area) {\r\n                clipArea(ctx, area);\r\n            }\r\n            const items = me._labelItems || (me._labelItems = me._computeLabelItems(chartArea));\r\n            let i, ilen;\r\n            for (i = 0, ilen = items.length; i < ilen; ++i) {\r\n                const item = items[i];\r\n                const tickFont = item.font;\r\n                const label = item.label;\r\n                let y = item.textOffset;\r\n                renderText(ctx, label, 0, y, tickFont, item);\r\n            }\r\n            if (area) {\r\n                unclipArea(ctx);\r\n            }\r\n        }\r\n\r\n        drawTitle() {\r\n            const {ctx, options: {position, title, reverse}} = this;\r\n            if (!title.display) {\r\n                return;\r\n            }\r\n            const font = toFont(title.font);\r\n            const padding = toPadding(title.padding);\r\n            const align = title.align;\r\n            let offset = font.lineHeight / 2;\r\n            if (position === 'bottom') {\r\n                offset += padding.bottom;\r\n                if (isArray(title.text)) {\r\n                    offset += font.lineHeight * (title.text.length - 1);\r\n                }\r\n            } else {\r\n                offset += padding.top;\r\n            }\r\n            const {titleX, titleY, maxWidth, rotation} = titleArgs(this, offset, position, align);\r\n            renderText(ctx, title.text, 0, 0, font, {\r\n                color: title.color,\r\n                maxWidth,\r\n                rotation,\r\n                textAlign: titleAlign(align, position, reverse),\r\n                textBaseline: 'middle',\r\n                translation: [titleX, titleY],\r\n            });\r\n        }\r\n\r\n        draw(chartArea) {\r\n            const me = this;\r\n            if (!me._isVisible()) {\r\n                return;\r\n            }\r\n            me.drawBackground();\r\n            me.drawGrid(chartArea);\r\n            me.drawTitle();\r\n            me.drawLabels(chartArea);\r\n        }\r\n\r\n        _layers() {\r\n            const me = this;\r\n            const opts = me.options;\r\n            const tz = opts.ticks && opts.ticks.z || 0;\r\n            const gz = opts.grid && opts.grid.z || 0;\r\n            if (!me._isVisible() || tz === gz || me.draw !== Scale.prototype.draw) {\r\n                return [{\r\n                    z: tz,\r\n                    draw(chartArea) {\r\n                        me.draw(chartArea);\r\n                    }\r\n                }];\r\n            }\r\n            return [{\r\n                z: gz,\r\n                draw(chartArea) {\r\n                    me.drawBackground();\r\n                    me.drawGrid(chartArea);\r\n                    me.drawTitle();\r\n                }\r\n            }, {\r\n                z: tz,\r\n                draw(chartArea) {\r\n                    me.drawLabels(chartArea);\r\n                }\r\n            }];\r\n        }\r\n\r\n        getMatchingVisibleMetas(type) {\r\n            const me = this;\r\n            const metas = me.chart.getSortedVisibleDatasetMetas();\r\n            const axisID = me.axis + 'AxisID';\r\n            const result = [];\r\n            let i, ilen;\r\n            for (i = 0, ilen = metas.length; i < ilen; ++i) {\r\n                const meta = metas[i];\r\n                if (meta[axisID] === me.id && (!type || meta.type === type)) {\r\n                    result.push(meta);\r\n                }\r\n            }\r\n            return result;\r\n        }\r\n\r\n        _resolveTickFontOptions(index) {\r\n            const opts = this.options.ticks.setContext(this.getContext(index));\r\n            return toFont(opts.font);\r\n        }\r\n    }\r\n\r\n    function _createResolver(scopes, prefixes = [''], rootScopes = scopes, fallback) {\r\n        if (!defined(fallback)) {\r\n            fallback = _resolve('_fallback', scopes);\r\n        }\r\n        const cache = {\r\n            [Symbol.toStringTag]: 'Object',\r\n            _cacheable: true,\r\n            _scopes: scopes,\r\n            _rootScopes: rootScopes,\r\n            _fallback: fallback,\r\n            override: (scope) => _createResolver([scope, ...scopes], prefixes, rootScopes, fallback),\r\n        };\r\n        return new Proxy(cache, {\r\n            deleteProperty(target, prop) {\r\n                delete target[prop];\r\n                delete target._keys;\r\n                delete scopes[0][prop];\r\n                return true;\r\n            },\r\n            get(target, prop) {\r\n                return _cached(target, prop,\r\n                    () => _resolveWithPrefixes(prop, prefixes, scopes, target));\r\n            },\r\n            getOwnPropertyDescriptor(target, prop) {\r\n                return Reflect.getOwnPropertyDescriptor(target._scopes[0], prop);\r\n            },\r\n            getPrototypeOf() {\r\n                return Reflect.getPrototypeOf(scopes[0]);\r\n            },\r\n            has(target, prop) {\r\n                return getKeysFromAllScopes(target).includes(prop);\r\n            },\r\n            ownKeys(target) {\r\n                return getKeysFromAllScopes(target);\r\n            },\r\n            set(target, prop, value) {\r\n                scopes[0][prop] = value;\r\n                delete target[prop];\r\n                delete target._keys;\r\n                return true;\r\n            }\r\n        });\r\n    }\r\n\r\n    function _attachContext(proxy, context, subProxy, descriptorDefaults) {\r\n        const cache = {\r\n            _cacheable: false,\r\n            _proxy: proxy,\r\n            _context: context,\r\n            _subProxy: subProxy,\r\n            _stack: new Set(),\r\n            _descriptors: _descriptors(proxy, descriptorDefaults),\r\n            setContext: (ctx) => _attachContext(proxy, ctx, subProxy, descriptorDefaults),\r\n            override: (scope) => _attachContext(proxy.override(scope), context, subProxy, descriptorDefaults)\r\n        };\r\n        return new Proxy(cache, {\r\n            deleteProperty(target, prop) {\r\n                delete target[prop];\r\n                delete proxy[prop];\r\n                return true;\r\n            },\r\n            get(target, prop, receiver) {\r\n                return _cached(target, prop,\r\n                    () => _resolveWithContext(target, prop, receiver));\r\n            },\r\n            getOwnPropertyDescriptor(target, prop) {\r\n                return target._descriptors.allKeys\r\n                    ? Reflect.has(proxy, prop) ? {enumerable: true, configurable: true} : undefined\r\n                    : Reflect.getOwnPropertyDescriptor(proxy, prop);\r\n            },\r\n            getPrototypeOf() {\r\n                return Reflect.getPrototypeOf(proxy);\r\n            },\r\n            has(target, prop) {\r\n                return Reflect.has(proxy, prop);\r\n            },\r\n            ownKeys() {\r\n                return Reflect.ownKeys(proxy);\r\n            },\r\n            set(target, prop, value) {\r\n                proxy[prop] = value;\r\n                delete target[prop];\r\n                return true;\r\n            }\r\n        });\r\n    }\r\n\r\n    function _descriptors(proxy, defaults = {scriptable: true, indexable: true}) {\r\n        const {_scriptable = defaults.scriptable, _indexable = defaults.indexable, _allKeys = defaults.allKeys} = proxy;\r\n        return {\r\n            allKeys: _allKeys,\r\n            scriptable: _scriptable,\r\n            indexable: _indexable,\r\n            isScriptable: isFunction(_scriptable) ? _scriptable : () => _scriptable,\r\n            isIndexable: isFunction(_indexable) ? _indexable : () => _indexable\r\n        };\r\n    }\r\n\r\n    const readKey = (prefix, name) => prefix ? prefix + _capitalize(name) : name;\r\n    const needsSubResolver = (prop, value) => isObject(value) && prop !== 'adapters';\r\n\r\n    function _cached(target, prop, resolve) {\r\n        let value = target[prop];\r\n        if (defined(value)) {\r\n            return value;\r\n        }\r\n        value = resolve();\r\n        if (defined(value)) {\r\n            target[prop] = value;\r\n        }\r\n        return value;\r\n    }\r\n\r\n    function _resolveWithContext(target, prop, receiver) {\r\n        const {_proxy, _context, _subProxy, _descriptors: descriptors} = target;\r\n        let value = _proxy[prop];\r\n        if (isFunction(value) && descriptors.isScriptable(prop)) {\r\n            value = _resolveScriptable(prop, value, target, receiver);\r\n        }\r\n        if (isArray(value) && value.length) {\r\n            value = _resolveArray(prop, value, target, descriptors.isIndexable);\r\n        }\r\n        if (needsSubResolver(prop, value)) {\r\n            value = _attachContext(value, _context, _subProxy && _subProxy[prop], descriptors);\r\n        }\r\n        return value;\r\n    }\r\n\r\n    function _resolveScriptable(prop, value, target, receiver) {\r\n        const {_proxy, _context, _subProxy, _stack} = target;\r\n        if (_stack.has(prop)) {\r\n            throw new Error('Recursion detected: ' + [..._stack].join('->') + '->' + prop);\r\n        }\r\n        _stack.add(prop);\r\n        value = value(_context, _subProxy || receiver);\r\n        _stack.delete(prop);\r\n        if (isObject(value)) {\r\n            value = createSubResolver(_proxy._scopes, _proxy, prop, value);\r\n        }\r\n        return value;\r\n    }\r\n\r\n    function _resolveArray(prop, value, target, isIndexable) {\r\n        const {_proxy, _context, _subProxy, _descriptors: descriptors} = target;\r\n        if (defined(_context.index) && isIndexable(prop)) {\r\n            value = value[_context.index % value.length];\r\n        } else if (isObject(value[0])) {\r\n            const arr = value;\r\n            const scopes = _proxy._scopes.filter(s => s !== arr);\r\n            value = [];\r\n            for (const item of arr) {\r\n                const resolver = createSubResolver(scopes, _proxy, prop, item);\r\n                value.push(_attachContext(resolver, _context, _subProxy && _subProxy[prop], descriptors));\r\n            }\r\n        }\r\n        return value;\r\n    }\r\n\r\n    function resolveFallback(fallback, prop, value) {\r\n        return isFunction(fallback) ? fallback(prop, value) : fallback;\r\n    }\r\n\r\n    const getScope = (key, parent) => key === true ? parent\r\n        : typeof key === 'string' ? resolveObjectKey(parent, key) : undefined;\r\n\r\n    function addScopes(set, parentScopes, key, parentFallback) {\r\n        for (const parent of parentScopes) {\r\n            const scope = getScope(key, parent);\r\n            if (scope) {\r\n                set.add(scope);\r\n                const fallback = resolveFallback(scope._fallback, key, scope);\r\n                if (defined(fallback) && fallback !== key && fallback !== parentFallback) {\r\n                    return fallback;\r\n                }\r\n            } else if (scope === false && defined(parentFallback) && key !== parentFallback) {\r\n                return null;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n    function createSubResolver(parentScopes, resolver, prop, value) {\r\n        const rootScopes = resolver._rootScopes;\r\n        const fallback = resolveFallback(resolver._fallback, prop, value);\r\n        const allScopes = [...parentScopes, ...rootScopes];\r\n        const set = new Set();\r\n        const firstParent = parentScopes[0];\r\n        if (isObject(firstParent) && !(prop in firstParent)) {\r\n            set.add(firstParent[prop] = {});\r\n        }\r\n        set.add(value);\r\n        let key = addScopesFromKey(set, allScopes, prop, fallback || prop);\r\n        if (key === null) {\r\n            return false;\r\n        }\r\n        if (defined(fallback) && fallback !== prop) {\r\n            key = addScopesFromKey(set, allScopes, fallback, key);\r\n            if (key === null) {\r\n                return false;\r\n            }\r\n        }\r\n        return _createResolver([...set], [''], rootScopes, fallback);\r\n    }\r\n\r\n    function addScopesFromKey(set, allScopes, key, fallback) {\r\n        while (key) {\r\n            key = addScopes(set, allScopes, key, fallback);\r\n        }\r\n        return key;\r\n    }\r\n\r\n    function _resolveWithPrefixes(prop, prefixes, scopes, proxy) {\r\n        let value;\r\n        for (const prefix of prefixes) {\r\n            value = _resolve(readKey(prefix, prop), scopes);\r\n            if (defined(value)) {\r\n                return needsSubResolver(prop, value)\r\n                    ? createSubResolver(scopes, proxy, prop, value)\r\n                    : value;\r\n            }\r\n        }\r\n    }\r\n\r\n    function _resolve(key, scopes) {\r\n        for (const scope of scopes) {\r\n            if (!scope) {\r\n                continue;\r\n            }\r\n            const value = scope[key];\r\n            if (defined(value)) {\r\n                return value;\r\n            }\r\n        }\r\n    }\r\n\r\n    function getKeysFromAllScopes(target) {\r\n        let keys = target._keys;\r\n        if (!keys) {\r\n            keys = target._keys = resolveKeysFromAllScopes(target._scopes);\r\n        }\r\n        return keys;\r\n    }\r\n\r\n    function resolveKeysFromAllScopes(scopes) {\r\n        const set = new Set();\r\n        for (const scope of scopes) {\r\n            for (const key of Object.keys(scope).filter(k => !k.startsWith('_'))) {\r\n                set.add(key);\r\n            }\r\n        }\r\n        return [...set];\r\n    }\r\n\r\n    const EPSILON = Number.EPSILON || 1e-14;\r\n    const getPoint = (points, i) => i < points.length && !points[i].skip && points[i];\r\n\r\n    function splineCurve(firstPoint, middlePoint, afterPoint, t) {\r\n        const previous = firstPoint.skip ? middlePoint : firstPoint;\r\n        const current = middlePoint;\r\n        const next = afterPoint.skip ? middlePoint : afterPoint;\r\n        const d01 = distanceBetweenPoints(current, previous);\r\n        const d12 = distanceBetweenPoints(next, current);\r\n        let s01 = d01 / (d01 + d12);\r\n        let s12 = d12 / (d01 + d12);\r\n        s01 = isNaN(s01) ? 0 : s01;\r\n        s12 = isNaN(s12) ? 0 : s12;\r\n        const fa = t * s01;\r\n        const fb = t * s12;\r\n        return {\r\n            previous: {\r\n                x: current.x - fa * (next.x - previous.x),\r\n                y: current.y - fa * (next.y - previous.y)\r\n            },\r\n            next: {\r\n                x: current.x + fb * (next.x - previous.x),\r\n                y: current.y + fb * (next.y - previous.y)\r\n            }\r\n        };\r\n    }\r\n\r\n    function monotoneAdjust(points, deltaK, mK) {\r\n        const pointsLen = points.length;\r\n        let alphaK, betaK, tauK, squaredMagnitude, pointCurrent;\r\n        let pointAfter = getPoint(points, 0);\r\n        for (let i = 0; i < pointsLen - 1; ++i) {\r\n            pointCurrent = pointAfter;\r\n            pointAfter = getPoint(points, i + 1);\r\n            if (!pointCurrent || !pointAfter) {\r\n                continue;\r\n            }\r\n            if (almostEquals(deltaK[i], 0, EPSILON)) {\r\n                mK[i] = mK[i + 1] = 0;\r\n                continue;\r\n            }\r\n            alphaK = mK[i] / deltaK[i];\r\n            betaK = mK[i + 1] / deltaK[i];\r\n            squaredMagnitude = Math.pow(alphaK, 2) + Math.pow(betaK, 2);\r\n            if (squaredMagnitude <= 9) {\r\n                continue;\r\n            }\r\n            tauK = 3 / Math.sqrt(squaredMagnitude);\r\n            mK[i] = alphaK * tauK * deltaK[i];\r\n            mK[i + 1] = betaK * tauK * deltaK[i];\r\n        }\r\n    }\r\n\r\n    function monotoneCompute(points, mK) {\r\n        const pointsLen = points.length;\r\n        let deltaX, pointBefore, pointCurrent;\r\n        let pointAfter = getPoint(points, 0);\r\n        for (let i = 0; i < pointsLen; ++i) {\r\n            pointBefore = pointCurrent;\r\n            pointCurrent = pointAfter;\r\n            pointAfter = getPoint(points, i + 1);\r\n            if (!pointCurrent) {\r\n                continue;\r\n            }\r\n            const {x, y} = pointCurrent;\r\n            if (pointBefore) {\r\n                deltaX = (x - pointBefore.x) / 3;\r\n                pointCurrent.cp1x = x - deltaX;\r\n                pointCurrent.cp1y = y - deltaX * mK[i];\r\n            }\r\n            if (pointAfter) {\r\n                deltaX = (pointAfter.x - x) / 3;\r\n                pointCurrent.cp2x = x + deltaX;\r\n                pointCurrent.cp2y = y + deltaX * mK[i];\r\n            }\r\n        }\r\n    }\r\n\r\n    function splineCurveMonotone(points) {\r\n        const pointsLen = points.length;\r\n        const deltaK = Array(pointsLen).fill(0);\r\n        const mK = Array(pointsLen);\r\n        let i, pointBefore, pointCurrent;\r\n        let pointAfter = getPoint(points, 0);\r\n        for (i = 0; i < pointsLen; ++i) {\r\n            pointBefore = pointCurrent;\r\n            pointCurrent = pointAfter;\r\n            pointAfter = getPoint(points, i + 1);\r\n            if (!pointCurrent) {\r\n                continue;\r\n            }\r\n            if (pointAfter) {\r\n                const slopeDeltaX = (pointAfter.x - pointCurrent.x);\r\n                deltaK[i] = slopeDeltaX !== 0 ? (pointAfter.y - pointCurrent.y) / slopeDeltaX : 0;\r\n            }\r\n            mK[i] = !pointBefore ? deltaK[i]\r\n                : !pointAfter ? deltaK[i - 1]\r\n                    : (sign(deltaK[i - 1]) !== sign(deltaK[i])) ? 0\r\n                        : (deltaK[i - 1] + deltaK[i]) / 2;\r\n        }\r\n        monotoneAdjust(points, deltaK, mK);\r\n        monotoneCompute(points, mK);\r\n    }\r\n\r\n    function capControlPoint(pt, min, max) {\r\n        return Math.max(Math.min(pt, max), min);\r\n    }\r\n\r\n    function capBezierPoints(points, area) {\r\n        let i, ilen, point, inArea, inAreaPrev;\r\n        let inAreaNext = _isPointInArea(points[0], area);\r\n        for (i = 0, ilen = points.length; i < ilen; ++i) {\r\n            inAreaPrev = inArea;\r\n            inArea = inAreaNext;\r\n            inAreaNext = i < ilen - 1 && _isPointInArea(points[i + 1], area);\r\n            if (!inArea) {\r\n                continue;\r\n            }\r\n            point = points[i];\r\n            if (inAreaPrev) {\r\n                point.cp1x = capControlPoint(point.cp1x, area.left, area.right);\r\n                point.cp1y = capControlPoint(point.cp1y, area.top, area.bottom);\r\n            }\r\n            if (inAreaNext) {\r\n                point.cp2x = capControlPoint(point.cp2x, area.left, area.right);\r\n                point.cp2y = capControlPoint(point.cp2y, area.top, area.bottom);\r\n            }\r\n        }\r\n    }\r\n\r\n    function _updateBezierControlPoints(points, options, area, loop) {\r\n        let i, ilen, point, controlPoints;\r\n        if (options.spanGaps) {\r\n            points = points.filter((pt) => !pt.skip);\r\n        }\r\n        if (options.cubicInterpolationMode === 'monotone') {\r\n            splineCurveMonotone(points);\r\n        } else {\r\n            let prev = loop ? points[points.length - 1] : points[0];\r\n            for (i = 0, ilen = points.length; i < ilen; ++i) {\r\n                point = points[i];\r\n                controlPoints = splineCurve(\r\n                    prev,\r\n                    point,\r\n                    points[Math.min(i + 1, ilen - (loop ? 0 : 1)) % ilen],\r\n                    options.tension\r\n                );\r\n                point.cp1x = controlPoints.previous.x;\r\n                point.cp1y = controlPoints.previous.y;\r\n                point.cp2x = controlPoints.next.x;\r\n                point.cp2y = controlPoints.next.y;\r\n                prev = point;\r\n            }\r\n        }\r\n        if (options.capBezierPoints) {\r\n            capBezierPoints(points, area);\r\n        }\r\n    }\r\n\r\n    function _pointInLine(p1, p2, t, mode) {\r\n        return {\r\n            x: p1.x + t * (p2.x - p1.x),\r\n            y: p1.y + t * (p2.y - p1.y)\r\n        };\r\n    }\r\n\r\n    function _steppedInterpolation(p1, p2, t, mode) {\r\n        return {\r\n            x: p1.x + t * (p2.x - p1.x),\r\n            y: mode === 'middle' ? t < 0.5 ? p1.y : p2.y\r\n                : mode === 'after' ? t < 1 ? p1.y : p2.y\r\n                    : t > 0 ? p2.y : p1.y\r\n        };\r\n    }\r\n\r\n    function _bezierInterpolation(p1, p2, t, mode) {\r\n        const cp1 = {x: p1.cp2x, y: p1.cp2y};\r\n        const cp2 = {x: p2.cp1x, y: p2.cp1y};\r\n        const a = _pointInLine(p1, cp1, t);\r\n        const b = _pointInLine(cp1, cp2, t);\r\n        const c = _pointInLine(cp2, p2, t);\r\n        const d = _pointInLine(a, b, t);\r\n        const e = _pointInLine(b, c, t);\r\n        return _pointInLine(d, e, t);\r\n    }\r\n\r\n    const getRightToLeftAdapter = function (rectX, width) {\r\n        return {\r\n            x(x) {\r\n                return rectX + rectX + width - x;\r\n            },\r\n            setWidth(w) {\r\n                width = w;\r\n            },\r\n            textAlign(align) {\r\n                if (align === 'center') {\r\n                    return align;\r\n                }\r\n                return align === 'right' ? 'left' : 'right';\r\n            },\r\n            xPlus(x, value) {\r\n                return x - value;\r\n            },\r\n            leftForLtr(x, itemWidth) {\r\n                return x - itemWidth;\r\n            },\r\n        };\r\n    };\r\n    const getLeftToRightAdapter = function () {\r\n        return {\r\n            x(x) {\r\n                return x;\r\n            },\r\n            setWidth(w) {\r\n            },\r\n            textAlign(align) {\r\n                return align;\r\n            },\r\n            xPlus(x, value) {\r\n                return x + value;\r\n            },\r\n            leftForLtr(x, _itemWidth) {\r\n                return x;\r\n            },\r\n        };\r\n    };\r\n\r\n    function getRtlAdapter(rtl, rectX, width) {\r\n        return rtl ? getRightToLeftAdapter(rectX, width) : getLeftToRightAdapter();\r\n    }\r\n\r\n    function overrideTextDirection(ctx, direction) {\r\n        let style, original;\r\n        if (direction === 'ltr' || direction === 'rtl') {\r\n            style = ctx.canvas.style;\r\n            original = [\r\n                style.getPropertyValue('direction'),\r\n                style.getPropertyPriority('direction'),\r\n            ];\r\n            style.setProperty('direction', direction, 'important');\r\n            ctx.prevTextDirection = original;\r\n        }\r\n    }\r\n\r\n    function restoreTextDirection(ctx, original) {\r\n        if (original !== undefined) {\r\n            delete ctx.prevTextDirection;\r\n            ctx.canvas.style.setProperty('direction', original[0], original[1]);\r\n        }\r\n    }\r\n\r\n    function propertyFn(property) {\r\n        if (property === 'angle') {\r\n            return {\r\n                between: _angleBetween,\r\n                compare: _angleDiff,\r\n                normalize: _normalizeAngle,\r\n            };\r\n        }\r\n        return {\r\n            between: (n, s, e) => n >= s && n <= e,\r\n            compare: (a, b) => a - b,\r\n            normalize: x => x\r\n        };\r\n    }\r\n\r\n    function makeSubSegment(start, end, loop, count) {\r\n        return {\r\n            start: start % count,\r\n            end: end % count,\r\n            loop: loop && (end - start + 1) % count === 0\r\n        };\r\n    }\r\n\r\n    function getSegment(segment, points, bounds) {\r\n        const {property, start: startBound, end: endBound} = bounds;\r\n        const {between, normalize} = propertyFn(property);\r\n        const count = points.length;\r\n        let {start, end, loop} = segment;\r\n        let i, ilen;\r\n        if (loop) {\r\n            start += count;\r\n            end += count;\r\n            for (i = 0, ilen = count; i < ilen; ++i) {\r\n                if (!between(normalize(points[start % count][property]), startBound, endBound)) {\r\n                    break;\r\n                }\r\n                start--;\r\n                end--;\r\n            }\r\n            start %= count;\r\n            end %= count;\r\n        }\r\n        if (end < start) {\r\n            end += count;\r\n        }\r\n        return {start, end, loop};\r\n    }\r\n\r\n    function _boundSegment(segment, points, bounds) {\r\n        if (!bounds) {\r\n            return [segment];\r\n        }\r\n        const {property, start: startBound, end: endBound} = bounds;\r\n        const count = points.length;\r\n        const {compare, between, normalize} = propertyFn(property);\r\n        const {start, end, loop} = getSegment(segment, points, bounds);\r\n        const result = [];\r\n        let inside = false;\r\n        let subStart = null;\r\n        let value, point, prevValue;\r\n        const startIsBefore = () => between(startBound, prevValue, value) && compare(startBound, prevValue) !== 0;\r\n        const endIsBefore = () => compare(endBound, value) === 0 || between(endBound, prevValue, value);\r\n        const shouldStart = () => inside || startIsBefore();\r\n        const shouldStop = () => !inside || endIsBefore();\r\n        for (let i = start, prev = start; i <= end; ++i) {\r\n            point = points[i % count];\r\n            if (point.skip) {\r\n                continue;\r\n            }\r\n            value = normalize(point[property]);\r\n            inside = between(value, startBound, endBound);\r\n            if (subStart === null && shouldStart()) {\r\n                subStart = compare(value, startBound) === 0 ? i : prev;\r\n            }\r\n            if (subStart !== null && shouldStop()) {\r\n                result.push(makeSubSegment(subStart, i, loop, count));\r\n                subStart = null;\r\n            }\r\n            prev = i;\r\n            prevValue = value;\r\n        }\r\n        if (subStart !== null) {\r\n            result.push(makeSubSegment(subStart, end, loop, count));\r\n        }\r\n        return result;\r\n    }\r\n\r\n    function _boundSegments(line, bounds) {\r\n        const result = [];\r\n        const segments = line.segments;\r\n        for (let i = 0; i < segments.length; i++) {\r\n            const sub = _boundSegment(segments[i], line.points, bounds);\r\n            if (sub.length) {\r\n                result.push(...sub);\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n\r\n    function findStartAndEnd(points, count, loop, spanGaps) {\r\n        let start = 0;\r\n        let end = count - 1;\r\n        if (loop && !spanGaps) {\r\n            while (start < count && !points[start].skip) {\r\n                start++;\r\n            }\r\n        }\r\n        while (start < count && points[start].skip) {\r\n            start++;\r\n        }\r\n        start %= count;\r\n        if (loop) {\r\n            end += start;\r\n        }\r\n        while (end > start && points[end % count].skip) {\r\n            end--;\r\n        }\r\n        end %= count;\r\n        return {start, end};\r\n    }\r\n\r\n    function solidSegments(points, start, max, loop) {\r\n        const count = points.length;\r\n        const result = [];\r\n        let last = start;\r\n        let prev = points[start];\r\n        let end;\r\n        for (end = start + 1; end <= max; ++end) {\r\n            const cur = points[end % count];\r\n            if (cur.skip || cur.stop) {\r\n                if (!prev.skip) {\r\n                    loop = false;\r\n                    result.push({start: start % count, end: (end - 1) % count, loop});\r\n                    start = last = cur.stop ? end : null;\r\n                }\r\n            } else {\r\n                last = end;\r\n                if (prev.skip) {\r\n                    start = end;\r\n                }\r\n            }\r\n            prev = cur;\r\n        }\r\n        if (last !== null) {\r\n            result.push({start: start % count, end: last % count, loop});\r\n        }\r\n        return result;\r\n    }\r\n\r\n    function _computeSegments(line) {\r\n        const points = line.points;\r\n        const spanGaps = line.options.spanGaps;\r\n        const count = points.length;\r\n        if (!count) {\r\n            return [];\r\n        }\r\n        const loop = !!line._loop;\r\n        const {start, end} = findStartAndEnd(points, count, loop, spanGaps);\r\n        if (spanGaps === true) {\r\n            return [{start, end, loop}];\r\n        }\r\n        const max = end < start ? end + count : end;\r\n        const completeLoop = !!line._fullLoop && start === 0 && end === count - 1;\r\n        return solidSegments(points, start, max, completeLoop);\r\n    }\r\n\r\n    var helpers = /*#__PURE__*/Object.freeze({\r\n        __proto__: null,\r\n        easingEffects: effects,\r\n        color: color,\r\n        getHoverColor: getHoverColor,\r\n        noop: noop,\r\n        uid: uid,\r\n        isNullOrUndef: isNullOrUndef,\r\n        isArray: isArray,\r\n        isObject: isObject,\r\n        isFinite: isNumberFinite,\r\n        finiteOrDefault: finiteOrDefault,\r\n        valueOrDefault: valueOrDefault,\r\n        toPercentage: toPercentage,\r\n        toDimension: toDimension,\r\n        callback: callback,\r\n        each: each,\r\n        _elementsEqual: _elementsEqual,\r\n        clone: clone,\r\n        _merger: _merger,\r\n        merge: merge,\r\n        mergeIf: mergeIf,\r\n        _mergerIf: _mergerIf,\r\n        _deprecated: _deprecated,\r\n        resolveObjectKey: resolveObjectKey,\r\n        _capitalize: _capitalize,\r\n        defined: defined,\r\n        isFunction: isFunction,\r\n        toFontString: toFontString,\r\n        _measureText: _measureText,\r\n        _longestText: _longestText,\r\n        _alignPixel: _alignPixel,\r\n        clearCanvas: clearCanvas,\r\n        drawPoint: drawPoint,\r\n        _isPointInArea: _isPointInArea,\r\n        clipArea: clipArea,\r\n        unclipArea: unclipArea,\r\n        _steppedLineTo: _steppedLineTo,\r\n        _bezierCurveTo: _bezierCurveTo,\r\n        renderText: renderText,\r\n        _lookup: _lookup,\r\n        _lookupByKey: _lookupByKey,\r\n        _rlookupByKey: _rlookupByKey,\r\n        _filterBetween: _filterBetween,\r\n        listenArrayEvents: listenArrayEvents,\r\n        unlistenArrayEvents: unlistenArrayEvents,\r\n        _arrayUnique: _arrayUnique,\r\n        _createResolver: _createResolver,\r\n        _attachContext: _attachContext,\r\n        _descriptors: _descriptors,\r\n        splineCurve: splineCurve,\r\n        splineCurveMonotone: splineCurveMonotone,\r\n        _updateBezierControlPoints: _updateBezierControlPoints,\r\n        _getParentNode: _getParentNode,\r\n        getStyle: getStyle,\r\n        getRelativePosition: getRelativePosition$1,\r\n        getMaximumSize: getMaximumSize,\r\n        retinaScale: retinaScale,\r\n        supportsEventListenerOptions: supportsEventListenerOptions,\r\n        readUsedSize: readUsedSize,\r\n        fontString: fontString,\r\n        requestAnimFrame: requestAnimFrame,\r\n        throttled: throttled,\r\n        debounce: debounce,\r\n        _toLeftRightCenter: _toLeftRightCenter,\r\n        _alignStartEnd: _alignStartEnd,\r\n        _textX: _textX,\r\n        _pointInLine: _pointInLine,\r\n        _steppedInterpolation: _steppedInterpolation,\r\n        _bezierInterpolation: _bezierInterpolation,\r\n        formatNumber: formatNumber,\r\n        toLineHeight: toLineHeight,\r\n        toTRBL: toTRBL,\r\n        toTRBLCorners: toTRBLCorners,\r\n        toPadding: toPadding,\r\n        toFont: toFont,\r\n        resolve: resolve,\r\n        _addGrace: _addGrace,\r\n        PI: PI,\r\n        TAU: TAU,\r\n        PITAU: PITAU,\r\n        INFINITY: INFINITY,\r\n        RAD_PER_DEG: RAD_PER_DEG,\r\n        HALF_PI: HALF_PI,\r\n        QUARTER_PI: QUARTER_PI,\r\n        TWO_THIRDS_PI: TWO_THIRDS_PI,\r\n        log10: log10,\r\n        sign: sign,\r\n        niceNum: niceNum,\r\n        _factorize: _factorize,\r\n        isNumber: isNumber,\r\n        almostEquals: almostEquals,\r\n        almostWhole: almostWhole,\r\n        _setMinAndMaxByKey: _setMinAndMaxByKey,\r\n        toRadians: toRadians,\r\n        toDegrees: toDegrees,\r\n        _decimalPlaces: _decimalPlaces,\r\n        getAngleFromPoint: getAngleFromPoint,\r\n        distanceBetweenPoints: distanceBetweenPoints,\r\n        _angleDiff: _angleDiff,\r\n        _normalizeAngle: _normalizeAngle,\r\n        _angleBetween: _angleBetween,\r\n        _limitValue: _limitValue,\r\n        _int16Range: _int16Range,\r\n        getRtlAdapter: getRtlAdapter,\r\n        overrideTextDirection: overrideTextDirection,\r\n        restoreTextDirection: restoreTextDirection,\r\n        _boundSegment: _boundSegment,\r\n        _boundSegments: _boundSegments,\r\n        _computeSegments: _computeSegments\r\n    });\r\n\r\n    class TypedRegistry {\r\n        constructor(type, scope, override) {\r\n            this.type = type;\r\n            this.scope = scope;\r\n            this.override = override;\r\n            this.items = Object.create(null);\r\n        }\r\n\r\n        isForType(type) {\r\n            return Object.prototype.isPrototypeOf.call(this.type.prototype, type.prototype);\r\n        }\r\n\r\n        register(item) {\r\n            const me = this;\r\n            const proto = Object.getPrototypeOf(item);\r\n            let parentScope;\r\n            if (isIChartComponent(proto)) {\r\n                parentScope = me.register(proto);\r\n            }\r\n            const items = me.items;\r\n            const id = item.id;\r\n            const scope = me.scope + '.' + id;\r\n            if (!id) {\r\n                throw new Error('class does not have id: ' + item);\r\n            }\r\n            if (id in items) {\r\n                return scope;\r\n            }\r\n            items[id] = item;\r\n            registerDefaults(item, scope, parentScope);\r\n            if (me.override) {\r\n                defaults.override(item.id, item.overrides);\r\n            }\r\n            return scope;\r\n        }\r\n\r\n        get(id) {\r\n            return this.items[id];\r\n        }\r\n\r\n        unregister(item) {\r\n            const items = this.items;\r\n            const id = item.id;\r\n            const scope = this.scope;\r\n            if (id in items) {\r\n                delete items[id];\r\n            }\r\n            if (scope && id in defaults[scope]) {\r\n                delete defaults[scope][id];\r\n                if (this.override) {\r\n                    delete overrides[id];\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    function registerDefaults(item, scope, parentScope) {\r\n        const itemDefaults = merge(Object.create(null), [\r\n            parentScope ? defaults.get(parentScope) : {},\r\n            defaults.get(scope),\r\n            item.defaults\r\n        ]);\r\n        defaults.set(scope, itemDefaults);\r\n        if (item.defaultRoutes) {\r\n            routeDefaults(scope, item.defaultRoutes);\r\n        }\r\n        if (item.descriptors) {\r\n            defaults.describe(scope, item.descriptors);\r\n        }\r\n    }\r\n\r\n    function routeDefaults(scope, routes) {\r\n        Object.keys(routes).forEach(property => {\r\n            const propertyParts = property.split('.');\r\n            const sourceName = propertyParts.pop();\r\n            const sourceScope = [scope].concat(propertyParts).join('.');\r\n            const parts = routes[property].split('.');\r\n            const targetName = parts.pop();\r\n            const targetScope = parts.join('.');\r\n            defaults.route(sourceScope, sourceName, targetScope, targetName);\r\n        });\r\n    }\r\n\r\n    function isIChartComponent(proto) {\r\n        return 'id' in proto && 'defaults' in proto;\r\n    }\r\n\r\n    class Registry {\r\n        constructor() {\r\n            this.controllers = new TypedRegistry(DatasetController, 'datasets', true);\r\n            this.elements = new TypedRegistry(Element, 'elements');\r\n            this.plugins = new TypedRegistry(Object, 'plugins');\r\n            this.scales = new TypedRegistry(Scale, 'scales');\r\n            this._typedRegistries = [this.controllers, this.scales, this.elements];\r\n        }\r\n\r\n        add(...args) {\r\n            this._each('register', args);\r\n        }\r\n\r\n        remove(...args) {\r\n            this._each('unregister', args);\r\n        }\r\n\r\n        addControllers(...args) {\r\n            this._each('register', args, this.controllers);\r\n        }\r\n\r\n        addElements(...args) {\r\n            this._each('register', args, this.elements);\r\n        }\r\n\r\n        addPlugins(...args) {\r\n            this._each('register', args, this.plugins);\r\n        }\r\n\r\n        addScales(...args) {\r\n            this._each('register', args, this.scales);\r\n        }\r\n\r\n        getController(id) {\r\n            return this._get(id, this.controllers, 'controller');\r\n        }\r\n\r\n        getElement(id) {\r\n            return this._get(id, this.elements, 'element');\r\n        }\r\n\r\n        getPlugin(id) {\r\n            return this._get(id, this.plugins, 'plugin');\r\n        }\r\n\r\n        getScale(id) {\r\n            return this._get(id, this.scales, 'scale');\r\n        }\r\n\r\n        removeControllers(...args) {\r\n            this._each('unregister', args, this.controllers);\r\n        }\r\n\r\n        removeElements(...args) {\r\n            this._each('unregister', args, this.elements);\r\n        }\r\n\r\n        removePlugins(...args) {\r\n            this._each('unregister', args, this.plugins);\r\n        }\r\n\r\n        removeScales(...args) {\r\n            this._each('unregister', args, this.scales);\r\n        }\r\n\r\n        _each(method, args, typedRegistry) {\r\n            const me = this;\r\n            [...args].forEach(arg => {\r\n                const reg = typedRegistry || me._getRegistryForType(arg);\r\n                if (typedRegistry || reg.isForType(arg) || (reg === me.plugins && arg.id)) {\r\n                    me._exec(method, reg, arg);\r\n                } else {\r\n                    each(arg, item => {\r\n                        const itemReg = typedRegistry || me._getRegistryForType(item);\r\n                        me._exec(method, itemReg, item);\r\n                    });\r\n                }\r\n            });\r\n        }\r\n\r\n        _exec(method, registry, component) {\r\n            const camelMethod = _capitalize(method);\r\n            callback(component['before' + camelMethod], [], component);\r\n            registry[method](component);\r\n            callback(component['after' + camelMethod], [], component);\r\n        }\r\n\r\n        _getRegistryForType(type) {\r\n            for (let i = 0; i < this._typedRegistries.length; i++) {\r\n                const reg = this._typedRegistries[i];\r\n                if (reg.isForType(type)) {\r\n                    return reg;\r\n                }\r\n            }\r\n            return this.plugins;\r\n        }\r\n\r\n        _get(id, typedRegistry, type) {\r\n            const item = typedRegistry.get(id);\r\n            if (item === undefined) {\r\n                throw new Error('\"' + id + '\" is not a registered ' + type + '.');\r\n            }\r\n            return item;\r\n        }\r\n    }\r\n\r\n    var registry = new Registry();\r\n\r\n    class PluginService {\r\n        constructor() {\r\n            this._init = [];\r\n        }\r\n\r\n        notify(chart, hook, args) {\r\n            const me = this;\r\n            if (hook === 'beforeInit') {\r\n                me._init = me._createDescriptors(chart, true);\r\n                me._notify(me._init, chart, 'install');\r\n            }\r\n            const descriptors = me._descriptors(chart);\r\n            const result = me._notify(descriptors, chart, hook, args);\r\n            if (hook === 'destroy') {\r\n                me._notify(descriptors, chart, 'stop');\r\n                me._notify(me._init, chart, 'uninstall');\r\n            }\r\n            return result;\r\n        }\r\n\r\n        _notify(descriptors, chart, hook, args) {\r\n            args = args || {};\r\n            for (const descriptor of descriptors) {\r\n                const plugin = descriptor.plugin;\r\n                const method = plugin[hook];\r\n                const params = [chart, args, descriptor.options];\r\n                if (callback(method, params, plugin) === false && args.cancelable) {\r\n                    return false;\r\n                }\r\n            }\r\n            return true;\r\n        }\r\n\r\n        invalidate() {\r\n            if (!isNullOrUndef(this._cache)) {\r\n                this._oldCache = this._cache;\r\n                this._cache = undefined;\r\n            }\r\n        }\r\n\r\n        _descriptors(chart) {\r\n            if (this._cache) {\r\n                return this._cache;\r\n            }\r\n            const descriptors = this._cache = this._createDescriptors(chart);\r\n            this._notifyStateChanges(chart);\r\n            return descriptors;\r\n        }\r\n\r\n        _createDescriptors(chart, all) {\r\n            const config = chart && chart.config;\r\n            const options = valueOrDefault(config.options && config.options.plugins, {});\r\n            const plugins = allPlugins(config);\r\n            return options === false && !all ? [] : createDescriptors(chart, plugins, options, all);\r\n        }\r\n\r\n        _notifyStateChanges(chart) {\r\n            const previousDescriptors = this._oldCache || [];\r\n            const descriptors = this._cache;\r\n            const diff = (a, b) => a.filter(x => !b.some(y => x.plugin.id === y.plugin.id));\r\n            this._notify(diff(previousDescriptors, descriptors), chart, 'stop');\r\n            this._notify(diff(descriptors, previousDescriptors), chart, 'start');\r\n        }\r\n    }\r\n\r\n    function allPlugins(config) {\r\n        const plugins = [];\r\n        const keys = Object.keys(registry.plugins.items);\r\n        for (let i = 0; i < keys.length; i++) {\r\n            plugins.push(registry.getPlugin(keys[i]));\r\n        }\r\n        const local = config.plugins || [];\r\n        for (let i = 0; i < local.length; i++) {\r\n            const plugin = local[i];\r\n            if (plugins.indexOf(plugin) === -1) {\r\n                plugins.push(plugin);\r\n            }\r\n        }\r\n        return plugins;\r\n    }\r\n\r\n    function getOpts(options, all) {\r\n        if (!all && options === false) {\r\n            return null;\r\n        }\r\n        if (options === true) {\r\n            return {};\r\n        }\r\n        return options;\r\n    }\r\n\r\n    function createDescriptors(chart, plugins, options, all) {\r\n        const result = [];\r\n        const context = chart.getContext();\r\n        for (let i = 0; i < plugins.length; i++) {\r\n            const plugin = plugins[i];\r\n            const id = plugin.id;\r\n            const opts = getOpts(options[id], all);\r\n            if (opts === null) {\r\n                continue;\r\n            }\r\n            result.push({\r\n                plugin,\r\n                options: pluginOpts(chart.config, plugin, opts, context)\r\n            });\r\n        }\r\n        return result;\r\n    }\r\n\r\n    function pluginOpts(config, plugin, opts, context) {\r\n        const keys = config.pluginScopeKeys(plugin);\r\n        const scopes = config.getOptionScopes(opts, keys);\r\n        return config.createResolver(scopes, context, [''], {scriptable: false, indexable: false, allKeys: true});\r\n    }\r\n\r\n    function getIndexAxis(type, options) {\r\n        const datasetDefaults = defaults.datasets[type] || {};\r\n        const datasetOptions = (options.datasets || {})[type] || {};\r\n        return datasetOptions.indexAxis || options.indexAxis || datasetDefaults.indexAxis || 'x';\r\n    }\r\n\r\n    function getAxisFromDefaultScaleID(id, indexAxis) {\r\n        let axis = id;\r\n        if (id === '_index_') {\r\n            axis = indexAxis;\r\n        } else if (id === '_value_') {\r\n            axis = indexAxis === 'x' ? 'y' : 'x';\r\n        }\r\n        return axis;\r\n    }\r\n\r\n    function getDefaultScaleIDFromAxis(axis, indexAxis) {\r\n        return axis === indexAxis ? '_index_' : '_value_';\r\n    }\r\n\r\n    function axisFromPosition(position) {\r\n        if (position === 'top' || position === 'bottom') {\r\n            return 'x';\r\n        }\r\n        if (position === 'left' || position === 'right') {\r\n            return 'y';\r\n        }\r\n    }\r\n\r\n    function determineAxis(id, scaleOptions) {\r\n        if (id === 'x' || id === 'y') {\r\n            return id;\r\n        }\r\n        return scaleOptions.axis || axisFromPosition(scaleOptions.position) || id.charAt(0).toLowerCase();\r\n    }\r\n\r\n    function mergeScaleConfig(config, options) {\r\n        const chartDefaults = overrides[config.type] || {scales: {}};\r\n        const configScales = options.scales || {};\r\n        const chartIndexAxis = getIndexAxis(config.type, options);\r\n        const firstIDs = Object.create(null);\r\n        const scales = Object.create(null);\r\n        Object.keys(configScales).forEach(id => {\r\n            const scaleConf = configScales[id];\r\n            const axis = determineAxis(id, scaleConf);\r\n            const defaultId = getDefaultScaleIDFromAxis(axis, chartIndexAxis);\r\n            const defaultScaleOptions = chartDefaults.scales || {};\r\n            firstIDs[axis] = firstIDs[axis] || id;\r\n            scales[id] = mergeIf(Object.create(null), [{axis}, scaleConf, defaultScaleOptions[axis], defaultScaleOptions[defaultId]]);\r\n        });\r\n        config.data.datasets.forEach(dataset => {\r\n            const type = dataset.type || config.type;\r\n            const indexAxis = dataset.indexAxis || getIndexAxis(type, options);\r\n            const datasetDefaults = overrides[type] || {};\r\n            const defaultScaleOptions = datasetDefaults.scales || {};\r\n            Object.keys(defaultScaleOptions).forEach(defaultID => {\r\n                const axis = getAxisFromDefaultScaleID(defaultID, indexAxis);\r\n                const id = dataset[axis + 'AxisID'] || firstIDs[axis] || axis;\r\n                scales[id] = scales[id] || Object.create(null);\r\n                mergeIf(scales[id], [{axis}, configScales[id], defaultScaleOptions[defaultID]]);\r\n            });\r\n        });\r\n        Object.keys(scales).forEach(key => {\r\n            const scale = scales[key];\r\n            mergeIf(scale, [defaults.scales[scale.type], defaults.scale]);\r\n        });\r\n        return scales;\r\n    }\r\n\r\n    function initOptions(config) {\r\n        const options = config.options || (config.options = {});\r\n        options.plugins = valueOrDefault(options.plugins, {});\r\n        options.scales = mergeScaleConfig(config, options);\r\n    }\r\n\r\n    function initConfig(config) {\r\n        config = config || {};\r\n        const data = config.data = config.data || {datasets: [], labels: []};\r\n        data.datasets = data.datasets || [];\r\n        data.labels = data.labels || [];\r\n        initOptions(config);\r\n        return config;\r\n    }\r\n\r\n    const keyCache = new Map();\r\n    const keysCached = new Set();\r\n\r\n    function cachedKeys(cacheKey, generate) {\r\n        let keys = keyCache.get(cacheKey);\r\n        if (!keys) {\r\n            keys = generate();\r\n            keyCache.set(cacheKey, keys);\r\n            keysCached.add(keys);\r\n        }\r\n        return keys;\r\n    }\r\n\r\n    const addIfFound = (set, obj, key) => {\r\n        const opts = resolveObjectKey(obj, key);\r\n        if (opts !== undefined) {\r\n            set.add(opts);\r\n        }\r\n    };\r\n\r\n    class Config {\r\n        constructor(config) {\r\n            this._config = initConfig(config);\r\n            this._scopeCache = new Map();\r\n            this._resolverCache = new Map();\r\n        }\r\n\r\n        get type() {\r\n            return this._config.type;\r\n        }\r\n\r\n        set type(type) {\r\n            this._config.type = type;\r\n        }\r\n\r\n        get data() {\r\n            return this._config.data;\r\n        }\r\n\r\n        set data(data) {\r\n            this._config.data = data;\r\n        }\r\n\r\n        get options() {\r\n            return this._config.options;\r\n        }\r\n\r\n        set options(options) {\r\n            this._config.options = options;\r\n        }\r\n\r\n        get plugins() {\r\n            return this._config.plugins;\r\n        }\r\n\r\n        update() {\r\n            const config = this._config;\r\n            this.clearCache();\r\n            initOptions(config);\r\n        }\r\n\r\n        clearCache() {\r\n            this._scopeCache.clear();\r\n            this._resolverCache.clear();\r\n        }\r\n\r\n        datasetScopeKeys(datasetType) {\r\n            return cachedKeys(datasetType,\r\n                () => [[\r\n                    `datasets.${datasetType}`,\r\n                    ''\r\n                ]]);\r\n        }\r\n\r\n        datasetAnimationScopeKeys(datasetType, transition) {\r\n            return cachedKeys(`${datasetType}.transition.${transition}`,\r\n                () => [\r\n                    [\r\n                        `datasets.${datasetType}.transitions.${transition}`,\r\n                        `transitions.${transition}`,\r\n                    ],\r\n                    [\r\n                        `datasets.${datasetType}`,\r\n                        ''\r\n                    ]\r\n                ]);\r\n        }\r\n\r\n        datasetElementScopeKeys(datasetType, elementType) {\r\n            return cachedKeys(`${datasetType}-${elementType}`,\r\n                () => [[\r\n                    `datasets.${datasetType}.elements.${elementType}`,\r\n                    `datasets.${datasetType}`,\r\n                    `elements.${elementType}`,\r\n                    ''\r\n                ]]);\r\n        }\r\n\r\n        pluginScopeKeys(plugin) {\r\n            const id = plugin.id;\r\n            const type = this.type;\r\n            return cachedKeys(`${type}-plugin-${id}`,\r\n                () => [[\r\n                    `plugins.${id}`,\r\n                    ...plugin.additionalOptionScopes || [],\r\n                ]]);\r\n        }\r\n\r\n        _cachedScopes(mainScope, resetCache) {\r\n            const _scopeCache = this._scopeCache;\r\n            let cache = _scopeCache.get(mainScope);\r\n            if (!cache || resetCache) {\r\n                cache = new Map();\r\n                _scopeCache.set(mainScope, cache);\r\n            }\r\n            return cache;\r\n        }\r\n\r\n        getOptionScopes(mainScope, keyLists, resetCache) {\r\n            const {options, type} = this;\r\n            const cache = this._cachedScopes(mainScope, resetCache);\r\n            const cached = cache.get(keyLists);\r\n            if (cached) {\r\n                return cached;\r\n            }\r\n            const scopes = new Set();\r\n            keyLists.forEach(keys => {\r\n                if (mainScope) {\r\n                    scopes.add(mainScope);\r\n                    keys.forEach(key => addIfFound(scopes, mainScope, key));\r\n                }\r\n                keys.forEach(key => addIfFound(scopes, options, key));\r\n                keys.forEach(key => addIfFound(scopes, overrides[type] || {}, key));\r\n                keys.forEach(key => addIfFound(scopes, defaults, key));\r\n                keys.forEach(key => addIfFound(scopes, descriptors, key));\r\n            });\r\n            const array = [...scopes];\r\n            if (keysCached.has(keyLists)) {\r\n                cache.set(keyLists, array);\r\n            }\r\n            return array;\r\n        }\r\n\r\n        chartOptionScopes() {\r\n            const {options, type} = this;\r\n            return [\r\n                options,\r\n                overrides[type] || {},\r\n                defaults.datasets[type] || {},\r\n                {type},\r\n                defaults,\r\n                descriptors\r\n            ];\r\n        }\r\n\r\n        resolveNamedOptions(scopes, names, context, prefixes = ['']) {\r\n            const result = {$shared: true};\r\n            const {resolver, subPrefixes} = getResolver(this._resolverCache, scopes, prefixes);\r\n            let options = resolver;\r\n            if (needContext(resolver, names)) {\r\n                result.$shared = false;\r\n                context = isFunction(context) ? context() : context;\r\n                const subResolver = this.createResolver(scopes, context, subPrefixes);\r\n                options = _attachContext(resolver, context, subResolver);\r\n            }\r\n            for (const prop of names) {\r\n                result[prop] = options[prop];\r\n            }\r\n            return result;\r\n        }\r\n\r\n        createResolver(scopes, context, prefixes = [''], descriptorDefaults) {\r\n            const {resolver} = getResolver(this._resolverCache, scopes, prefixes);\r\n            return isObject(context)\r\n                ? _attachContext(resolver, context, undefined, descriptorDefaults)\r\n                : resolver;\r\n        }\r\n    }\r\n\r\n    function getResolver(resolverCache, scopes, prefixes) {\r\n        let cache = resolverCache.get(scopes);\r\n        if (!cache) {\r\n            cache = new Map();\r\n            resolverCache.set(scopes, cache);\r\n        }\r\n        const cacheKey = prefixes.join();\r\n        let cached = cache.get(cacheKey);\r\n        if (!cached) {\r\n            const resolver = _createResolver(scopes, prefixes);\r\n            cached = {\r\n                resolver,\r\n                subPrefixes: prefixes.filter(p => !p.toLowerCase().includes('hover'))\r\n            };\r\n            cache.set(cacheKey, cached);\r\n        }\r\n        return cached;\r\n    }\r\n\r\n    function needContext(proxy, names) {\r\n        const {isScriptable, isIndexable} = _descriptors(proxy);\r\n        for (const prop of names) {\r\n            if ((isScriptable(prop) && isFunction(proxy[prop]))\r\n                || (isIndexable(prop) && isArray(proxy[prop]))) {\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n    var version = \"3.0.1\";\r\n\r\n    const KNOWN_POSITIONS = ['top', 'bottom', 'left', 'right', 'chartArea'];\r\n\r\n    function positionIsHorizontal(position, axis) {\r\n        return position === 'top' || position === 'bottom' || (KNOWN_POSITIONS.indexOf(position) === -1 && axis === 'x');\r\n    }\r\n\r\n    function compare2Level(l1, l2) {\r\n        return function (a, b) {\r\n            return a[l1] === b[l1]\r\n                ? a[l2] - b[l2]\r\n                : a[l1] - b[l1];\r\n        };\r\n    }\r\n\r\n    function onAnimationsComplete(context) {\r\n        const chart = context.chart;\r\n        const animationOptions = chart.options.animation;\r\n        chart.notifyPlugins('afterRender');\r\n        callback(animationOptions && animationOptions.onComplete, [context], chart);\r\n    }\r\n\r\n    function onAnimationProgress(context) {\r\n        const chart = context.chart;\r\n        const animationOptions = chart.options.animation;\r\n        callback(animationOptions && animationOptions.onProgress, [context], chart);\r\n    }\r\n\r\n    function isDomSupported() {\r\n        return typeof window !== 'undefined' && typeof document !== 'undefined';\r\n    }\r\n\r\n    function getCanvas(item) {\r\n        if (isDomSupported() && typeof item === 'string') {\r\n            item = document.getElementById(item);\r\n        } else if (item && item.length) {\r\n            item = item[0];\r\n        }\r\n        if (item && item.canvas) {\r\n            item = item.canvas;\r\n        }\r\n        return item;\r\n    }\r\n\r\n    const instances = {};\r\n    const getChart = (key) => {\r\n        const canvas = getCanvas(key);\r\n        return Object.values(instances).filter((c) => c.canvas === canvas).pop();\r\n    };\r\n\r\n    class Chart {\r\n        constructor(item, config) {\r\n            const me = this;\r\n            this.config = config = new Config(config);\r\n            const initialCanvas = getCanvas(item);\r\n            const existingChart = getChart(initialCanvas);\r\n            if (existingChart) {\r\n                throw new Error(\r\n                    'Canvas is already in use. Chart with ID \\'' + existingChart.id + '\\'' +\r\n                    ' must be destroyed before the canvas can be reused.'\r\n                );\r\n            }\r\n            const options = config.createResolver(config.chartOptionScopes(), me.getContext());\r\n            this.platform = me._initializePlatform(initialCanvas, config);\r\n            const context = me.platform.acquireContext(initialCanvas, options.aspectRatio);\r\n            const canvas = context && context.canvas;\r\n            const height = canvas && canvas.height;\r\n            const width = canvas && canvas.width;\r\n            this.id = uid();\r\n            this.ctx = context;\r\n            this.canvas = canvas;\r\n            this.width = width;\r\n            this.height = height;\r\n            this._options = options;\r\n            this._aspectRatio = this.aspectRatio;\r\n            this._layers = [];\r\n            this._metasets = [];\r\n            this._stacks = undefined;\r\n            this.boxes = [];\r\n            this.currentDevicePixelRatio = undefined;\r\n            this.chartArea = undefined;\r\n            this._active = [];\r\n            this._lastEvent = undefined;\r\n            this._listeners = {};\r\n            this._sortedMetasets = [];\r\n            this.scales = {};\r\n            this.scale = undefined;\r\n            this._plugins = new PluginService();\r\n            this.$proxies = {};\r\n            this._hiddenIndices = {};\r\n            this.attached = false;\r\n            this._animationsDisabled = undefined;\r\n            this.$context = undefined;\r\n            this._doResize = debounce(() => this.update('resize'), options.resizeDelay || 0);\r\n            instances[me.id] = me;\r\n            if (!context || !canvas) {\r\n                console.error(\"Failed to create chart: can't acquire context from the given item\");\r\n                return;\r\n            }\r\n            animator.listen(me, 'complete', onAnimationsComplete);\r\n            animator.listen(me, 'progress', onAnimationProgress);\r\n            me._initialize();\r\n            if (me.attached) {\r\n                me.update();\r\n            }\r\n        }\r\n\r\n        get aspectRatio() {\r\n            const {options: {aspectRatio, maintainAspectRatio}, width, height, _aspectRatio} = this;\r\n            if (!isNullOrUndef(aspectRatio)) {\r\n                return aspectRatio;\r\n            }\r\n            if (maintainAspectRatio && _aspectRatio) {\r\n                return _aspectRatio;\r\n            }\r\n            return height ? width / height : null;\r\n        }\r\n\r\n        get data() {\r\n            return this.config.data;\r\n        }\r\n\r\n        set data(data) {\r\n            this.config.data = data;\r\n        }\r\n\r\n        get options() {\r\n            return this._options;\r\n        }\r\n\r\n        set options(options) {\r\n            this.config.options = options;\r\n        }\r\n\r\n        _initialize() {\r\n            const me = this;\r\n            me.notifyPlugins('beforeInit');\r\n            if (me.options.responsive) {\r\n                me.resize();\r\n            } else {\r\n                retinaScale(me, me.options.devicePixelRatio);\r\n            }\r\n            me.bindEvents();\r\n            me.notifyPlugins('afterInit');\r\n            return me;\r\n        }\r\n\r\n        _initializePlatform(canvas, config) {\r\n            if (config.platform) {\r\n                return new config.platform();\r\n            } else if (!isDomSupported() || (typeof OffscreenCanvas !== 'undefined' && canvas instanceof OffscreenCanvas)) {\r\n                return new BasicPlatform();\r\n            }\r\n            return new DomPlatform();\r\n        }\r\n\r\n        clear() {\r\n            clearCanvas(this.canvas, this.ctx);\r\n            return this;\r\n        }\r\n\r\n        stop() {\r\n            animator.stop(this);\r\n            return this;\r\n        }\r\n\r\n        resize(width, height) {\r\n            if (!animator.running(this)) {\r\n                this._resize(width, height);\r\n            } else {\r\n                this._resizeBeforeDraw = {width, height};\r\n            }\r\n        }\r\n\r\n        _resize(width, height) {\r\n            const me = this;\r\n            const options = me.options;\r\n            const canvas = me.canvas;\r\n            const aspectRatio = options.maintainAspectRatio && me.aspectRatio;\r\n            const newSize = me.platform.getMaximumSize(canvas, width, height, aspectRatio);\r\n            const oldRatio = me.currentDevicePixelRatio;\r\n            const newRatio = options.devicePixelRatio || me.platform.getDevicePixelRatio();\r\n            if (me.width === newSize.width && me.height === newSize.height && oldRatio === newRatio) {\r\n                return;\r\n            }\r\n            me.width = newSize.width;\r\n            me.height = newSize.height;\r\n            me._aspectRatio = me.aspectRatio;\r\n            retinaScale(me, newRatio, true);\r\n            me.notifyPlugins('resize', {size: newSize});\r\n            callback(options.onResize, [me, newSize], me);\r\n            if (me.attached) {\r\n                if (me._doResize()) {\r\n                    me.render();\r\n                }\r\n            }\r\n        }\r\n\r\n        ensureScalesHaveIDs() {\r\n            const options = this.options;\r\n            const scalesOptions = options.scales || {};\r\n            each(scalesOptions, (axisOptions, axisID) => {\r\n                axisOptions.id = axisID;\r\n            });\r\n        }\r\n\r\n        buildOrUpdateScales() {\r\n            const me = this;\r\n            const options = me.options;\r\n            const scaleOpts = options.scales;\r\n            const scales = me.scales;\r\n            const updated = Object.keys(scales).reduce((obj, id) => {\r\n                obj[id] = false;\r\n                return obj;\r\n            }, {});\r\n            let items = [];\r\n            if (scaleOpts) {\r\n                items = items.concat(\r\n                    Object.keys(scaleOpts).map((id) => {\r\n                        const scaleOptions = scaleOpts[id];\r\n                        const axis = determineAxis(id, scaleOptions);\r\n                        const isRadial = axis === 'r';\r\n                        const isHorizontal = axis === 'x';\r\n                        return {\r\n                            options: scaleOptions,\r\n                            dposition: isRadial ? 'chartArea' : isHorizontal ? 'bottom' : 'left',\r\n                            dtype: isRadial ? 'radialLinear' : isHorizontal ? 'category' : 'linear'\r\n                        };\r\n                    })\r\n                );\r\n            }\r\n            each(items, (item) => {\r\n                const scaleOptions = item.options;\r\n                const id = scaleOptions.id;\r\n                const axis = determineAxis(id, scaleOptions);\r\n                const scaleType = valueOrDefault(scaleOptions.type, item.dtype);\r\n                if (scaleOptions.position === undefined || positionIsHorizontal(scaleOptions.position, axis) !== positionIsHorizontal(item.dposition)) {\r\n                    scaleOptions.position = item.dposition;\r\n                }\r\n                updated[id] = true;\r\n                let scale = null;\r\n                if (id in scales && scales[id].type === scaleType) {\r\n                    scale = scales[id];\r\n                } else {\r\n                    const scaleClass = registry.getScale(scaleType);\r\n                    scale = new scaleClass({\r\n                        id,\r\n                        type: scaleType,\r\n                        ctx: me.ctx,\r\n                        chart: me\r\n                    });\r\n                    scales[scale.id] = scale;\r\n                }\r\n                scale.init(scaleOptions, options);\r\n            });\r\n            each(updated, (hasUpdated, id) => {\r\n                if (!hasUpdated) {\r\n                    delete scales[id];\r\n                }\r\n            });\r\n            each(scales, (scale) => {\r\n                layouts.configure(me, scale, scale.options);\r\n                layouts.addBox(me, scale);\r\n            });\r\n        }\r\n\r\n        _updateMetasetIndex(meta, index) {\r\n            const metasets = this._metasets;\r\n            const oldIndex = meta.index;\r\n            if (oldIndex !== index) {\r\n                metasets[oldIndex] = metasets[index];\r\n                metasets[index] = meta;\r\n                meta.index = index;\r\n            }\r\n        }\r\n\r\n        _updateMetasets() {\r\n            const me = this;\r\n            const metasets = me._metasets;\r\n            const numData = me.data.datasets.length;\r\n            const numMeta = metasets.length;\r\n            if (numMeta > numData) {\r\n                for (let i = numData; i < numMeta; ++i) {\r\n                    me._destroyDatasetMeta(i);\r\n                }\r\n                metasets.splice(numData, numMeta - numData);\r\n            }\r\n            me._sortedMetasets = metasets.slice(0).sort(compare2Level('order', 'index'));\r\n        }\r\n\r\n        _removeUnreferencedMetasets() {\r\n            const me = this;\r\n            const {_metasets: metasets, data: {datasets}} = me;\r\n            if (metasets.length > datasets.length) {\r\n                delete me._stacks;\r\n            }\r\n            metasets.forEach((meta, index) => {\r\n                if (datasets.filter(x => x === meta._dataset).length === 0) {\r\n                    me._destroyDatasetMeta(index);\r\n                }\r\n            });\r\n        }\r\n\r\n        buildOrUpdateControllers() {\r\n            const me = this;\r\n            const newControllers = [];\r\n            const datasets = me.data.datasets;\r\n            let i, ilen;\r\n            me._removeUnreferencedMetasets();\r\n            for (i = 0, ilen = datasets.length; i < ilen; i++) {\r\n                const dataset = datasets[i];\r\n                let meta = me.getDatasetMeta(i);\r\n                const type = dataset.type || me.config.type;\r\n                if (meta.type && meta.type !== type) {\r\n                    me._destroyDatasetMeta(i);\r\n                    meta = me.getDatasetMeta(i);\r\n                }\r\n                meta.type = type;\r\n                meta.indexAxis = dataset.indexAxis || getIndexAxis(type, me.options);\r\n                meta.order = dataset.order || 0;\r\n                me._updateMetasetIndex(meta, i);\r\n                meta.label = '' + dataset.label;\r\n                meta.visible = me.isDatasetVisible(i);\r\n                if (meta.controller) {\r\n                    meta.controller.updateIndex(i);\r\n                    meta.controller.linkScales();\r\n                } else {\r\n                    const ControllerClass = registry.getController(type);\r\n                    const {datasetElementType, dataElementType} = defaults.datasets[type];\r\n                    Object.assign(ControllerClass.prototype, {\r\n                        dataElementType: registry.getElement(dataElementType),\r\n                        datasetElementType: datasetElementType && registry.getElement(datasetElementType)\r\n                    });\r\n                    meta.controller = new ControllerClass(me, i);\r\n                    newControllers.push(meta.controller);\r\n                }\r\n            }\r\n            me._updateMetasets();\r\n            return newControllers;\r\n        }\r\n\r\n        _resetElements() {\r\n            const me = this;\r\n            each(me.data.datasets, (dataset, datasetIndex) => {\r\n                me.getDatasetMeta(datasetIndex).controller.reset();\r\n            }, me);\r\n        }\r\n\r\n        reset() {\r\n            this._resetElements();\r\n            this.notifyPlugins('reset');\r\n        }\r\n\r\n        update(mode) {\r\n            const me = this;\r\n            const config = me.config;\r\n            config.update();\r\n            me._options = config.createResolver(config.chartOptionScopes(), me.getContext());\r\n            each(me.scales, (scale) => {\r\n                layouts.removeBox(me, scale);\r\n            });\r\n            const animsDisabled = me._animationsDisabled = !me.options.animation;\r\n            me.ensureScalesHaveIDs();\r\n            me.buildOrUpdateScales();\r\n            me._plugins.invalidate();\r\n            if (me.notifyPlugins('beforeUpdate', {mode, cancelable: true}) === false) {\r\n                return;\r\n            }\r\n            const newControllers = me.buildOrUpdateControllers();\r\n            me.notifyPlugins('beforeElementsUpdate');\r\n            let minPadding = 0;\r\n            for (let i = 0, ilen = me.data.datasets.length; i < ilen; i++) {\r\n                const {controller} = me.getDatasetMeta(i);\r\n                const reset = !animsDisabled && newControllers.indexOf(controller) === -1;\r\n                controller.buildOrUpdateElements(reset);\r\n                minPadding = Math.max(+controller.getMaxOverflow(), minPadding);\r\n            }\r\n            me._minPadding = minPadding;\r\n            me._updateLayout(minPadding);\r\n            if (!animsDisabled) {\r\n                each(newControllers, (controller) => {\r\n                    controller.reset();\r\n                });\r\n            }\r\n            me._updateDatasets(mode);\r\n            me.notifyPlugins('afterUpdate', {mode});\r\n            me._layers.sort(compare2Level('z', '_idx'));\r\n            if (me._lastEvent) {\r\n                me._eventHandler(me._lastEvent, true);\r\n            }\r\n            me.render();\r\n        }\r\n\r\n        _updateLayout(minPadding) {\r\n            const me = this;\r\n            if (me.notifyPlugins('beforeLayout', {cancelable: true}) === false) {\r\n                return;\r\n            }\r\n            layouts.update(me, me.width, me.height, minPadding);\r\n            const area = me.chartArea;\r\n            const noArea = area.width <= 0 || area.height <= 0;\r\n            me._layers = [];\r\n            each(me.boxes, (box) => {\r\n                if (noArea && box.position === 'chartArea') {\r\n                    return;\r\n                }\r\n                if (box.configure) {\r\n                    box.configure();\r\n                }\r\n                me._layers.push(...box._layers());\r\n            }, me);\r\n            me._layers.forEach((item, index) => {\r\n                item._idx = index;\r\n            });\r\n            me.notifyPlugins('afterLayout');\r\n        }\r\n\r\n        _updateDatasets(mode) {\r\n            const me = this;\r\n            const isFunction = typeof mode === 'function';\r\n            if (me.notifyPlugins('beforeDatasetsUpdate', {mode, cancelable: true}) === false) {\r\n                return;\r\n            }\r\n            for (let i = 0, ilen = me.data.datasets.length; i < ilen; ++i) {\r\n                me._updateDataset(i, isFunction ? mode({datasetIndex: i}) : mode);\r\n            }\r\n            me.notifyPlugins('afterDatasetsUpdate', {mode});\r\n        }\r\n\r\n        _updateDataset(index, mode) {\r\n            const me = this;\r\n            const meta = me.getDatasetMeta(index);\r\n            const args = {meta, index, mode, cancelable: true};\r\n            if (me.notifyPlugins('beforeDatasetUpdate', args) === false) {\r\n                return;\r\n            }\r\n            meta.controller._update(mode);\r\n            args.cancelable = false;\r\n            me.notifyPlugins('afterDatasetUpdate', args);\r\n        }\r\n\r\n        render() {\r\n            const me = this;\r\n            if (me.notifyPlugins('beforeRender', {cancelable: true}) === false) {\r\n                return;\r\n            }\r\n            if (animator.has(me)) {\r\n                if (me.attached && !animator.running(me)) {\r\n                    animator.start(me);\r\n                }\r\n            } else {\r\n                me.draw();\r\n                onAnimationsComplete({chart: me});\r\n            }\r\n        }\r\n\r\n        draw() {\r\n            const me = this;\r\n            let i;\r\n            if (me._resizeBeforeDraw) {\r\n                const {width, height} = me._resizeBeforeDraw;\r\n                me._resize(width, height);\r\n                me._resizeBeforeDraw = null;\r\n            }\r\n            me.clear();\r\n            if (me.width <= 0 || me.height <= 0) {\r\n                return;\r\n            }\r\n            if (me.notifyPlugins('beforeDraw', {cancelable: true}) === false) {\r\n                return;\r\n            }\r\n            const layers = me._layers;\r\n            for (i = 0; i < layers.length && layers[i].z <= 0; ++i) {\r\n                layers[i].draw(me.chartArea);\r\n            }\r\n            me._drawDatasets();\r\n            for (; i < layers.length; ++i) {\r\n                layers[i].draw(me.chartArea);\r\n            }\r\n            me.notifyPlugins('afterDraw');\r\n        }\r\n\r\n        _getSortedDatasetMetas(filterVisible) {\r\n            const me = this;\r\n            const metasets = me._sortedMetasets;\r\n            const result = [];\r\n            let i, ilen;\r\n            for (i = 0, ilen = metasets.length; i < ilen; ++i) {\r\n                const meta = metasets[i];\r\n                if (!filterVisible || meta.visible) {\r\n                    result.push(meta);\r\n                }\r\n            }\r\n            return result;\r\n        }\r\n\r\n        getSortedVisibleDatasetMetas() {\r\n            return this._getSortedDatasetMetas(true);\r\n        }\r\n\r\n        _drawDatasets() {\r\n            const me = this;\r\n            if (me.notifyPlugins('beforeDatasetsDraw', {cancelable: true}) === false) {\r\n                return;\r\n            }\r\n            const metasets = me.getSortedVisibleDatasetMetas();\r\n            for (let i = metasets.length - 1; i >= 0; --i) {\r\n                me._drawDataset(metasets[i]);\r\n            }\r\n            me.notifyPlugins('afterDatasetsDraw');\r\n        }\r\n\r\n        _drawDataset(meta) {\r\n            const me = this;\r\n            const ctx = me.ctx;\r\n            const clip = meta._clip;\r\n            const area = me.chartArea;\r\n            const args = {\r\n                meta,\r\n                index: meta.index,\r\n                cancelable: true\r\n            };\r\n            if (me.notifyPlugins('beforeDatasetDraw', args) === false) {\r\n                return;\r\n            }\r\n            clipArea(ctx, {\r\n                left: clip.left === false ? 0 : area.left - clip.left,\r\n                right: clip.right === false ? me.width : area.right + clip.right,\r\n                top: clip.top === false ? 0 : area.top - clip.top,\r\n                bottom: clip.bottom === false ? me.height : area.bottom + clip.bottom\r\n            });\r\n            meta.controller.draw();\r\n            unclipArea(ctx);\r\n            args.cancelable = false;\r\n            me.notifyPlugins('afterDatasetDraw', args);\r\n        }\r\n\r\n        getElementsAtEventForMode(e, mode, options, useFinalPosition) {\r\n            const method = Interaction.modes[mode];\r\n            if (typeof method === 'function') {\r\n                return method(this, e, options, useFinalPosition);\r\n            }\r\n            return [];\r\n        }\r\n\r\n        getDatasetMeta(datasetIndex) {\r\n            const me = this;\r\n            const dataset = me.data.datasets[datasetIndex];\r\n            const metasets = me._metasets;\r\n            let meta = metasets.filter(x => x && x._dataset === dataset).pop();\r\n            if (!meta) {\r\n                meta = metasets[datasetIndex] = {\r\n                    type: null,\r\n                    data: [],\r\n                    dataset: null,\r\n                    controller: null,\r\n                    hidden: null,\r\n                    xAxisID: null,\r\n                    yAxisID: null,\r\n                    order: dataset && dataset.order || 0,\r\n                    index: datasetIndex,\r\n                    _dataset: dataset,\r\n                    _parsed: [],\r\n                    _sorted: false\r\n                };\r\n            }\r\n            return meta;\r\n        }\r\n\r\n        getContext() {\r\n            return this.$context || (this.$context = {chart: this, type: 'chart'});\r\n        }\r\n\r\n        getVisibleDatasetCount() {\r\n            return this.getSortedVisibleDatasetMetas().length;\r\n        }\r\n\r\n        isDatasetVisible(datasetIndex) {\r\n            const dataset = this.data.datasets[datasetIndex];\r\n            if (!dataset) {\r\n                return false;\r\n            }\r\n            const meta = this.getDatasetMeta(datasetIndex);\r\n            return typeof meta.hidden === 'boolean' ? !meta.hidden : !dataset.hidden;\r\n        }\r\n\r\n        setDatasetVisibility(datasetIndex, visible) {\r\n            const meta = this.getDatasetMeta(datasetIndex);\r\n            meta.hidden = !visible;\r\n        }\r\n\r\n        toggleDataVisibility(index) {\r\n            this._hiddenIndices[index] = !this._hiddenIndices[index];\r\n        }\r\n\r\n        getDataVisibility(index) {\r\n            return !this._hiddenIndices[index];\r\n        }\r\n\r\n        _updateDatasetVisibility(datasetIndex, visible) {\r\n            const me = this;\r\n            const mode = visible ? 'show' : 'hide';\r\n            const meta = me.getDatasetMeta(datasetIndex);\r\n            const anims = meta.controller._resolveAnimations(undefined, mode);\r\n            me.setDatasetVisibility(datasetIndex, visible);\r\n            anims.update(meta, {visible});\r\n            me.update((ctx) => ctx.datasetIndex === datasetIndex ? mode : undefined);\r\n        }\r\n\r\n        hide(datasetIndex) {\r\n            this._updateDatasetVisibility(datasetIndex, false);\r\n        }\r\n\r\n        show(datasetIndex) {\r\n            this._updateDatasetVisibility(datasetIndex, true);\r\n        }\r\n\r\n        _destroyDatasetMeta(datasetIndex) {\r\n            const me = this;\r\n            const meta = me._metasets && me._metasets[datasetIndex];\r\n            if (meta && meta.controller) {\r\n                meta.controller._destroy();\r\n                delete me._metasets[datasetIndex];\r\n            }\r\n        }\r\n\r\n        destroy() {\r\n            const me = this;\r\n            const {canvas, ctx} = me;\r\n            let i, ilen;\r\n            me.stop();\r\n            animator.remove(me);\r\n            for (i = 0, ilen = me.data.datasets.length; i < ilen; ++i) {\r\n                me._destroyDatasetMeta(i);\r\n            }\r\n            me.config.clearCache();\r\n            if (canvas) {\r\n                me.unbindEvents();\r\n                clearCanvas(canvas, ctx);\r\n                me.platform.releaseContext(ctx);\r\n                me.canvas = null;\r\n                me.ctx = null;\r\n            }\r\n            me.notifyPlugins('destroy');\r\n            delete instances[me.id];\r\n        }\r\n\r\n        toBase64Image(...args) {\r\n            return this.canvas.toDataURL(...args);\r\n        }\r\n\r\n        bindEvents() {\r\n            const me = this;\r\n            const listeners = me._listeners;\r\n            const platform = me.platform;\r\n            const _add = (type, listener) => {\r\n                platform.addEventListener(me, type, listener);\r\n                listeners[type] = listener;\r\n            };\r\n            const _remove = (type, listener) => {\r\n                if (listeners[type]) {\r\n                    platform.removeEventListener(me, type, listener);\r\n                    delete listeners[type];\r\n                }\r\n            };\r\n            let listener = function (e, x, y) {\r\n                e.offsetX = x;\r\n                e.offsetY = y;\r\n                me._eventHandler(e);\r\n            };\r\n            each(me.options.events, (type) => _add(type, listener));\r\n            if (me.options.responsive) {\r\n                listener = (width, height) => {\r\n                    if (me.canvas) {\r\n                        me.resize(width, height);\r\n                    }\r\n                };\r\n                let detached;\r\n                const attached = () => {\r\n                    _remove('attach', attached);\r\n                    me.attached = true;\r\n                    me.resize();\r\n                    _add('resize', listener);\r\n                    _add('detach', detached);\r\n                };\r\n                detached = () => {\r\n                    me.attached = false;\r\n                    _remove('resize', listener);\r\n                    _add('attach', attached);\r\n                };\r\n                if (platform.isAttached(me.canvas)) {\r\n                    attached();\r\n                } else {\r\n                    detached();\r\n                }\r\n            } else {\r\n                me.attached = true;\r\n            }\r\n        }\r\n\r\n        unbindEvents() {\r\n            const me = this;\r\n            const listeners = me._listeners;\r\n            if (!listeners) {\r\n                return;\r\n            }\r\n            delete me._listeners;\r\n            each(listeners, (listener, type) => {\r\n                me.platform.removeEventListener(me, type, listener);\r\n            });\r\n        }\r\n\r\n        updateHoverStyle(items, mode, enabled) {\r\n            const prefix = enabled ? 'set' : 'remove';\r\n            let meta, item, i, ilen;\r\n            if (mode === 'dataset') {\r\n                meta = this.getDatasetMeta(items[0].datasetIndex);\r\n                meta.controller['_' + prefix + 'DatasetHoverStyle']();\r\n            }\r\n            for (i = 0, ilen = items.length; i < ilen; ++i) {\r\n                item = items[i];\r\n                const controller = item && this.getDatasetMeta(item.datasetIndex).controller;\r\n                if (controller) {\r\n                    controller[prefix + 'HoverStyle'](item.element, item.datasetIndex, item.index);\r\n                }\r\n            }\r\n        }\r\n\r\n        getActiveElements() {\r\n            return this._active || [];\r\n        }\r\n\r\n        setActiveElements(activeElements) {\r\n            const me = this;\r\n            const lastActive = me._active || [];\r\n            const active = activeElements.map(({datasetIndex, index}) => {\r\n                const meta = me.getDatasetMeta(datasetIndex);\r\n                if (!meta) {\r\n                    throw new Error('No dataset found at index ' + datasetIndex);\r\n                }\r\n                return {\r\n                    datasetIndex,\r\n                    element: meta.data[index],\r\n                    index,\r\n                };\r\n            });\r\n            const changed = !_elementsEqual(active, lastActive);\r\n            if (changed) {\r\n                me._active = active;\r\n                me._updateHoverStyles(active, lastActive);\r\n            }\r\n        }\r\n\r\n        notifyPlugins(hook, args) {\r\n            return this._plugins.notify(this, hook, args);\r\n        }\r\n\r\n        _updateHoverStyles(active, lastActive, replay) {\r\n            const me = this;\r\n            const hoverOptions = me.options.hover;\r\n            const diff = (a, b) => a.filter(x => !b.some(y => x.datasetIndex === y.datasetIndex && x.index === y.index));\r\n            const deactivated = diff(lastActive, active);\r\n            const activated = replay ? active : diff(active, lastActive);\r\n            if (deactivated.length) {\r\n                me.updateHoverStyle(deactivated, hoverOptions.mode, false);\r\n            }\r\n            if (activated.length && hoverOptions.mode) {\r\n                me.updateHoverStyle(activated, hoverOptions.mode, true);\r\n            }\r\n        }\r\n\r\n        _eventHandler(e, replay) {\r\n            const me = this;\r\n            const args = {event: e, replay, cancelable: true};\r\n            if (me.notifyPlugins('beforeEvent', args) === false) {\r\n                return;\r\n            }\r\n            const changed = me._handleEvent(e, replay);\r\n            args.cancelable = false;\r\n            me.notifyPlugins('afterEvent', args);\r\n            if (changed || args.changed) {\r\n                me.render();\r\n            }\r\n            return me;\r\n        }\r\n\r\n        _handleEvent(e, replay) {\r\n            const me = this;\r\n            const {_active: lastActive = [], options} = me;\r\n            const hoverOptions = options.hover;\r\n            const useFinalPosition = replay;\r\n            let active = [];\r\n            let changed = false;\r\n            let lastEvent = null;\r\n            if (e.type !== 'mouseout') {\r\n                active = me.getElementsAtEventForMode(e, hoverOptions.mode, hoverOptions, useFinalPosition);\r\n                lastEvent = e.type === 'click' ? me._lastEvent : e;\r\n            }\r\n            me._lastEvent = null;\r\n            callback(options.onHover, [e, active, me], me);\r\n            if (e.type === 'mouseup' || e.type === 'click' || e.type === 'contextmenu') {\r\n                if (_isPointInArea(e, me.chartArea, me._minPadding)) {\r\n                    callback(options.onClick, [e, active, me], me);\r\n                }\r\n            }\r\n            changed = !_elementsEqual(active, lastActive);\r\n            if (changed || replay) {\r\n                me._active = active;\r\n                me._updateHoverStyles(active, lastActive, replay);\r\n            }\r\n            me._lastEvent = lastEvent;\r\n            return changed;\r\n        }\r\n    }\r\n\r\n    const invalidatePlugins = () => each(Chart.instances, (chart) => chart._plugins.invalidate());\r\n    const enumerable = true;\r\n    Object.defineProperties(Chart, {\r\n        defaults: {\r\n            enumerable,\r\n            value: defaults\r\n        },\r\n        instances: {\r\n            enumerable,\r\n            value: instances\r\n        },\r\n        overrides: {\r\n            enumerable,\r\n            value: overrides\r\n        },\r\n        registry: {\r\n            enumerable,\r\n            value: registry\r\n        },\r\n        version: {\r\n            enumerable,\r\n            value: version\r\n        },\r\n        getChart: {\r\n            enumerable,\r\n            value: getChart\r\n        },\r\n        register: {\r\n            enumerable,\r\n            value: (...items) => {\r\n                registry.add(...items);\r\n                invalidatePlugins();\r\n            }\r\n        },\r\n        unregister: {\r\n            enumerable,\r\n            value: (...items) => {\r\n                registry.remove(...items);\r\n                invalidatePlugins();\r\n            }\r\n        }\r\n    });\r\n\r\n    function abstract() {\r\n        throw new Error('This method is not implemented: either no adapter can be found or an incomplete integration was provided.');\r\n    }\r\n\r\n    class DateAdapter {\r\n        constructor(options) {\r\n            this.options = options || {};\r\n        }\r\n\r\n        formats() {\r\n            return abstract();\r\n        }\r\n\r\n        parse(value, format) {\r\n            return abstract();\r\n        }\r\n\r\n        format(timestamp, format) {\r\n            return abstract();\r\n        }\r\n\r\n        add(timestamp, amount, unit) {\r\n            return abstract();\r\n        }\r\n\r\n        diff(a, b, unit) {\r\n            return abstract();\r\n        }\r\n\r\n        startOf(timestamp, unit, weekday) {\r\n            return abstract();\r\n        }\r\n\r\n        endOf(timestamp, unit) {\r\n            return abstract();\r\n        }\r\n    }\r\n\r\n    DateAdapter.override = function (members) {\r\n        Object.assign(DateAdapter.prototype, members);\r\n    };\r\n    var _adapters = {\r\n        _date: DateAdapter\r\n    };\r\n\r\n    function getAllScaleValues(scale) {\r\n        if (!scale._cache.$bar) {\r\n            const metas = scale.getMatchingVisibleMetas('bar');\r\n            let values = [];\r\n            for (let i = 0, ilen = metas.length; i < ilen; i++) {\r\n                values = values.concat(metas[i].controller.getAllParsedValues(scale));\r\n            }\r\n            scale._cache.$bar = _arrayUnique(values.sort((a, b) => a - b));\r\n        }\r\n        return scale._cache.$bar;\r\n    }\r\n\r\n    function computeMinSampleSize(scale) {\r\n        const values = getAllScaleValues(scale);\r\n        let min = scale._length;\r\n        let i, ilen, curr, prev;\r\n        const updateMinAndPrev = () => {\r\n            min = Math.min(min, i && Math.abs(curr - prev) || min);\r\n            prev = curr;\r\n        };\r\n        for (i = 0, ilen = values.length; i < ilen; ++i) {\r\n            curr = scale.getPixelForValue(values[i]);\r\n            updateMinAndPrev();\r\n        }\r\n        for (i = 0, ilen = scale.ticks.length; i < ilen; ++i) {\r\n            curr = scale.getPixelForTick(i);\r\n            updateMinAndPrev();\r\n        }\r\n        return min;\r\n    }\r\n\r\n    function computeFitCategoryTraits(index, ruler, options, stackCount) {\r\n        const thickness = options.barThickness;\r\n        let size, ratio;\r\n        if (isNullOrUndef(thickness)) {\r\n            size = ruler.min * options.categoryPercentage;\r\n            ratio = options.barPercentage;\r\n        } else {\r\n            size = thickness * stackCount;\r\n            ratio = 1;\r\n        }\r\n        return {\r\n            chunk: size / stackCount,\r\n            ratio,\r\n            start: ruler.pixels[index] - (size / 2)\r\n        };\r\n    }\r\n\r\n    function computeFlexCategoryTraits(index, ruler, options, stackCount) {\r\n        const pixels = ruler.pixels;\r\n        const curr = pixels[index];\r\n        let prev = index > 0 ? pixels[index - 1] : null;\r\n        let next = index < pixels.length - 1 ? pixels[index + 1] : null;\r\n        const percent = options.categoryPercentage;\r\n        if (prev === null) {\r\n            prev = curr - (next === null ? ruler.end - ruler.start : next - curr);\r\n        }\r\n        if (next === null) {\r\n            next = curr + curr - prev;\r\n        }\r\n        const start = curr - (curr - Math.min(prev, next)) / 2 * percent;\r\n        const size = Math.abs(next - prev) / 2 * percent;\r\n        return {\r\n            chunk: size / stackCount,\r\n            ratio: options.barPercentage,\r\n            start\r\n        };\r\n    }\r\n\r\n    function parseFloatBar(entry, item, vScale, i) {\r\n        const startValue = vScale.parse(entry[0], i);\r\n        const endValue = vScale.parse(entry[1], i);\r\n        const min = Math.min(startValue, endValue);\r\n        const max = Math.max(startValue, endValue);\r\n        let barStart = min;\r\n        let barEnd = max;\r\n        if (Math.abs(min) > Math.abs(max)) {\r\n            barStart = max;\r\n            barEnd = min;\r\n        }\r\n        item[vScale.axis] = barEnd;\r\n        item._custom = {\r\n            barStart,\r\n            barEnd,\r\n            start: startValue,\r\n            end: endValue,\r\n            min,\r\n            max\r\n        };\r\n    }\r\n\r\n    function parseValue(entry, item, vScale, i) {\r\n        if (isArray(entry)) {\r\n            parseFloatBar(entry, item, vScale, i);\r\n        } else {\r\n            item[vScale.axis] = vScale.parse(entry, i);\r\n        }\r\n        return item;\r\n    }\r\n\r\n    function parseArrayOrPrimitive(meta, data, start, count) {\r\n        const iScale = meta.iScale;\r\n        const vScale = meta.vScale;\r\n        const labels = iScale.getLabels();\r\n        const singleScale = iScale === vScale;\r\n        const parsed = [];\r\n        let i, ilen, item, entry;\r\n        for (i = start, ilen = start + count; i < ilen; ++i) {\r\n            entry = data[i];\r\n            item = {};\r\n            item[iScale.axis] = singleScale || iScale.parse(labels[i], i);\r\n            parsed.push(parseValue(entry, item, vScale, i));\r\n        }\r\n        return parsed;\r\n    }\r\n\r\n    function isFloatBar(custom) {\r\n        return custom && custom.barStart !== undefined && custom.barEnd !== undefined;\r\n    }\r\n\r\n    class BarController extends DatasetController {\r\n        parsePrimitiveData(meta, data, start, count) {\r\n            return parseArrayOrPrimitive(meta, data, start, count);\r\n        }\r\n\r\n        parseArrayData(meta, data, start, count) {\r\n            return parseArrayOrPrimitive(meta, data, start, count);\r\n        }\r\n\r\n        parseObjectData(meta, data, start, count) {\r\n            const {iScale, vScale} = meta;\r\n            const {xAxisKey = 'x', yAxisKey = 'y'} = this._parsing;\r\n            const iAxisKey = iScale.axis === 'x' ? xAxisKey : yAxisKey;\r\n            const vAxisKey = vScale.axis === 'x' ? xAxisKey : yAxisKey;\r\n            const parsed = [];\r\n            let i, ilen, item, obj;\r\n            for (i = start, ilen = start + count; i < ilen; ++i) {\r\n                obj = data[i];\r\n                item = {};\r\n                item[iScale.axis] = iScale.parse(resolveObjectKey(obj, iAxisKey), i);\r\n                parsed.push(parseValue(resolveObjectKey(obj, vAxisKey), item, vScale, i));\r\n            }\r\n            return parsed;\r\n        }\r\n\r\n        updateRangeFromParsed(range, scale, parsed, stack) {\r\n            super.updateRangeFromParsed(range, scale, parsed, stack);\r\n            const custom = parsed._custom;\r\n            if (custom && scale === this._cachedMeta.vScale) {\r\n                range.min = Math.min(range.min, custom.min);\r\n                range.max = Math.max(range.max, custom.max);\r\n            }\r\n        }\r\n\r\n        getLabelAndValue(index) {\r\n            const me = this;\r\n            const meta = me._cachedMeta;\r\n            const {iScale, vScale} = meta;\r\n            const parsed = me.getParsed(index);\r\n            const custom = parsed._custom;\r\n            const value = isFloatBar(custom)\r\n                ? '[' + custom.start + ', ' + custom.end + ']'\r\n                : '' + vScale.getLabelForValue(parsed[vScale.axis]);\r\n            return {\r\n                label: '' + iScale.getLabelForValue(parsed[iScale.axis]),\r\n                value\r\n            };\r\n        }\r\n\r\n        initialize() {\r\n            const me = this;\r\n            me.enableOptionSharing = true;\r\n            super.initialize();\r\n            const meta = me._cachedMeta;\r\n            meta.stack = me.getDataset().stack;\r\n        }\r\n\r\n        update(mode) {\r\n            const me = this;\r\n            const meta = me._cachedMeta;\r\n            me.updateElements(meta.data, 0, meta.data.length, mode);\r\n        }\r\n\r\n        updateElements(bars, start, count, mode) {\r\n            const me = this;\r\n            const reset = mode === 'reset';\r\n            const vScale = me._cachedMeta.vScale;\r\n            const base = vScale.getBasePixel();\r\n            const horizontal = vScale.isHorizontal();\r\n            const ruler = me._getRuler();\r\n            const firstOpts = me.resolveDataElementOptions(start, mode);\r\n            const sharedOptions = me.getSharedOptions(firstOpts);\r\n            const includeOptions = me.includeOptions(mode, sharedOptions);\r\n            me.updateSharedOptions(sharedOptions, mode, firstOpts);\r\n            for (let i = start; i < start + count; i++) {\r\n                const vpixels = reset ? {base, head: base} : me._calculateBarValuePixels(i);\r\n                const ipixels = me._calculateBarIndexPixels(i, ruler);\r\n                const properties = {\r\n                    horizontal,\r\n                    base: vpixels.base,\r\n                    x: horizontal ? vpixels.head : ipixels.center,\r\n                    y: horizontal ? ipixels.center : vpixels.head,\r\n                    height: horizontal ? ipixels.size : undefined,\r\n                    width: horizontal ? undefined : ipixels.size\r\n                };\r\n                if (includeOptions) {\r\n                    properties.options = sharedOptions || me.resolveDataElementOptions(i, mode);\r\n                }\r\n                me.updateElement(bars[i], i, properties, mode);\r\n            }\r\n        }\r\n\r\n        _getStacks(last, dataIndex) {\r\n            const me = this;\r\n            const meta = me._cachedMeta;\r\n            const iScale = meta.iScale;\r\n            const metasets = iScale.getMatchingVisibleMetas(me._type);\r\n            const stacked = iScale.options.stacked;\r\n            const ilen = metasets.length;\r\n            const stacks = [];\r\n            let i, item;\r\n            for (i = 0; i < ilen; ++i) {\r\n                item = metasets[i];\r\n                if (typeof dataIndex !== 'undefined') {\r\n                    const val = item.controller.getParsed(dataIndex)[\r\n                        item.controller._cachedMeta.vScale.axis\r\n                        ];\r\n                    if (isNullOrUndef(val) || isNaN(val)) {\r\n                        continue;\r\n                    }\r\n                }\r\n                if (stacked === false || stacks.indexOf(item.stack) === -1 ||\r\n                    (stacked === undefined && item.stack === undefined)) {\r\n                    stacks.push(item.stack);\r\n                }\r\n                if (item.index === last) {\r\n                    break;\r\n                }\r\n            }\r\n            if (!stacks.length) {\r\n                stacks.push(undefined);\r\n            }\r\n            return stacks;\r\n        }\r\n\r\n        _getStackCount(index) {\r\n            return this._getStacks(undefined, index).length;\r\n        }\r\n\r\n        _getStackIndex(datasetIndex, name) {\r\n            const stacks = this._getStacks(datasetIndex);\r\n            const index = (name !== undefined)\r\n                ? stacks.indexOf(name)\r\n                : -1;\r\n            return (index === -1)\r\n                ? stacks.length - 1\r\n                : index;\r\n        }\r\n\r\n        _getRuler() {\r\n            const me = this;\r\n            const opts = me.options;\r\n            const meta = me._cachedMeta;\r\n            const iScale = meta.iScale;\r\n            const pixels = [];\r\n            let i, ilen;\r\n            for (i = 0, ilen = meta.data.length; i < ilen; ++i) {\r\n                pixels.push(iScale.getPixelForValue(me.getParsed(i)[iScale.axis], i));\r\n            }\r\n            const barThickness = opts.barThickness;\r\n            const min = barThickness || computeMinSampleSize(iScale);\r\n            return {\r\n                min,\r\n                pixels,\r\n                start: iScale._startPixel,\r\n                end: iScale._endPixel,\r\n                stackCount: me._getStackCount(),\r\n                scale: iScale,\r\n                grouped: opts.grouped,\r\n                ratio: barThickness ? 1 : opts.categoryPercentage * opts.barPercentage\r\n            };\r\n        }\r\n\r\n        _calculateBarValuePixels(index) {\r\n            const me = this;\r\n            const {vScale, _stacked} = me._cachedMeta;\r\n            const {base: baseValue, minBarLength} = me.options;\r\n            const parsed = me.getParsed(index);\r\n            const custom = parsed._custom;\r\n            const floating = isFloatBar(custom);\r\n            let value = parsed[vScale.axis];\r\n            let start = 0;\r\n            let length = _stacked ? me.applyStack(vScale, parsed, _stacked) : value;\r\n            let head, size;\r\n            if (length !== value) {\r\n                start = length - value;\r\n                length = value;\r\n            }\r\n            if (floating) {\r\n                value = custom.barStart;\r\n                length = custom.barEnd - custom.barStart;\r\n                if (value !== 0 && sign(value) !== sign(custom.barEnd)) {\r\n                    start = 0;\r\n                }\r\n                start += value;\r\n            }\r\n            const startValue = !isNullOrUndef(baseValue) && !floating ? baseValue : start;\r\n            let base = vScale.getPixelForValue(startValue);\r\n            if (this.chart.getDataVisibility(index)) {\r\n                head = vScale.getPixelForValue(start + length);\r\n            } else {\r\n                head = base;\r\n            }\r\n            size = head - base;\r\n            if (minBarLength !== undefined && Math.abs(size) < minBarLength) {\r\n                size = size < 0 ? -minBarLength : minBarLength;\r\n                if (value === 0) {\r\n                    base -= size / 2;\r\n                }\r\n                head = base + size;\r\n            }\r\n            const actualBase = baseValue || 0;\r\n            if (base === vScale.getPixelForValue(actualBase)) {\r\n                const halfGrid = vScale.getLineWidthForValue(actualBase) / 2;\r\n                if (size > 0) {\r\n                    base += halfGrid;\r\n                    size -= halfGrid;\r\n                } else if (size < 0) {\r\n                    base -= halfGrid;\r\n                    size += halfGrid;\r\n                }\r\n            }\r\n            return {\r\n                size,\r\n                base,\r\n                head,\r\n                center: head + size / 2\r\n            };\r\n        }\r\n\r\n        _calculateBarIndexPixels(index, ruler) {\r\n            const me = this;\r\n            const scale = ruler.scale;\r\n            const options = me.options;\r\n            const maxBarThickness = valueOrDefault(options.maxBarThickness, Infinity);\r\n            let center, size;\r\n            if (ruler.grouped) {\r\n                const stackCount = options.skipNull ? me._getStackCount(index) : ruler.stackCount;\r\n                const range = options.barThickness === 'flex'\r\n                    ? computeFlexCategoryTraits(index, ruler, options, stackCount)\r\n                    : computeFitCategoryTraits(index, ruler, options, stackCount);\r\n                const stackIndex = me._getStackIndex(me.index, me._cachedMeta.stack);\r\n                center = range.start + (range.chunk * stackIndex) + (range.chunk / 2);\r\n                size = Math.min(maxBarThickness, range.chunk * range.ratio);\r\n            } else {\r\n                center = scale.getPixelForValue(me.getParsed(index)[scale.axis], index);\r\n                size = Math.min(maxBarThickness, ruler.min * ruler.ratio);\r\n            }\r\n            return {\r\n                base: center - size / 2,\r\n                head: center + size / 2,\r\n                center,\r\n                size\r\n            };\r\n        }\r\n\r\n        draw() {\r\n            const me = this;\r\n            const chart = me.chart;\r\n            const meta = me._cachedMeta;\r\n            const vScale = meta.vScale;\r\n            const rects = meta.data;\r\n            const ilen = rects.length;\r\n            let i = 0;\r\n            clipArea(chart.ctx, chart.chartArea);\r\n            for (; i < ilen; ++i) {\r\n                if (me.getParsed(i)[vScale.axis] !== null) {\r\n                    rects[i].draw(me._ctx);\r\n                }\r\n            }\r\n            unclipArea(chart.ctx);\r\n        }\r\n    }\r\n\r\n    BarController.id = 'bar';\r\n    BarController.defaults = {\r\n        datasetElementType: false,\r\n        dataElementType: 'bar',\r\n        categoryPercentage: 0.8,\r\n        barPercentage: 0.9,\r\n        grouped: true,\r\n        animations: {\r\n            numbers: {\r\n                type: 'number',\r\n                properties: ['x', 'y', 'base', 'width', 'height']\r\n            }\r\n        }\r\n    };\r\n    BarController.overrides = {\r\n        interaction: {\r\n            mode: 'index'\r\n        },\r\n        scales: {\r\n            _index_: {\r\n                type: 'category',\r\n                offset: true,\r\n                grid: {\r\n                    offset: true\r\n                }\r\n            },\r\n            _value_: {\r\n                type: 'linear',\r\n                beginAtZero: true,\r\n            }\r\n        }\r\n    };\r\n\r\n    class BubbleController extends DatasetController {\r\n        initialize() {\r\n            this.enableOptionSharing = true;\r\n            super.initialize();\r\n        }\r\n\r\n        parseObjectData(meta, data, start, count) {\r\n            const {xScale, yScale} = meta;\r\n            const {xAxisKey = 'x', yAxisKey = 'y'} = this._parsing;\r\n            const parsed = [];\r\n            let i, ilen, item;\r\n            for (i = start, ilen = start + count; i < ilen; ++i) {\r\n                item = data[i];\r\n                parsed.push({\r\n                    x: xScale.parse(resolveObjectKey(item, xAxisKey), i),\r\n                    y: yScale.parse(resolveObjectKey(item, yAxisKey), i),\r\n                    _custom: item && item.r && +item.r\r\n                });\r\n            }\r\n            return parsed;\r\n        }\r\n\r\n        getMaxOverflow() {\r\n            const {data, _parsed} = this._cachedMeta;\r\n            let max = 0;\r\n            for (let i = data.length - 1; i >= 0; --i) {\r\n                max = Math.max(max, data[i].size() / 2, _parsed[i]._custom);\r\n            }\r\n            return max > 0 && max;\r\n        }\r\n\r\n        getLabelAndValue(index) {\r\n            const me = this;\r\n            const meta = me._cachedMeta;\r\n            const {xScale, yScale} = meta;\r\n            const parsed = me.getParsed(index);\r\n            const x = xScale.getLabelForValue(parsed.x);\r\n            const y = yScale.getLabelForValue(parsed.y);\r\n            const r = parsed._custom;\r\n            return {\r\n                label: meta.label,\r\n                value: '(' + x + ', ' + y + (r ? ', ' + r : '') + ')'\r\n            };\r\n        }\r\n\r\n        update(mode) {\r\n            const me = this;\r\n            const points = me._cachedMeta.data;\r\n            me.updateElements(points, 0, points.length, mode);\r\n        }\r\n\r\n        updateElements(points, start, count, mode) {\r\n            const me = this;\r\n            const reset = mode === 'reset';\r\n            const {xScale, yScale} = me._cachedMeta;\r\n            const firstOpts = me.resolveDataElementOptions(start, mode);\r\n            const sharedOptions = me.getSharedOptions(firstOpts);\r\n            const includeOptions = me.includeOptions(mode, sharedOptions);\r\n            for (let i = start; i < start + count; i++) {\r\n                const point = points[i];\r\n                const parsed = !reset && me.getParsed(i);\r\n                const x = reset ? xScale.getPixelForDecimal(0.5) : xScale.getPixelForValue(parsed.x);\r\n                const y = reset ? yScale.getBasePixel() : yScale.getPixelForValue(parsed.y);\r\n                const properties = {\r\n                    x,\r\n                    y,\r\n                    skip: isNaN(x) || isNaN(y)\r\n                };\r\n                if (includeOptions) {\r\n                    properties.options = me.resolveDataElementOptions(i, mode);\r\n                    if (reset) {\r\n                        properties.options.radius = 0;\r\n                    }\r\n                }\r\n                me.updateElement(point, i, properties, mode);\r\n            }\r\n            me.updateSharedOptions(sharedOptions, mode, firstOpts);\r\n        }\r\n\r\n        resolveDataElementOptions(index, mode) {\r\n            const parsed = this.getParsed(index);\r\n            let values = super.resolveDataElementOptions(index, mode);\r\n            if (values.$shared) {\r\n                values = Object.assign({}, values, {$shared: false});\r\n            }\r\n            const radius = values.radius;\r\n            if (mode !== 'active') {\r\n                values.radius = 0;\r\n            }\r\n            values.radius += valueOrDefault(parsed && parsed._custom, radius);\r\n            return values;\r\n        }\r\n    }\r\n\r\n    BubbleController.id = 'bubble';\r\n    BubbleController.defaults = {\r\n        datasetElementType: false,\r\n        dataElementType: 'point',\r\n        animations: {\r\n            numbers: {\r\n                type: 'number',\r\n                properties: ['x', 'y', 'borderWidth', 'radius']\r\n            }\r\n        }\r\n    };\r\n    BubbleController.overrides = {\r\n        scales: {\r\n            x: {\r\n                type: 'linear'\r\n            },\r\n            y: {\r\n                type: 'linear'\r\n            }\r\n        },\r\n        plugins: {\r\n            tooltip: {\r\n                callbacks: {\r\n                    title() {\r\n                        return '';\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    };\r\n\r\n    function getRatioAndOffset(rotation, circumference, cutout) {\r\n        let ratioX = 1;\r\n        let ratioY = 1;\r\n        let offsetX = 0;\r\n        let offsetY = 0;\r\n        if (circumference < TAU) {\r\n            const startAngle = rotation;\r\n            const endAngle = startAngle + circumference;\r\n            const startX = Math.cos(startAngle);\r\n            const startY = Math.sin(startAngle);\r\n            const endX = Math.cos(endAngle);\r\n            const endY = Math.sin(endAngle);\r\n            const calcMax = (angle, a, b) => _angleBetween(angle, startAngle, endAngle) ? 1 : Math.max(a, a * cutout, b, b * cutout);\r\n            const calcMin = (angle, a, b) => _angleBetween(angle, startAngle, endAngle) ? -1 : Math.min(a, a * cutout, b, b * cutout);\r\n            const maxX = calcMax(0, startX, endX);\r\n            const maxY = calcMax(HALF_PI, startY, endY);\r\n            const minX = calcMin(PI, startX, endX);\r\n            const minY = calcMin(PI + HALF_PI, startY, endY);\r\n            ratioX = (maxX - minX) / 2;\r\n            ratioY = (maxY - minY) / 2;\r\n            offsetX = -(maxX + minX) / 2;\r\n            offsetY = -(maxY + minY) / 2;\r\n        }\r\n        return {ratioX, ratioY, offsetX, offsetY};\r\n    }\r\n\r\n    class DoughnutController extends DatasetController {\r\n        constructor(chart, datasetIndex) {\r\n            super(chart, datasetIndex);\r\n            this.enableOptionSharing = true;\r\n            this.innerRadius = undefined;\r\n            this.outerRadius = undefined;\r\n            this.offsetX = undefined;\r\n            this.offsetY = undefined;\r\n        }\r\n\r\n        linkScales() {\r\n        }\r\n\r\n        parse(start, count) {\r\n            const data = this.getDataset().data;\r\n            const meta = this._cachedMeta;\r\n            let i, ilen;\r\n            for (i = start, ilen = start + count; i < ilen; ++i) {\r\n                meta._parsed[i] = +data[i];\r\n            }\r\n        }\r\n\r\n        _getRotation() {\r\n            return toRadians(this.options.rotation - 90);\r\n        }\r\n\r\n        _getCircumference() {\r\n            return toRadians(this.options.circumference);\r\n        }\r\n\r\n        _getRotationExtents() {\r\n            let min = TAU;\r\n            let max = -TAU;\r\n            const me = this;\r\n            for (let i = 0; i < me.chart.data.datasets.length; ++i) {\r\n                if (me.chart.isDatasetVisible(i)) {\r\n                    const controller = me.chart.getDatasetMeta(i).controller;\r\n                    const rotation = controller._getRotation();\r\n                    const circumference = controller._getCircumference();\r\n                    min = Math.min(min, rotation);\r\n                    max = Math.max(max, rotation + circumference);\r\n                }\r\n            }\r\n            return {\r\n                rotation: min,\r\n                circumference: max - min,\r\n            };\r\n        }\r\n\r\n        update(mode) {\r\n            const me = this;\r\n            const chart = me.chart;\r\n            const {chartArea} = chart;\r\n            const meta = me._cachedMeta;\r\n            const arcs = meta.data;\r\n            const spacing = me.getMaxBorderWidth() + me.getMaxOffset(arcs);\r\n            const maxSize = Math.max((Math.min(chartArea.width, chartArea.height) - spacing) / 2, 0);\r\n            const cutout = Math.min(toPercentage(me.options.cutout, maxSize), 1);\r\n            const chartWeight = me._getRingWeight(me.index);\r\n            const {circumference, rotation} = me._getRotationExtents();\r\n            const {ratioX, ratioY, offsetX, offsetY} = getRatioAndOffset(rotation, circumference, cutout);\r\n            const maxWidth = (chartArea.width - spacing) / ratioX;\r\n            const maxHeight = (chartArea.height - spacing) / ratioY;\r\n            const maxRadius = Math.max(Math.min(maxWidth, maxHeight) / 2, 0);\r\n            const outerRadius = toDimension(me.options.radius, maxRadius);\r\n            const innerRadius = Math.max(outerRadius * cutout, 0);\r\n            const radiusLength = (outerRadius - innerRadius) / me._getVisibleDatasetWeightTotal();\r\n            me.offsetX = offsetX * outerRadius;\r\n            me.offsetY = offsetY * outerRadius;\r\n            meta.total = me.calculateTotal();\r\n            me.outerRadius = outerRadius - radiusLength * me._getRingWeightOffset(me.index);\r\n            me.innerRadius = Math.max(me.outerRadius - radiusLength * chartWeight, 0);\r\n            me.updateElements(arcs, 0, arcs.length, mode);\r\n        }\r\n\r\n        _circumference(i, reset) {\r\n            const me = this;\r\n            const opts = me.options;\r\n            const meta = me._cachedMeta;\r\n            const circumference = me._getCircumference();\r\n            if ((reset && opts.animation.animateRotate) || !this.chart.getDataVisibility(i) || meta._parsed[i] === null) {\r\n                return 0;\r\n            }\r\n            return me.calculateCircumference(meta._parsed[i] * circumference / TAU);\r\n        }\r\n\r\n        updateElements(arcs, start, count, mode) {\r\n            const me = this;\r\n            const reset = mode === 'reset';\r\n            const chart = me.chart;\r\n            const chartArea = chart.chartArea;\r\n            const opts = chart.options;\r\n            const animationOpts = opts.animation;\r\n            const centerX = (chartArea.left + chartArea.right) / 2;\r\n            const centerY = (chartArea.top + chartArea.bottom) / 2;\r\n            const animateScale = reset && animationOpts.animateScale;\r\n            const innerRadius = animateScale ? 0 : me.innerRadius;\r\n            const outerRadius = animateScale ? 0 : me.outerRadius;\r\n            const firstOpts = me.resolveDataElementOptions(start, mode);\r\n            const sharedOptions = me.getSharedOptions(firstOpts);\r\n            const includeOptions = me.includeOptions(mode, sharedOptions);\r\n            let startAngle = me._getRotation();\r\n            let i;\r\n            for (i = 0; i < start; ++i) {\r\n                startAngle += me._circumference(i, reset);\r\n            }\r\n            for (i = start; i < start + count; ++i) {\r\n                const circumference = me._circumference(i, reset);\r\n                const arc = arcs[i];\r\n                const properties = {\r\n                    x: centerX + me.offsetX,\r\n                    y: centerY + me.offsetY,\r\n                    startAngle,\r\n                    endAngle: startAngle + circumference,\r\n                    circumference,\r\n                    outerRadius,\r\n                    innerRadius\r\n                };\r\n                if (includeOptions) {\r\n                    properties.options = sharedOptions || me.resolveDataElementOptions(i, mode);\r\n                }\r\n                startAngle += circumference;\r\n                me.updateElement(arc, i, properties, mode);\r\n            }\r\n            me.updateSharedOptions(sharedOptions, mode, firstOpts);\r\n        }\r\n\r\n        calculateTotal() {\r\n            const meta = this._cachedMeta;\r\n            const metaData = meta.data;\r\n            let total = 0;\r\n            let i;\r\n            for (i = 0; i < metaData.length; i++) {\r\n                const value = meta._parsed[i];\r\n                if (value !== null && !isNaN(value) && this.chart.getDataVisibility(i)) {\r\n                    total += Math.abs(value);\r\n                }\r\n            }\r\n            return total;\r\n        }\r\n\r\n        calculateCircumference(value) {\r\n            const total = this._cachedMeta.total;\r\n            if (total > 0 && !isNaN(value)) {\r\n                return TAU * (Math.abs(value) / total);\r\n            }\r\n            return 0;\r\n        }\r\n\r\n        getLabelAndValue(index) {\r\n            const me = this;\r\n            const meta = me._cachedMeta;\r\n            const chart = me.chart;\r\n            const labels = chart.data.labels || [];\r\n            const value = formatNumber(meta._parsed[index], chart.options.locale);\r\n            return {\r\n                label: labels[index] || '',\r\n                value,\r\n            };\r\n        }\r\n\r\n        getMaxBorderWidth(arcs) {\r\n            const me = this;\r\n            let max = 0;\r\n            const chart = me.chart;\r\n            let i, ilen, meta, controller, options;\r\n            if (!arcs) {\r\n                for (i = 0, ilen = chart.data.datasets.length; i < ilen; ++i) {\r\n                    if (chart.isDatasetVisible(i)) {\r\n                        meta = chart.getDatasetMeta(i);\r\n                        arcs = meta.data;\r\n                        controller = meta.controller;\r\n                        if (controller !== me) {\r\n                            controller.configure();\r\n                        }\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n            if (!arcs) {\r\n                return 0;\r\n            }\r\n            for (i = 0, ilen = arcs.length; i < ilen; ++i) {\r\n                options = controller.resolveDataElementOptions(i);\r\n                if (options.borderAlign !== 'inner') {\r\n                    max = Math.max(max, options.borderWidth || 0, options.hoverBorderWidth || 0);\r\n                }\r\n            }\r\n            return max;\r\n        }\r\n\r\n        getMaxOffset(arcs) {\r\n            let max = 0;\r\n            for (let i = 0, ilen = arcs.length; i < ilen; ++i) {\r\n                const options = this.resolveDataElementOptions(i);\r\n                max = Math.max(max, options.offset || 0, options.hoverOffset || 0);\r\n            }\r\n            return max;\r\n        }\r\n\r\n        _getRingWeightOffset(datasetIndex) {\r\n            let ringWeightOffset = 0;\r\n            for (let i = 0; i < datasetIndex; ++i) {\r\n                if (this.chart.isDatasetVisible(i)) {\r\n                    ringWeightOffset += this._getRingWeight(i);\r\n                }\r\n            }\r\n            return ringWeightOffset;\r\n        }\r\n\r\n        _getRingWeight(datasetIndex) {\r\n            return Math.max(valueOrDefault(this.chart.data.datasets[datasetIndex].weight, 1), 0);\r\n        }\r\n\r\n        _getVisibleDatasetWeightTotal() {\r\n            return this._getRingWeightOffset(this.chart.data.datasets.length) || 1;\r\n        }\r\n    }\r\n\r\n    DoughnutController.id = 'doughnut';\r\n    DoughnutController.defaults = {\r\n        datasetElementType: false,\r\n        dataElementType: 'arc',\r\n        animation: {\r\n            animateRotate: true,\r\n            animateScale: false\r\n        },\r\n        animations: {\r\n            numbers: {\r\n                type: 'number',\r\n                properties: ['circumference', 'endAngle', 'innerRadius', 'outerRadius', 'startAngle', 'x', 'y', 'offset', 'borderWidth']\r\n            },\r\n        },\r\n        cutout: '50%',\r\n        rotation: 0,\r\n        circumference: 360,\r\n        radius: '100%',\r\n        indexAxis: 'r',\r\n    };\r\n    DoughnutController.overrides = {\r\n        aspectRatio: 1,\r\n        plugins: {\r\n            legend: {\r\n                labels: {\r\n                    generateLabels(chart) {\r\n                        const data = chart.data;\r\n                        if (data.labels.length && data.datasets.length) {\r\n                            return data.labels.map((label, i) => {\r\n                                const meta = chart.getDatasetMeta(0);\r\n                                const style = meta.controller.getStyle(i);\r\n                                return {\r\n                                    text: label,\r\n                                    fillStyle: style.backgroundColor,\r\n                                    strokeStyle: style.borderColor,\r\n                                    lineWidth: style.borderWidth,\r\n                                    hidden: !chart.getDataVisibility(i),\r\n                                    index: i\r\n                                };\r\n                            });\r\n                        }\r\n                        return [];\r\n                    }\r\n                },\r\n                onClick(e, legendItem, legend) {\r\n                    legend.chart.toggleDataVisibility(legendItem.index);\r\n                    legend.chart.update();\r\n                }\r\n            },\r\n            tooltip: {\r\n                callbacks: {\r\n                    title() {\r\n                        return '';\r\n                    },\r\n                    label(tooltipItem) {\r\n                        let dataLabel = tooltipItem.label;\r\n                        const value = ': ' + tooltipItem.formattedValue;\r\n                        if (isArray(dataLabel)) {\r\n                            dataLabel = dataLabel.slice();\r\n                            dataLabel[0] += value;\r\n                        } else {\r\n                            dataLabel += value;\r\n                        }\r\n                        return dataLabel;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    };\r\n\r\n    class LineController extends DatasetController {\r\n        initialize() {\r\n            this.enableOptionSharing = true;\r\n            super.initialize();\r\n        }\r\n\r\n        update(mode) {\r\n            const me = this;\r\n            const meta = me._cachedMeta;\r\n            const {dataset: line, data: points = [], _dataset} = meta;\r\n            const animationsDisabled = me.chart._animationsDisabled;\r\n            let {start, count} = getStartAndCountOfVisiblePoints(meta, points, animationsDisabled);\r\n            me._drawStart = start;\r\n            me._drawCount = count;\r\n            if (scaleRangesChanged(meta)) {\r\n                start = 0;\r\n                count = points.length;\r\n            }\r\n            line._decimated = !!_dataset._decimated;\r\n            line.points = points;\r\n            if (mode !== 'resize') {\r\n                const options = me.resolveDatasetElementOptions(mode);\r\n                if (!me.options.showLine) {\r\n                    options.borderWidth = 0;\r\n                }\r\n                me.updateElement(line, undefined, {\r\n                    animated: !animationsDisabled,\r\n                    options\r\n                }, mode);\r\n            }\r\n            me.updateElements(points, start, count, mode);\r\n        }\r\n\r\n        updateElements(points, start, count, mode) {\r\n            const me = this;\r\n            const reset = mode === 'reset';\r\n            const {xScale, yScale, _stacked} = me._cachedMeta;\r\n            const firstOpts = me.resolveDataElementOptions(start, mode);\r\n            const sharedOptions = me.getSharedOptions(firstOpts);\r\n            const includeOptions = me.includeOptions(mode, sharedOptions);\r\n            const spanGaps = me.options.spanGaps;\r\n            const maxGapLength = isNumber(spanGaps) ? spanGaps : Number.POSITIVE_INFINITY;\r\n            const directUpdate = me.chart._animationsDisabled || reset || mode === 'none';\r\n            let prevParsed = start > 0 && me.getParsed(start - 1);\r\n            for (let i = start; i < start + count; ++i) {\r\n                const point = points[i];\r\n                const parsed = me.getParsed(i);\r\n                const properties = directUpdate ? point : {};\r\n                const x = properties.x = xScale.getPixelForValue(parsed.x, i);\r\n                const y = properties.y = reset ? yScale.getBasePixel() : yScale.getPixelForValue(_stacked ? me.applyStack(yScale, parsed, _stacked) : parsed.y, i);\r\n                properties.skip = isNaN(x) || isNaN(y);\r\n                properties.stop = i > 0 && (parsed.x - prevParsed.x) > maxGapLength;\r\n                if (includeOptions) {\r\n                    properties.options = sharedOptions || me.resolveDataElementOptions(i, mode);\r\n                }\r\n                if (!directUpdate) {\r\n                    me.updateElement(point, i, properties, mode);\r\n                }\r\n                prevParsed = parsed;\r\n            }\r\n            me.updateSharedOptions(sharedOptions, mode, firstOpts);\r\n        }\r\n\r\n        getMaxOverflow() {\r\n            const me = this;\r\n            const meta = me._cachedMeta;\r\n            const dataset = meta.dataset;\r\n            const border = dataset.options && dataset.options.borderWidth || 0;\r\n            const data = meta.data || [];\r\n            if (!data.length) {\r\n                return border;\r\n            }\r\n            const firstPoint = data[0].size(me.resolveDataElementOptions(0));\r\n            const lastPoint = data[data.length - 1].size(me.resolveDataElementOptions(data.length - 1));\r\n            return Math.max(border, firstPoint, lastPoint) / 2;\r\n        }\r\n\r\n        draw() {\r\n            this._cachedMeta.dataset.updateControlPoints(this.chart.chartArea);\r\n            super.draw();\r\n        }\r\n    }\r\n\r\n    LineController.id = 'line';\r\n    LineController.defaults = {\r\n        datasetElementType: 'line',\r\n        dataElementType: 'point',\r\n        showLine: true,\r\n        spanGaps: false,\r\n    };\r\n    LineController.overrides = {\r\n        scales: {\r\n            _index_: {\r\n                type: 'category',\r\n            },\r\n            _value_: {\r\n                type: 'linear',\r\n            },\r\n        }\r\n    };\r\n\r\n    function getStartAndCountOfVisiblePoints(meta, points, animationsDisabled) {\r\n        const pointCount = points.length;\r\n        let start = 0;\r\n        let count = pointCount;\r\n        if (meta._sorted) {\r\n            const {iScale, _parsed} = meta;\r\n            const axis = iScale.axis;\r\n            const {min, max, minDefined, maxDefined} = iScale.getUserBounds();\r\n            if (minDefined) {\r\n                start = _limitValue(Math.min(\r\n                    _lookupByKey(_parsed, iScale.axis, min).lo,\r\n                    animationsDisabled ? pointCount : _lookupByKey(points, axis, iScale.getPixelForValue(min)).lo),\r\n                    0, pointCount - 1);\r\n            }\r\n            if (maxDefined) {\r\n                count = _limitValue(Math.max(\r\n                    _lookupByKey(_parsed, iScale.axis, max).hi + 1,\r\n                    animationsDisabled ? 0 : _lookupByKey(points, axis, iScale.getPixelForValue(max)).hi + 1),\r\n                    start, pointCount) - start;\r\n            } else {\r\n                count = pointCount - start;\r\n            }\r\n        }\r\n        return {start, count};\r\n    }\r\n\r\n    function scaleRangesChanged(meta) {\r\n        const {xScale, yScale, _scaleRanges} = meta;\r\n        const newRanges = {\r\n            xmin: xScale.min,\r\n            xmax: xScale.max,\r\n            ymin: yScale.min,\r\n            ymax: yScale.max\r\n        };\r\n        if (!_scaleRanges) {\r\n            meta._scaleRanges = newRanges;\r\n            return true;\r\n        }\r\n        const changed = _scaleRanges.xmin !== xScale.min\r\n            || _scaleRanges.xmax !== xScale.max\r\n            || _scaleRanges.ymin !== yScale.min\r\n            || _scaleRanges.ymax !== yScale.max;\r\n        Object.assign(_scaleRanges, newRanges);\r\n        return changed;\r\n    }\r\n\r\n    class PolarAreaController extends DatasetController {\r\n        constructor(chart, datasetIndex) {\r\n            super(chart, datasetIndex);\r\n            this.innerRadius = undefined;\r\n            this.outerRadius = undefined;\r\n        }\r\n\r\n        update(mode) {\r\n            const arcs = this._cachedMeta.data;\r\n            this._updateRadius();\r\n            this.updateElements(arcs, 0, arcs.length, mode);\r\n        }\r\n\r\n        _updateRadius() {\r\n            const me = this;\r\n            const chart = me.chart;\r\n            const chartArea = chart.chartArea;\r\n            const opts = chart.options;\r\n            const minSize = Math.min(chartArea.right - chartArea.left, chartArea.bottom - chartArea.top);\r\n            const outerRadius = Math.max(minSize / 2, 0);\r\n            const innerRadius = Math.max(opts.cutoutPercentage ? (outerRadius / 100) * (opts.cutoutPercentage) : 1, 0);\r\n            const radiusLength = (outerRadius - innerRadius) / chart.getVisibleDatasetCount();\r\n            me.outerRadius = outerRadius - (radiusLength * me.index);\r\n            me.innerRadius = me.outerRadius - radiusLength;\r\n        }\r\n\r\n        updateElements(arcs, start, count, mode) {\r\n            const me = this;\r\n            const reset = mode === 'reset';\r\n            const chart = me.chart;\r\n            const dataset = me.getDataset();\r\n            const opts = chart.options;\r\n            const animationOpts = opts.animation;\r\n            const scale = me._cachedMeta.rScale;\r\n            const centerX = scale.xCenter;\r\n            const centerY = scale.yCenter;\r\n            const datasetStartAngle = scale.getIndexAngle(0) - 0.5 * PI;\r\n            let angle = datasetStartAngle;\r\n            let i;\r\n            const defaultAngle = 360 / me.countVisibleElements();\r\n            for (i = 0; i < start; ++i) {\r\n                angle += me._computeAngle(i, mode, defaultAngle);\r\n            }\r\n            for (i = start; i < start + count; i++) {\r\n                const arc = arcs[i];\r\n                let startAngle = angle;\r\n                let endAngle = angle + me._computeAngle(i, mode, defaultAngle);\r\n                let outerRadius = chart.getDataVisibility(i) ? scale.getDistanceFromCenterForValue(dataset.data[i]) : 0;\r\n                angle = endAngle;\r\n                if (reset) {\r\n                    if (animationOpts.animateScale) {\r\n                        outerRadius = 0;\r\n                    }\r\n                    if (animationOpts.animateRotate) {\r\n                        startAngle = endAngle = datasetStartAngle;\r\n                    }\r\n                }\r\n                const properties = {\r\n                    x: centerX,\r\n                    y: centerY,\r\n                    innerRadius: 0,\r\n                    outerRadius,\r\n                    startAngle,\r\n                    endAngle,\r\n                    options: me.resolveDataElementOptions(i, mode)\r\n                };\r\n                me.updateElement(arc, i, properties, mode);\r\n            }\r\n        }\r\n\r\n        countVisibleElements() {\r\n            const dataset = this.getDataset();\r\n            const meta = this._cachedMeta;\r\n            let count = 0;\r\n            meta.data.forEach((element, index) => {\r\n                if (!isNaN(dataset.data[index]) && this.chart.getDataVisibility(index)) {\r\n                    count++;\r\n                }\r\n            });\r\n            return count;\r\n        }\r\n\r\n        _computeAngle(index, mode, defaultAngle) {\r\n            return this.chart.getDataVisibility(index)\r\n                ? toRadians(this.resolveDataElementOptions(index, mode).angle || defaultAngle)\r\n                : 0;\r\n        }\r\n    }\r\n\r\n    PolarAreaController.id = 'polarArea';\r\n    PolarAreaController.defaults = {\r\n        dataElementType: 'arc',\r\n        animation: {\r\n            animateRotate: true,\r\n            animateScale: true\r\n        },\r\n        animations: {\r\n            numbers: {\r\n                type: 'number',\r\n                properties: ['x', 'y', 'startAngle', 'endAngle', 'innerRadius', 'outerRadius']\r\n            },\r\n        },\r\n        indexAxis: 'r',\r\n        startAngle: 0,\r\n    };\r\n    PolarAreaController.overrides = {\r\n        aspectRatio: 1,\r\n        plugins: {\r\n            legend: {\r\n                labels: {\r\n                    generateLabels(chart) {\r\n                        const data = chart.data;\r\n                        if (data.labels.length && data.datasets.length) {\r\n                            return data.labels.map((label, i) => {\r\n                                const meta = chart.getDatasetMeta(0);\r\n                                const style = meta.controller.getStyle(i);\r\n                                return {\r\n                                    text: label,\r\n                                    fillStyle: style.backgroundColor,\r\n                                    strokeStyle: style.borderColor,\r\n                                    lineWidth: style.borderWidth,\r\n                                    hidden: !chart.getDataVisibility(i),\r\n                                    index: i\r\n                                };\r\n                            });\r\n                        }\r\n                        return [];\r\n                    }\r\n                },\r\n                onClick(e, legendItem, legend) {\r\n                    legend.chart.toggleDataVisibility(legendItem.index);\r\n                    legend.chart.update();\r\n                }\r\n            },\r\n            tooltip: {\r\n                callbacks: {\r\n                    title() {\r\n                        return '';\r\n                    },\r\n                    label(context) {\r\n                        return context.chart.data.labels[context.dataIndex] + ': ' + context.formattedValue;\r\n                    }\r\n                }\r\n            }\r\n        },\r\n        scales: {\r\n            r: {\r\n                type: 'radialLinear',\r\n                angleLines: {\r\n                    display: false\r\n                },\r\n                beginAtZero: true,\r\n                grid: {\r\n                    circular: true\r\n                },\r\n                pointLabels: {\r\n                    display: false\r\n                },\r\n                startAngle: 0\r\n            }\r\n        }\r\n    };\r\n\r\n    class PieController extends DoughnutController {\r\n    }\r\n\r\n    PieController.id = 'pie';\r\n    PieController.defaults = {\r\n        cutout: 0,\r\n        rotation: 0,\r\n        circumference: 360,\r\n        radius: '100%'\r\n    };\r\n\r\n    class RadarController extends DatasetController {\r\n        getLabelAndValue(index) {\r\n            const me = this;\r\n            const vScale = me._cachedMeta.vScale;\r\n            const parsed = me.getParsed(index);\r\n            return {\r\n                label: vScale.getLabels()[index],\r\n                value: '' + vScale.getLabelForValue(parsed[vScale.axis])\r\n            };\r\n        }\r\n\r\n        update(mode) {\r\n            const me = this;\r\n            const meta = me._cachedMeta;\r\n            const line = meta.dataset;\r\n            const points = meta.data || [];\r\n            const labels = meta.iScale.getLabels();\r\n            line.points = points;\r\n            if (mode !== 'resize') {\r\n                const options = me.resolveDatasetElementOptions(mode);\r\n                if (!me.options.showLine) {\r\n                    options.borderWidth = 0;\r\n                }\r\n                const properties = {\r\n                    _loop: true,\r\n                    _fullLoop: labels.length === points.length,\r\n                    options\r\n                };\r\n                me.updateElement(line, undefined, properties, mode);\r\n            }\r\n            me.updateElements(points, 0, points.length, mode);\r\n        }\r\n\r\n        updateElements(points, start, count, mode) {\r\n            const me = this;\r\n            const dataset = me.getDataset();\r\n            const scale = me._cachedMeta.rScale;\r\n            const reset = mode === 'reset';\r\n            for (let i = start; i < start + count; i++) {\r\n                const point = points[i];\r\n                const options = me.resolveDataElementOptions(i, mode);\r\n                const pointPosition = scale.getPointPositionForValue(i, dataset.data[i]);\r\n                const x = reset ? scale.xCenter : pointPosition.x;\r\n                const y = reset ? scale.yCenter : pointPosition.y;\r\n                const properties = {\r\n                    x,\r\n                    y,\r\n                    angle: pointPosition.angle,\r\n                    skip: isNaN(x) || isNaN(y),\r\n                    options\r\n                };\r\n                me.updateElement(point, i, properties, mode);\r\n            }\r\n        }\r\n    }\r\n\r\n    RadarController.id = 'radar';\r\n    RadarController.defaults = {\r\n        datasetElementType: 'line',\r\n        dataElementType: 'point',\r\n        indexAxis: 'r',\r\n        showLine: true,\r\n        elements: {\r\n            line: {\r\n                fill: 'start'\r\n            }\r\n        },\r\n    };\r\n    RadarController.overrides = {\r\n        aspectRatio: 1,\r\n        scales: {\r\n            r: {\r\n                type: 'radialLinear',\r\n            }\r\n        }\r\n    };\r\n\r\n    class ScatterController extends LineController {\r\n    }\r\n\r\n    ScatterController.id = 'scatter';\r\n    ScatterController.defaults = {\r\n        showLine: false,\r\n        fill: false\r\n    };\r\n    ScatterController.overrides = {\r\n        interaction: {\r\n            mode: 'point'\r\n        },\r\n        plugins: {\r\n            tooltip: {\r\n                callbacks: {\r\n                    title() {\r\n                        return '';\r\n                    },\r\n                    label(item) {\r\n                        return '(' + item.label + ', ' + item.formattedValue + ')';\r\n                    }\r\n                }\r\n            }\r\n        },\r\n        scales: {\r\n            x: {\r\n                type: 'linear'\r\n            },\r\n            y: {\r\n                type: 'linear'\r\n            }\r\n        }\r\n    };\r\n\r\n    var controllers = /*#__PURE__*/Object.freeze({\r\n        __proto__: null,\r\n        BarController: BarController,\r\n        BubbleController: BubbleController,\r\n        DoughnutController: DoughnutController,\r\n        LineController: LineController,\r\n        PolarAreaController: PolarAreaController,\r\n        PieController: PieController,\r\n        RadarController: RadarController,\r\n        ScatterController: ScatterController\r\n    });\r\n\r\n    function clipArc(ctx, element) {\r\n        const {startAngle, endAngle, pixelMargin, x, y, outerRadius, innerRadius} = element;\r\n        let angleMargin = pixelMargin / outerRadius;\r\n        ctx.beginPath();\r\n        ctx.arc(x, y, outerRadius, startAngle - angleMargin, endAngle + angleMargin);\r\n        if (innerRadius > pixelMargin) {\r\n            angleMargin = pixelMargin / innerRadius;\r\n            ctx.arc(x, y, innerRadius, endAngle + angleMargin, startAngle - angleMargin, true);\r\n        } else {\r\n            ctx.arc(x, y, pixelMargin, endAngle + HALF_PI, startAngle - HALF_PI);\r\n        }\r\n        ctx.closePath();\r\n        ctx.clip();\r\n    }\r\n\r\n    function pathArc(ctx, element) {\r\n        const {x, y, startAngle, endAngle, pixelMargin} = element;\r\n        const outerRadius = Math.max(element.outerRadius - pixelMargin, 0);\r\n        const innerRadius = element.innerRadius + pixelMargin;\r\n        ctx.beginPath();\r\n        ctx.arc(x, y, outerRadius, startAngle, endAngle);\r\n        ctx.arc(x, y, innerRadius, endAngle, startAngle, true);\r\n        ctx.closePath();\r\n    }\r\n\r\n    function drawArc(ctx, element) {\r\n        if (element.fullCircles) {\r\n            element.endAngle = element.startAngle + TAU;\r\n            pathArc(ctx, element);\r\n            for (let i = 0; i < element.fullCircles; ++i) {\r\n                ctx.fill();\r\n            }\r\n        }\r\n        if (!isNaN(element.circumference)) {\r\n            element.endAngle = element.startAngle + element.circumference % TAU;\r\n        }\r\n        pathArc(ctx, element);\r\n        ctx.fill();\r\n    }\r\n\r\n    function drawFullCircleBorders(ctx, element, inner) {\r\n        const {x, y, startAngle, endAngle, pixelMargin} = element;\r\n        const outerRadius = Math.max(element.outerRadius - pixelMargin, 0);\r\n        const innerRadius = element.innerRadius + pixelMargin;\r\n        let i;\r\n        if (inner) {\r\n            element.endAngle = element.startAngle + TAU;\r\n            clipArc(ctx, element);\r\n            element.endAngle = endAngle;\r\n            if (element.endAngle === element.startAngle) {\r\n                element.endAngle += TAU;\r\n                element.fullCircles--;\r\n            }\r\n        }\r\n        ctx.beginPath();\r\n        ctx.arc(x, y, innerRadius, startAngle + TAU, startAngle, true);\r\n        for (i = 0; i < element.fullCircles; ++i) {\r\n            ctx.stroke();\r\n        }\r\n        ctx.beginPath();\r\n        ctx.arc(x, y, outerRadius, startAngle, startAngle + TAU);\r\n        for (i = 0; i < element.fullCircles; ++i) {\r\n            ctx.stroke();\r\n        }\r\n    }\r\n\r\n    function drawBorder(ctx, element) {\r\n        const {x, y, startAngle, endAngle, pixelMargin, options} = element;\r\n        const outerRadius = element.outerRadius;\r\n        const innerRadius = element.innerRadius + pixelMargin;\r\n        const inner = options.borderAlign === 'inner';\r\n        if (!options.borderWidth) {\r\n            return;\r\n        }\r\n        if (inner) {\r\n            ctx.lineWidth = options.borderWidth * 2;\r\n            ctx.lineJoin = 'round';\r\n        } else {\r\n            ctx.lineWidth = options.borderWidth;\r\n            ctx.lineJoin = 'bevel';\r\n        }\r\n        if (element.fullCircles) {\r\n            drawFullCircleBorders(ctx, element, inner);\r\n        }\r\n        if (inner) {\r\n            clipArc(ctx, element);\r\n        }\r\n        ctx.beginPath();\r\n        ctx.arc(x, y, outerRadius, startAngle, endAngle);\r\n        ctx.arc(x, y, innerRadius, endAngle, startAngle, true);\r\n        ctx.closePath();\r\n        ctx.stroke();\r\n    }\r\n\r\n    class ArcElement extends Element {\r\n        constructor(cfg) {\r\n            super();\r\n            this.options = undefined;\r\n            this.circumference = undefined;\r\n            this.startAngle = undefined;\r\n            this.endAngle = undefined;\r\n            this.innerRadius = undefined;\r\n            this.outerRadius = undefined;\r\n            this.pixelMargin = 0;\r\n            this.fullCircles = 0;\r\n            if (cfg) {\r\n                Object.assign(this, cfg);\r\n            }\r\n        }\r\n\r\n        inRange(chartX, chartY, useFinalPosition) {\r\n            const point = this.getProps(['x', 'y'], useFinalPosition);\r\n            const {angle, distance} = getAngleFromPoint(point, {x: chartX, y: chartY});\r\n            const {startAngle, endAngle, innerRadius, outerRadius, circumference} = this.getProps([\r\n                'startAngle',\r\n                'endAngle',\r\n                'innerRadius',\r\n                'outerRadius',\r\n                'circumference'\r\n            ], useFinalPosition);\r\n            const betweenAngles = circumference >= TAU || _angleBetween(angle, startAngle, endAngle);\r\n            const withinRadius = (distance >= innerRadius && distance <= outerRadius);\r\n            return (betweenAngles && withinRadius);\r\n        }\r\n\r\n        getCenterPoint(useFinalPosition) {\r\n            const {x, y, startAngle, endAngle, innerRadius, outerRadius} = this.getProps([\r\n                'x',\r\n                'y',\r\n                'startAngle',\r\n                'endAngle',\r\n                'innerRadius',\r\n                'outerRadius'\r\n            ], useFinalPosition);\r\n            const halfAngle = (startAngle + endAngle) / 2;\r\n            const halfRadius = (innerRadius + outerRadius) / 2;\r\n            return {\r\n                x: x + Math.cos(halfAngle) * halfRadius,\r\n                y: y + Math.sin(halfAngle) * halfRadius\r\n            };\r\n        }\r\n\r\n        tooltipPosition(useFinalPosition) {\r\n            return this.getCenterPoint(useFinalPosition);\r\n        }\r\n\r\n        draw(ctx) {\r\n            const me = this;\r\n            const options = me.options;\r\n            const offset = options.offset || 0;\r\n            me.pixelMargin = (options.borderAlign === 'inner') ? 0.33 : 0;\r\n            me.fullCircles = Math.floor(me.circumference / TAU);\r\n            if (me.circumference === 0 || me.innerRadius < 0 || me.outerRadius < 0) {\r\n                return;\r\n            }\r\n            ctx.save();\r\n            if (offset && me.circumference < TAU) {\r\n                const halfAngle = (me.startAngle + me.endAngle) / 2;\r\n                ctx.translate(Math.cos(halfAngle) * offset, Math.sin(halfAngle) * offset);\r\n            }\r\n            ctx.fillStyle = options.backgroundColor;\r\n            ctx.strokeStyle = options.borderColor;\r\n            drawArc(ctx, me);\r\n            drawBorder(ctx, me);\r\n            ctx.restore();\r\n        }\r\n    }\r\n\r\n    ArcElement.id = 'arc';\r\n    ArcElement.defaults = {\r\n        borderAlign: 'center',\r\n        borderColor: '#fff',\r\n        borderWidth: 2,\r\n        offset: 0,\r\n        angle: undefined\r\n    };\r\n    ArcElement.defaultRoutes = {\r\n        backgroundColor: 'backgroundColor'\r\n    };\r\n\r\n    function setStyle(ctx, vm) {\r\n        ctx.lineCap = vm.borderCapStyle;\r\n        ctx.setLineDash(vm.borderDash);\r\n        ctx.lineDashOffset = vm.borderDashOffset;\r\n        ctx.lineJoin = vm.borderJoinStyle;\r\n        ctx.lineWidth = vm.borderWidth;\r\n        ctx.strokeStyle = vm.borderColor;\r\n    }\r\n\r\n    function lineTo(ctx, previous, target) {\r\n        ctx.lineTo(target.x, target.y);\r\n    }\r\n\r\n    function getLineMethod(options) {\r\n        if (options.stepped) {\r\n            return _steppedLineTo;\r\n        }\r\n        if (options.tension) {\r\n            return _bezierCurveTo;\r\n        }\r\n        return lineTo;\r\n    }\r\n\r\n    function pathVars(points, segment, params) {\r\n        params = params || {};\r\n        const count = points.length;\r\n        const start = Math.max(params.start || 0, segment.start);\r\n        const end = Math.min(params.end || count - 1, segment.end);\r\n        return {\r\n            count,\r\n            start,\r\n            loop: segment.loop,\r\n            ilen: end < start ? count + end - start : end - start\r\n        };\r\n    }\r\n\r\n    function pathSegment(ctx, line, segment, params) {\r\n        const {points, options} = line;\r\n        const {count, start, loop, ilen} = pathVars(points, segment, params);\r\n        const lineMethod = getLineMethod(options);\r\n        let {move = true, reverse} = params || {};\r\n        let i, point, prev;\r\n        for (i = 0; i <= ilen; ++i) {\r\n            point = points[(start + (reverse ? ilen - i : i)) % count];\r\n            if (point.skip) {\r\n                continue;\r\n            } else if (move) {\r\n                ctx.moveTo(point.x, point.y);\r\n                move = false;\r\n            } else {\r\n                lineMethod(ctx, prev, point, reverse, options.stepped);\r\n            }\r\n            prev = point;\r\n        }\r\n        if (loop) {\r\n            point = points[(start + (reverse ? ilen : 0)) % count];\r\n            lineMethod(ctx, prev, point, reverse, options.stepped);\r\n        }\r\n        return !!loop;\r\n    }\r\n\r\n    function fastPathSegment(ctx, line, segment, params) {\r\n        const points = line.points;\r\n        const {count, start, ilen} = pathVars(points, segment, params);\r\n        const {move = true, reverse} = params || {};\r\n        let avgX = 0;\r\n        let countX = 0;\r\n        let i, point, prevX, minY, maxY, lastY;\r\n        const pointIndex = (index) => (start + (reverse ? ilen - index : index)) % count;\r\n        const drawX = () => {\r\n            if (minY !== maxY) {\r\n                ctx.lineTo(avgX, maxY);\r\n                ctx.lineTo(avgX, minY);\r\n                ctx.lineTo(avgX, lastY);\r\n            }\r\n        };\r\n        if (move) {\r\n            point = points[pointIndex(0)];\r\n            ctx.moveTo(point.x, point.y);\r\n        }\r\n        for (i = 0; i <= ilen; ++i) {\r\n            point = points[pointIndex(i)];\r\n            if (point.skip) {\r\n                continue;\r\n            }\r\n            const x = point.x;\r\n            const y = point.y;\r\n            const truncX = x | 0;\r\n            if (truncX === prevX) {\r\n                if (y < minY) {\r\n                    minY = y;\r\n                } else if (y > maxY) {\r\n                    maxY = y;\r\n                }\r\n                avgX = (countX * avgX + x) / ++countX;\r\n            } else {\r\n                drawX();\r\n                ctx.lineTo(x, y);\r\n                prevX = truncX;\r\n                countX = 0;\r\n                minY = maxY = y;\r\n            }\r\n            lastY = y;\r\n        }\r\n        drawX();\r\n    }\r\n\r\n    function _getSegmentMethod(line) {\r\n        const opts = line.options;\r\n        const borderDash = opts.borderDash && opts.borderDash.length;\r\n        const useFastPath = !line._decimated && !line._loop && !opts.tension && !opts.stepped && !borderDash;\r\n        return useFastPath ? fastPathSegment : pathSegment;\r\n    }\r\n\r\n    function _getInterpolationMethod(options) {\r\n        if (options.stepped) {\r\n            return _steppedInterpolation;\r\n        }\r\n        if (options.tension) {\r\n            return _bezierInterpolation;\r\n        }\r\n        return _pointInLine;\r\n    }\r\n\r\n    function strokePathWithCache(ctx, line, start, count) {\r\n        let path = line._path;\r\n        if (!path) {\r\n            path = line._path = new Path2D();\r\n            if (line.path(path, start, count)) {\r\n                path.closePath();\r\n            }\r\n        }\r\n        ctx.stroke(path);\r\n    }\r\n\r\n    function strokePathDirect(ctx, line, start, count) {\r\n        ctx.beginPath();\r\n        if (line.path(ctx, start, count)) {\r\n            ctx.closePath();\r\n        }\r\n        ctx.stroke();\r\n    }\r\n\r\n    const usePath2D = typeof Path2D === 'function';\r\n    const strokePath = usePath2D ? strokePathWithCache : strokePathDirect;\r\n\r\n    class LineElement extends Element {\r\n        constructor(cfg) {\r\n            super();\r\n            this.animated = true;\r\n            this.options = undefined;\r\n            this._loop = undefined;\r\n            this._fullLoop = undefined;\r\n            this._path = undefined;\r\n            this._points = undefined;\r\n            this._segments = undefined;\r\n            this._decimated = false;\r\n            this._pointsUpdated = false;\r\n            if (cfg) {\r\n                Object.assign(this, cfg);\r\n            }\r\n        }\r\n\r\n        updateControlPoints(chartArea) {\r\n            const me = this;\r\n            const options = me.options;\r\n            if (options.tension && !options.stepped && !me._pointsUpdated) {\r\n                const loop = options.spanGaps ? me._loop : me._fullLoop;\r\n                _updateBezierControlPoints(me._points, options, chartArea, loop);\r\n                me._pointsUpdated = true;\r\n            }\r\n        }\r\n\r\n        set points(points) {\r\n            const me = this;\r\n            me._points = points;\r\n            delete me._segments;\r\n            delete me._path;\r\n            me._pointsUpdated = false;\r\n        }\r\n\r\n        get points() {\r\n            return this._points;\r\n        }\r\n\r\n        get segments() {\r\n            return this._segments || (this._segments = _computeSegments(this));\r\n        }\r\n\r\n        first() {\r\n            const segments = this.segments;\r\n            const points = this.points;\r\n            return segments.length && points[segments[0].start];\r\n        }\r\n\r\n        last() {\r\n            const segments = this.segments;\r\n            const points = this.points;\r\n            const count = segments.length;\r\n            return count && points[segments[count - 1].end];\r\n        }\r\n\r\n        interpolate(point, property) {\r\n            const me = this;\r\n            const options = me.options;\r\n            const value = point[property];\r\n            const points = me.points;\r\n            const segments = _boundSegments(me, {property, start: value, end: value});\r\n            if (!segments.length) {\r\n                return;\r\n            }\r\n            const result = [];\r\n            const _interpolate = _getInterpolationMethod(options);\r\n            let i, ilen;\r\n            for (i = 0, ilen = segments.length; i < ilen; ++i) {\r\n                const {start, end} = segments[i];\r\n                const p1 = points[start];\r\n                const p2 = points[end];\r\n                if (p1 === p2) {\r\n                    result.push(p1);\r\n                    continue;\r\n                }\r\n                const t = Math.abs((value - p1[property]) / (p2[property] - p1[property]));\r\n                const interpolated = _interpolate(p1, p2, t, options.stepped);\r\n                interpolated[property] = point[property];\r\n                result.push(interpolated);\r\n            }\r\n            return result.length === 1 ? result[0] : result;\r\n        }\r\n\r\n        pathSegment(ctx, segment, params) {\r\n            const segmentMethod = _getSegmentMethod(this);\r\n            return segmentMethod(ctx, this, segment, params);\r\n        }\r\n\r\n        path(ctx, start, count) {\r\n            const me = this;\r\n            const segments = me.segments;\r\n            const ilen = segments.length;\r\n            const segmentMethod = _getSegmentMethod(me);\r\n            let loop = me._loop;\r\n            start = start || 0;\r\n            count = count || (me.points.length - start);\r\n            for (let i = 0; i < ilen; ++i) {\r\n                loop &= segmentMethod(ctx, me, segments[i], {start, end: start + count - 1});\r\n            }\r\n            return !!loop;\r\n        }\r\n\r\n        draw(ctx, chartArea, start, count) {\r\n            const me = this;\r\n            const options = me.options || {};\r\n            const points = me.points || [];\r\n            if (!points.length || !options.borderWidth) {\r\n                return;\r\n            }\r\n            ctx.save();\r\n            setStyle(ctx, options);\r\n            strokePath(ctx, me, start, count);\r\n            ctx.restore();\r\n            if (me.animated) {\r\n                me._pointsUpdated = false;\r\n                me._path = undefined;\r\n            }\r\n        }\r\n    }\r\n\r\n    LineElement.id = 'line';\r\n    LineElement.defaults = {\r\n        borderCapStyle: 'butt',\r\n        borderDash: [],\r\n        borderDashOffset: 0,\r\n        borderJoinStyle: 'miter',\r\n        borderWidth: 3,\r\n        capBezierPoints: true,\r\n        cubicInterpolationMode: 'default',\r\n        fill: false,\r\n        spanGaps: false,\r\n        stepped: false,\r\n        tension: 0,\r\n    };\r\n    LineElement.defaultRoutes = {\r\n        backgroundColor: 'backgroundColor',\r\n        borderColor: 'borderColor'\r\n    };\r\n    LineElement.descriptors = {\r\n        _scriptable: true,\r\n        _indexable: (name) => name !== 'borderDash' && name !== 'fill',\r\n    };\r\n\r\n    function inRange$1(el, pos, axis, useFinalPosition) {\r\n        const options = el.options;\r\n        const {[axis]: value} = el.getProps([axis], useFinalPosition);\r\n        return (Math.abs(pos - value) < options.radius + options.hitRadius);\r\n    }\r\n\r\n    class PointElement extends Element {\r\n        constructor(cfg) {\r\n            super();\r\n            this.options = undefined;\r\n            this.skip = undefined;\r\n            this.stop = undefined;\r\n            if (cfg) {\r\n                Object.assign(this, cfg);\r\n            }\r\n        }\r\n\r\n        inRange(mouseX, mouseY, useFinalPosition) {\r\n            const options = this.options;\r\n            const {x, y} = this.getProps(['x', 'y'], useFinalPosition);\r\n            return ((Math.pow(mouseX - x, 2) + Math.pow(mouseY - y, 2)) < Math.pow(options.hitRadius + options.radius, 2));\r\n        }\r\n\r\n        inXRange(mouseX, useFinalPosition) {\r\n            return inRange$1(this, mouseX, 'x', useFinalPosition);\r\n        }\r\n\r\n        inYRange(mouseY, useFinalPosition) {\r\n            return inRange$1(this, mouseY, 'y', useFinalPosition);\r\n        }\r\n\r\n        getCenterPoint(useFinalPosition) {\r\n            const {x, y} = this.getProps(['x', 'y'], useFinalPosition);\r\n            return {x, y};\r\n        }\r\n\r\n        size(options) {\r\n            options = options || this.options || {};\r\n            let radius = options.radius || 0;\r\n            radius = Math.max(radius, radius && options.hoverRadius || 0);\r\n            const borderWidth = radius && options.borderWidth || 0;\r\n            return (radius + borderWidth) * 2;\r\n        }\r\n\r\n        draw(ctx) {\r\n            const me = this;\r\n            const options = me.options;\r\n            if (me.skip || options.radius < 0.1) {\r\n                return;\r\n            }\r\n            ctx.strokeStyle = options.borderColor;\r\n            ctx.lineWidth = options.borderWidth;\r\n            ctx.fillStyle = options.backgroundColor;\r\n            drawPoint(ctx, options, me.x, me.y);\r\n        }\r\n\r\n        getRange() {\r\n            const options = this.options || {};\r\n            return options.radius + options.hitRadius;\r\n        }\r\n    }\r\n\r\n    PointElement.id = 'point';\r\n    PointElement.defaults = {\r\n        borderWidth: 1,\r\n        hitRadius: 1,\r\n        hoverBorderWidth: 1,\r\n        hoverRadius: 4,\r\n        pointStyle: 'circle',\r\n        radius: 3,\r\n        rotation: 0\r\n    };\r\n    PointElement.defaultRoutes = {\r\n        backgroundColor: 'backgroundColor',\r\n        borderColor: 'borderColor'\r\n    };\r\n\r\n    function getBarBounds(bar, useFinalPosition) {\r\n        const {x, y, base, width, height} = bar.getProps(['x', 'y', 'base', 'width', 'height'], useFinalPosition);\r\n        let left, right, top, bottom, half;\r\n        if (bar.horizontal) {\r\n            half = height / 2;\r\n            left = Math.min(x, base);\r\n            right = Math.max(x, base);\r\n            top = y - half;\r\n            bottom = y + half;\r\n        } else {\r\n            half = width / 2;\r\n            left = x - half;\r\n            right = x + half;\r\n            top = Math.min(y, base);\r\n            bottom = Math.max(y, base);\r\n        }\r\n        return {left, top, right, bottom};\r\n    }\r\n\r\n    function parseBorderSkipped(bar) {\r\n        let edge = bar.options.borderSkipped;\r\n        const res = {};\r\n        if (!edge) {\r\n            return res;\r\n        }\r\n        edge = bar.horizontal\r\n            ? parseEdge(edge, 'left', 'right', bar.base > bar.x)\r\n            : parseEdge(edge, 'bottom', 'top', bar.base < bar.y);\r\n        res[edge] = true;\r\n        return res;\r\n    }\r\n\r\n    function parseEdge(edge, a, b, reverse) {\r\n        if (reverse) {\r\n            edge = swap(edge, a, b);\r\n            edge = startEnd(edge, b, a);\r\n        } else {\r\n            edge = startEnd(edge, a, b);\r\n        }\r\n        return edge;\r\n    }\r\n\r\n    function swap(orig, v1, v2) {\r\n        return orig === v1 ? v2 : orig === v2 ? v1 : orig;\r\n    }\r\n\r\n    function startEnd(v, start, end) {\r\n        return v === 'start' ? start : v === 'end' ? end : v;\r\n    }\r\n\r\n    function skipOrLimit(skip, value, min, max) {\r\n        return skip ? 0 : Math.max(Math.min(value, max), min);\r\n    }\r\n\r\n    function parseBorderWidth(bar, maxW, maxH) {\r\n        const value = bar.options.borderWidth;\r\n        const skip = parseBorderSkipped(bar);\r\n        const o = toTRBL(value);\r\n        return {\r\n            t: skipOrLimit(skip.top, o.top, 0, maxH),\r\n            r: skipOrLimit(skip.right, o.right, 0, maxW),\r\n            b: skipOrLimit(skip.bottom, o.bottom, 0, maxH),\r\n            l: skipOrLimit(skip.left, o.left, 0, maxW)\r\n        };\r\n    }\r\n\r\n    function parseBorderRadius(bar, maxW, maxH) {\r\n        const value = bar.options.borderRadius;\r\n        const o = toTRBLCorners(value);\r\n        const maxR = Math.min(maxW, maxH);\r\n        const skip = parseBorderSkipped(bar);\r\n        return {\r\n            topLeft: skipOrLimit(skip.top || skip.left, o.topLeft, 0, maxR),\r\n            topRight: skipOrLimit(skip.top || skip.right, o.topRight, 0, maxR),\r\n            bottomLeft: skipOrLimit(skip.bottom || skip.left, o.bottomLeft, 0, maxR),\r\n            bottomRight: skipOrLimit(skip.bottom || skip.right, o.bottomRight, 0, maxR)\r\n        };\r\n    }\r\n\r\n    function boundingRects(bar) {\r\n        const bounds = getBarBounds(bar);\r\n        const width = bounds.right - bounds.left;\r\n        const height = bounds.bottom - bounds.top;\r\n        const border = parseBorderWidth(bar, width / 2, height / 2);\r\n        const radius = parseBorderRadius(bar, width / 2, height / 2);\r\n        return {\r\n            outer: {\r\n                x: bounds.left,\r\n                y: bounds.top,\r\n                w: width,\r\n                h: height,\r\n                radius\r\n            },\r\n            inner: {\r\n                x: bounds.left + border.l,\r\n                y: bounds.top + border.t,\r\n                w: width - border.l - border.r,\r\n                h: height - border.t - border.b,\r\n                radius: {\r\n                    topLeft: Math.max(0, radius.topLeft - Math.max(border.t, border.l)),\r\n                    topRight: Math.max(0, radius.topRight - Math.max(border.t, border.r)),\r\n                    bottomLeft: Math.max(0, radius.bottomLeft - Math.max(border.b, border.l)),\r\n                    bottomRight: Math.max(0, radius.bottomRight - Math.max(border.b, border.r)),\r\n                }\r\n            }\r\n        };\r\n    }\r\n\r\n    function inRange(bar, x, y, useFinalPosition) {\r\n        const skipX = x === null;\r\n        const skipY = y === null;\r\n        const skipBoth = skipX && skipY;\r\n        const bounds = bar && !skipBoth && getBarBounds(bar, useFinalPosition);\r\n        return bounds\r\n            && (skipX || x >= bounds.left && x <= bounds.right)\r\n            && (skipY || y >= bounds.top && y <= bounds.bottom);\r\n    }\r\n\r\n    function hasRadius(radius) {\r\n        return radius.topLeft || radius.topRight || radius.bottomLeft || radius.bottomRight;\r\n    }\r\n\r\n    function addRoundedRectPath(ctx, rect) {\r\n        const {x, y, w, h, radius} = rect;\r\n        ctx.arc(x + radius.topLeft, y + radius.topLeft, radius.topLeft, -HALF_PI, PI, true);\r\n        ctx.lineTo(x, y + h - radius.bottomLeft);\r\n        ctx.arc(x + radius.bottomLeft, y + h - radius.bottomLeft, radius.bottomLeft, PI, HALF_PI, true);\r\n        ctx.lineTo(x + w - radius.bottomRight, y + h);\r\n        ctx.arc(x + w - radius.bottomRight, y + h - radius.bottomRight, radius.bottomRight, HALF_PI, 0, true);\r\n        ctx.lineTo(x + w, y + radius.topRight);\r\n        ctx.arc(x + w - radius.topRight, y + radius.topRight, radius.topRight, 0, -HALF_PI, true);\r\n        ctx.lineTo(x + radius.topLeft, y);\r\n    }\r\n\r\n    function addNormalRectPath(ctx, rect) {\r\n        ctx.rect(rect.x, rect.y, rect.w, rect.h);\r\n    }\r\n\r\n    class BarElement extends Element {\r\n        constructor(cfg) {\r\n            super();\r\n            this.options = undefined;\r\n            this.horizontal = undefined;\r\n            this.base = undefined;\r\n            this.width = undefined;\r\n            this.height = undefined;\r\n            if (cfg) {\r\n                Object.assign(this, cfg);\r\n            }\r\n        }\r\n\r\n        draw(ctx) {\r\n            const options = this.options;\r\n            const {inner, outer} = boundingRects(this);\r\n            const addRectPath = hasRadius(outer.radius) ? addRoundedRectPath : addNormalRectPath;\r\n            ctx.save();\r\n            if (outer.w !== inner.w || outer.h !== inner.h) {\r\n                ctx.beginPath();\r\n                addRectPath(ctx, outer);\r\n                ctx.clip();\r\n                addRectPath(ctx, inner);\r\n                ctx.fillStyle = options.borderColor;\r\n                ctx.fill('evenodd');\r\n            }\r\n            ctx.beginPath();\r\n            addRectPath(ctx, inner);\r\n            ctx.fillStyle = options.backgroundColor;\r\n            ctx.fill();\r\n            ctx.restore();\r\n        }\r\n\r\n        inRange(mouseX, mouseY, useFinalPosition) {\r\n            return inRange(this, mouseX, mouseY, useFinalPosition);\r\n        }\r\n\r\n        inXRange(mouseX, useFinalPosition) {\r\n            return inRange(this, mouseX, null, useFinalPosition);\r\n        }\r\n\r\n        inYRange(mouseY, useFinalPosition) {\r\n            return inRange(this, null, mouseY, useFinalPosition);\r\n        }\r\n\r\n        getCenterPoint(useFinalPosition) {\r\n            const {x, y, base, horizontal} = this.getProps(['x', 'y', 'base', 'horizontal'], useFinalPosition);\r\n            return {\r\n                x: horizontal ? (x + base) / 2 : x,\r\n                y: horizontal ? y : (y + base) / 2\r\n            };\r\n        }\r\n\r\n        getRange(axis) {\r\n            return axis === 'x' ? this.width / 2 : this.height / 2;\r\n        }\r\n    }\r\n\r\n    BarElement.id = 'bar';\r\n    BarElement.defaults = {\r\n        borderSkipped: 'start',\r\n        borderWidth: 0,\r\n        borderRadius: 0,\r\n        pointStyle: undefined\r\n    };\r\n    BarElement.defaultRoutes = {\r\n        backgroundColor: 'backgroundColor',\r\n        borderColor: 'borderColor'\r\n    };\r\n\r\n    var elements = /*#__PURE__*/Object.freeze({\r\n        __proto__: null,\r\n        ArcElement: ArcElement,\r\n        LineElement: LineElement,\r\n        PointElement: PointElement,\r\n        BarElement: BarElement\r\n    });\r\n\r\n    function lttbDecimation(data, availableWidth, options) {\r\n        const samples = options.samples || availableWidth;\r\n        const decimated = [];\r\n        const bucketWidth = (data.length - 2) / (samples - 2);\r\n        let sampledIndex = 0;\r\n        let a = 0;\r\n        let i, maxAreaPoint, maxArea, area, nextA;\r\n        decimated[sampledIndex++] = data[a];\r\n        for (i = 0; i < samples - 2; i++) {\r\n            let avgX = 0;\r\n            let avgY = 0;\r\n            let j;\r\n            const avgRangeStart = Math.floor((i + 1) * bucketWidth) + 1;\r\n            const avgRangeEnd = Math.min(Math.floor((i + 2) * bucketWidth) + 1, data.length);\r\n            const avgRangeLength = avgRangeEnd - avgRangeStart;\r\n            for (j = avgRangeStart; j < avgRangeEnd; j++) {\r\n                avgX = data[j].x;\r\n                avgY = data[j].y;\r\n            }\r\n            avgX /= avgRangeLength;\r\n            avgY /= avgRangeLength;\r\n            const rangeOffs = Math.floor(i * bucketWidth) + 1;\r\n            const rangeTo = Math.floor((i + 1) * bucketWidth) + 1;\r\n            const {x: pointAx, y: pointAy} = data[a];\r\n            maxArea = area = -1;\r\n            for (j = rangeOffs; j < rangeTo; j++) {\r\n                area = 0.5 * Math.abs(\r\n                    (pointAx - avgX) * (data[j].y - pointAy) -\r\n                    (pointAx - data[j].x) * (avgY - pointAy)\r\n                );\r\n                if (area > maxArea) {\r\n                    maxArea = area;\r\n                    maxAreaPoint = data[j];\r\n                    nextA = j;\r\n                }\r\n            }\r\n            decimated[sampledIndex++] = maxAreaPoint;\r\n            a = nextA;\r\n        }\r\n        decimated[sampledIndex++] = data[data.length - 1];\r\n        return decimated;\r\n    }\r\n\r\n    function minMaxDecimation(data, availableWidth) {\r\n        let avgX = 0;\r\n        let countX = 0;\r\n        let i, point, x, y, prevX, minIndex, maxIndex, startIndex, minY, maxY;\r\n        const decimated = [];\r\n        const xMin = data[0].x;\r\n        const xMax = data[data.length - 1].x;\r\n        const dx = xMax - xMin;\r\n        for (i = 0; i < data.length; ++i) {\r\n            point = data[i];\r\n            x = (point.x - xMin) / dx * availableWidth;\r\n            y = point.y;\r\n            const truncX = x | 0;\r\n            if (truncX === prevX) {\r\n                if (y < minY) {\r\n                    minY = y;\r\n                    minIndex = i;\r\n                } else if (y > maxY) {\r\n                    maxY = y;\r\n                    maxIndex = i;\r\n                }\r\n                avgX = (countX * avgX + point.x) / ++countX;\r\n            } else {\r\n                const lastIndex = i - 1;\r\n                if (!isNullOrUndef(minIndex) && !isNullOrUndef(maxIndex)) {\r\n                    const intermediateIndex1 = Math.min(minIndex, maxIndex);\r\n                    const intermediateIndex2 = Math.max(minIndex, maxIndex);\r\n                    if (intermediateIndex1 !== startIndex && intermediateIndex1 !== lastIndex) {\r\n                        decimated.push({\r\n                            ...data[intermediateIndex1],\r\n                            x: avgX,\r\n                        });\r\n                    }\r\n                    if (intermediateIndex2 !== startIndex && intermediateIndex2 !== lastIndex) {\r\n                        decimated.push({\r\n                            ...data[intermediateIndex2],\r\n                            x: avgX\r\n                        });\r\n                    }\r\n                }\r\n                if (i > 0 && lastIndex !== startIndex) {\r\n                    decimated.push(data[lastIndex]);\r\n                }\r\n                decimated.push(point);\r\n                prevX = truncX;\r\n                countX = 0;\r\n                minY = maxY = y;\r\n                minIndex = maxIndex = startIndex = i;\r\n            }\r\n        }\r\n        return decimated;\r\n    }\r\n\r\n    var plugin_decimation = {\r\n        id: 'decimation',\r\n        defaults: {\r\n            algorithm: 'min-max',\r\n            enabled: false,\r\n        },\r\n        beforeElementsUpdate: (chart, args, options) => {\r\n            if (!options.enabled) {\r\n                return;\r\n            }\r\n            const availableWidth = chart.width;\r\n            chart.data.datasets.forEach((dataset, datasetIndex) => {\r\n                const {_data, indexAxis} = dataset;\r\n                const meta = chart.getDatasetMeta(datasetIndex);\r\n                const data = _data || dataset.data;\r\n                if (resolve([indexAxis, chart.options.indexAxis]) === 'y') {\r\n                    return;\r\n                }\r\n                if (meta.type !== 'line') {\r\n                    return;\r\n                }\r\n                const xAxis = chart.scales[meta.xAxisID];\r\n                if (xAxis.type !== 'linear' && xAxis.type !== 'time') {\r\n                    return;\r\n                }\r\n                if (chart.options.parsing) {\r\n                    return;\r\n                }\r\n                if (data.length <= 4 * availableWidth) {\r\n                    return;\r\n                }\r\n                if (isNullOrUndef(_data)) {\r\n                    dataset._data = data;\r\n                    delete dataset.data;\r\n                    Object.defineProperty(dataset, 'data', {\r\n                        configurable: true,\r\n                        enumerable: true,\r\n                        get: function () {\r\n                            return this._decimated;\r\n                        },\r\n                        set: function (d) {\r\n                            this._data = d;\r\n                        }\r\n                    });\r\n                }\r\n                let decimated;\r\n                switch (options.algorithm) {\r\n                    case 'lttb':\r\n                        decimated = lttbDecimation(data, availableWidth, options);\r\n                        break;\r\n                    case 'min-max':\r\n                        decimated = minMaxDecimation(data, availableWidth);\r\n                        break;\r\n                    default:\r\n                        throw new Error(`Unsupported decimation algorithm '${options.algorithm}'`);\r\n                }\r\n                dataset._decimated = decimated;\r\n            });\r\n        },\r\n        destroy(chart) {\r\n            chart.data.datasets.forEach((dataset) => {\r\n                if (dataset._decimated) {\r\n                    const data = dataset._data;\r\n                    delete dataset._decimated;\r\n                    delete dataset._data;\r\n                    Object.defineProperty(dataset, 'data', {value: data});\r\n                }\r\n            });\r\n        }\r\n    };\r\n\r\n    function getLineByIndex(chart, index) {\r\n        const meta = chart.getDatasetMeta(index);\r\n        const visible = meta && chart.isDatasetVisible(index);\r\n        return visible ? meta.dataset : null;\r\n    }\r\n\r\n    function parseFillOption(line) {\r\n        const options = line.options;\r\n        const fillOption = options.fill;\r\n        let fill = valueOrDefault(fillOption && fillOption.target, fillOption);\r\n        if (fill === undefined) {\r\n            fill = !!options.backgroundColor;\r\n        }\r\n        if (fill === false || fill === null) {\r\n            return false;\r\n        }\r\n        if (fill === true) {\r\n            return 'origin';\r\n        }\r\n        return fill;\r\n    }\r\n\r\n    function decodeFill(line, index, count) {\r\n        const fill = parseFillOption(line);\r\n        if (isObject(fill)) {\r\n            return isNaN(fill.value) ? false : fill;\r\n        }\r\n        let target = parseFloat(fill);\r\n        if (isNumberFinite(target) && Math.floor(target) === target) {\r\n            if (fill[0] === '-' || fill[0] === '+') {\r\n                target = index + target;\r\n            }\r\n            if (target === index || target < 0 || target >= count) {\r\n                return false;\r\n            }\r\n            return target;\r\n        }\r\n        return ['origin', 'start', 'end', 'stack'].indexOf(fill) >= 0 && fill;\r\n    }\r\n\r\n    function computeLinearBoundary(source) {\r\n        const {scale = {}, fill} = source;\r\n        let target = null;\r\n        let horizontal;\r\n        if (fill === 'start') {\r\n            target = scale.bottom;\r\n        } else if (fill === 'end') {\r\n            target = scale.top;\r\n        } else if (isObject(fill)) {\r\n            target = scale.getPixelForValue(fill.value);\r\n        } else if (scale.getBasePixel) {\r\n            target = scale.getBasePixel();\r\n        }\r\n        if (isNumberFinite(target)) {\r\n            horizontal = scale.isHorizontal();\r\n            return {\r\n                x: horizontal ? target : null,\r\n                y: horizontal ? null : target\r\n            };\r\n        }\r\n        return null;\r\n    }\r\n\r\n    class simpleArc {\r\n        constructor(opts) {\r\n            this.x = opts.x;\r\n            this.y = opts.y;\r\n            this.radius = opts.radius;\r\n        }\r\n\r\n        pathSegment(ctx, bounds, opts) {\r\n            const {x, y, radius} = this;\r\n            bounds = bounds || {start: 0, end: TAU};\r\n            ctx.arc(x, y, radius, bounds.end, bounds.start, true);\r\n            return !opts.bounds;\r\n        }\r\n\r\n        interpolate(point) {\r\n            const {x, y, radius} = this;\r\n            const angle = point.angle;\r\n            return {\r\n                x: x + Math.cos(angle) * radius,\r\n                y: y + Math.sin(angle) * radius,\r\n                angle\r\n            };\r\n        }\r\n    }\r\n\r\n    function computeCircularBoundary(source) {\r\n        const {scale, fill} = source;\r\n        const options = scale.options;\r\n        const length = scale.getLabels().length;\r\n        const target = [];\r\n        const start = options.reverse ? scale.max : scale.min;\r\n        const end = options.reverse ? scale.min : scale.max;\r\n        let i, center, value;\r\n        if (fill === 'start') {\r\n            value = start;\r\n        } else if (fill === 'end') {\r\n            value = end;\r\n        } else if (isObject(fill)) {\r\n            value = fill.value;\r\n        } else {\r\n            value = scale.getBaseValue();\r\n        }\r\n        if (options.grid.circular) {\r\n            center = scale.getPointPositionForValue(0, start);\r\n            return new simpleArc({\r\n                x: center.x,\r\n                y: center.y,\r\n                radius: scale.getDistanceFromCenterForValue(value)\r\n            });\r\n        }\r\n        for (i = 0; i < length; ++i) {\r\n            target.push(scale.getPointPositionForValue(i, value));\r\n        }\r\n        return target;\r\n    }\r\n\r\n    function computeBoundary(source) {\r\n        const scale = source.scale || {};\r\n        if (scale.getPointPositionForValue) {\r\n            return computeCircularBoundary(source);\r\n        }\r\n        return computeLinearBoundary(source);\r\n    }\r\n\r\n    function pointsFromSegments(boundary, line) {\r\n        const {x = null, y = null} = boundary || {};\r\n        const linePoints = line.points;\r\n        const points = [];\r\n        line.segments.forEach((segment) => {\r\n            const first = linePoints[segment.start];\r\n            const last = linePoints[segment.end];\r\n            if (y !== null) {\r\n                points.push({x: first.x, y});\r\n                points.push({x: last.x, y});\r\n            } else if (x !== null) {\r\n                points.push({x, y: first.y});\r\n                points.push({x, y: last.y});\r\n            }\r\n        });\r\n        return points;\r\n    }\r\n\r\n    function buildStackLine(source) {\r\n        const {chart, scale, index, line} = source;\r\n        const points = [];\r\n        const segments = line.segments;\r\n        const sourcePoints = line.points;\r\n        const linesBelow = getLinesBelow(chart, index);\r\n        linesBelow.push(createBoundaryLine({x: null, y: scale.bottom}, line));\r\n        for (let i = 0; i < segments.length; i++) {\r\n            const segment = segments[i];\r\n            for (let j = segment.start; j <= segment.end; j++) {\r\n                addPointsBelow(points, sourcePoints[j], linesBelow);\r\n            }\r\n        }\r\n        return new LineElement({points, options: {}});\r\n    }\r\n\r\n    const isLineAndNotInHideAnimation = (meta) => meta.type === 'line' && !meta.hidden;\r\n\r\n    function getLinesBelow(chart, index) {\r\n        const below = [];\r\n        const metas = chart.getSortedVisibleDatasetMetas();\r\n        for (let i = 0; i < metas.length; i++) {\r\n            const meta = metas[i];\r\n            if (meta.index === index) {\r\n                break;\r\n            }\r\n            if (isLineAndNotInHideAnimation(meta)) {\r\n                below.unshift(meta.dataset);\r\n            }\r\n        }\r\n        return below;\r\n    }\r\n\r\n    function addPointsBelow(points, sourcePoint, linesBelow) {\r\n        const postponed = [];\r\n        for (let j = 0; j < linesBelow.length; j++) {\r\n            const line = linesBelow[j];\r\n            const {first, last, point} = findPoint(line, sourcePoint, 'x');\r\n            if (!point || (first && last)) {\r\n                continue;\r\n            }\r\n            if (first) {\r\n                postponed.unshift(point);\r\n            } else {\r\n                points.push(point);\r\n                if (!last) {\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n        points.push(...postponed);\r\n    }\r\n\r\n    function findPoint(line, sourcePoint, property) {\r\n        const point = line.interpolate(sourcePoint, property);\r\n        if (!point) {\r\n            return {};\r\n        }\r\n        const pointValue = point[property];\r\n        const segments = line.segments;\r\n        const linePoints = line.points;\r\n        let first = false;\r\n        let last = false;\r\n        for (let i = 0; i < segments.length; i++) {\r\n            const segment = segments[i];\r\n            const firstValue = linePoints[segment.start][property];\r\n            const lastValue = linePoints[segment.end][property];\r\n            if (pointValue >= firstValue && pointValue <= lastValue) {\r\n                first = pointValue === firstValue;\r\n                last = pointValue === lastValue;\r\n                break;\r\n            }\r\n        }\r\n        return {first, last, point};\r\n    }\r\n\r\n    function getTarget(source) {\r\n        const {chart, fill, line} = source;\r\n        if (isNumberFinite(fill)) {\r\n            return getLineByIndex(chart, fill);\r\n        }\r\n        if (fill === 'stack') {\r\n            return buildStackLine(source);\r\n        }\r\n        const boundary = computeBoundary(source);\r\n        if (boundary instanceof simpleArc) {\r\n            return boundary;\r\n        }\r\n        return createBoundaryLine(boundary, line);\r\n    }\r\n\r\n    function createBoundaryLine(boundary, line) {\r\n        let points = [];\r\n        let _loop = false;\r\n        if (isArray(boundary)) {\r\n            _loop = true;\r\n            points = boundary;\r\n        } else {\r\n            points = pointsFromSegments(boundary, line);\r\n        }\r\n        return points.length ? new LineElement({\r\n            points,\r\n            options: {tension: 0},\r\n            _loop,\r\n            _fullLoop: _loop\r\n        }) : null;\r\n    }\r\n\r\n    function resolveTarget(sources, index, propagate) {\r\n        const source = sources[index];\r\n        let fill = source.fill;\r\n        const visited = [index];\r\n        let target;\r\n        if (!propagate) {\r\n            return fill;\r\n        }\r\n        while (fill !== false && visited.indexOf(fill) === -1) {\r\n            if (!isNumberFinite(fill)) {\r\n                return fill;\r\n            }\r\n            target = sources[fill];\r\n            if (!target) {\r\n                return false;\r\n            }\r\n            if (target.visible) {\r\n                return fill;\r\n            }\r\n            visited.push(fill);\r\n            fill = target.fill;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    function _clip(ctx, target, clipY) {\r\n        ctx.beginPath();\r\n        target.path(ctx);\r\n        ctx.lineTo(target.last().x, clipY);\r\n        ctx.lineTo(target.first().x, clipY);\r\n        ctx.closePath();\r\n        ctx.clip();\r\n    }\r\n\r\n    function getBounds(property, first, last, loop) {\r\n        if (loop) {\r\n            return;\r\n        }\r\n        let start = first[property];\r\n        let end = last[property];\r\n        if (property === 'angle') {\r\n            start = _normalizeAngle(start);\r\n            end = _normalizeAngle(end);\r\n        }\r\n        return {property, start, end};\r\n    }\r\n\r\n    function _getEdge(a, b, prop, fn) {\r\n        if (a && b) {\r\n            return fn(a[prop], b[prop]);\r\n        }\r\n        return a ? a[prop] : b ? b[prop] : 0;\r\n    }\r\n\r\n    function _segments(line, target, property) {\r\n        const segments = line.segments;\r\n        const points = line.points;\r\n        const tpoints = target.points;\r\n        const parts = [];\r\n        for (let i = 0; i < segments.length; i++) {\r\n            const segment = segments[i];\r\n            const bounds = getBounds(property, points[segment.start], points[segment.end], segment.loop);\r\n            if (!target.segments) {\r\n                parts.push({\r\n                    source: segment,\r\n                    target: bounds,\r\n                    start: points[segment.start],\r\n                    end: points[segment.end]\r\n                });\r\n                continue;\r\n            }\r\n            const subs = _boundSegments(target, bounds);\r\n            for (let j = 0; j < subs.length; ++j) {\r\n                const sub = subs[j];\r\n                const subBounds = getBounds(property, tpoints[sub.start], tpoints[sub.end], sub.loop);\r\n                const fillSources = _boundSegment(segment, points, subBounds);\r\n                for (let k = 0; k < fillSources.length; k++) {\r\n                    parts.push({\r\n                        source: fillSources[k],\r\n                        target: sub,\r\n                        start: {\r\n                            [property]: _getEdge(bounds, subBounds, 'start', Math.max)\r\n                        },\r\n                        end: {\r\n                            [property]: _getEdge(bounds, subBounds, 'end', Math.min)\r\n                        }\r\n                    });\r\n                }\r\n            }\r\n        }\r\n        return parts;\r\n    }\r\n\r\n    function clipBounds(ctx, scale, bounds) {\r\n        const {top, bottom} = scale.chart.chartArea;\r\n        const {property, start, end} = bounds || {};\r\n        if (property === 'x') {\r\n            ctx.beginPath();\r\n            ctx.rect(start, top, end - start, bottom - top);\r\n            ctx.clip();\r\n        }\r\n    }\r\n\r\n    function interpolatedLineTo(ctx, target, point, property) {\r\n        const interpolatedPoint = target.interpolate(point, property);\r\n        if (interpolatedPoint) {\r\n            ctx.lineTo(interpolatedPoint.x, interpolatedPoint.y);\r\n        }\r\n    }\r\n\r\n    function _fill(ctx, cfg) {\r\n        const {line, target, property, color, scale} = cfg;\r\n        const segments = _segments(line, target, property);\r\n        ctx.fillStyle = color;\r\n        for (let i = 0, ilen = segments.length; i < ilen; ++i) {\r\n            const {source: src, target: tgt, start, end} = segments[i];\r\n            ctx.save();\r\n            clipBounds(ctx, scale, getBounds(property, start, end));\r\n            ctx.beginPath();\r\n            const lineLoop = !!line.pathSegment(ctx, src);\r\n            if (lineLoop) {\r\n                ctx.closePath();\r\n            } else {\r\n                interpolatedLineTo(ctx, target, end, property);\r\n            }\r\n            const targetLoop = !!target.pathSegment(ctx, tgt, {move: lineLoop, reverse: true});\r\n            const loop = lineLoop && targetLoop;\r\n            if (!loop) {\r\n                interpolatedLineTo(ctx, target, start, property);\r\n            }\r\n            ctx.closePath();\r\n            ctx.fill(loop ? 'evenodd' : 'nonzero');\r\n            ctx.restore();\r\n        }\r\n    }\r\n\r\n    function doFill(ctx, cfg) {\r\n        const {line, target, above, below, area, scale} = cfg;\r\n        const property = line._loop ? 'angle' : 'x';\r\n        ctx.save();\r\n        if (property === 'x' && below !== above) {\r\n            _clip(ctx, target, area.top);\r\n            _fill(ctx, {line, target, color: above, scale, property});\r\n            ctx.restore();\r\n            ctx.save();\r\n            _clip(ctx, target, area.bottom);\r\n        }\r\n        _fill(ctx, {line, target, color: below, scale, property});\r\n        ctx.restore();\r\n    }\r\n\r\n    var plugin_filler = {\r\n        id: 'filler',\r\n        afterDatasetsUpdate(chart, _args, options) {\r\n            const count = (chart.data.datasets || []).length;\r\n            const propagate = options.propagate;\r\n            const sources = [];\r\n            let meta, i, line, source;\r\n            for (i = 0; i < count; ++i) {\r\n                meta = chart.getDatasetMeta(i);\r\n                line = meta.dataset;\r\n                source = null;\r\n                if (line && line.options && line instanceof LineElement) {\r\n                    source = {\r\n                        visible: chart.isDatasetVisible(i),\r\n                        index: i,\r\n                        fill: decodeFill(line, i, count),\r\n                        chart,\r\n                        scale: meta.vScale,\r\n                        line\r\n                    };\r\n                }\r\n                meta.$filler = source;\r\n                sources.push(source);\r\n            }\r\n            for (i = 0; i < count; ++i) {\r\n                source = sources[i];\r\n                if (!source || source.fill === false) {\r\n                    continue;\r\n                }\r\n                source.fill = resolveTarget(sources, i, propagate);\r\n            }\r\n        },\r\n        beforeDatasetsDraw(chart) {\r\n            const metasets = chart.getSortedVisibleDatasetMetas();\r\n            const area = chart.chartArea;\r\n            let i, meta;\r\n            for (i = metasets.length - 1; i >= 0; --i) {\r\n                meta = metasets[i].$filler;\r\n                if (meta) {\r\n                    meta.line.updateControlPoints(area);\r\n                }\r\n            }\r\n        },\r\n        beforeDatasetDraw(chart, args) {\r\n            const area = chart.chartArea;\r\n            const ctx = chart.ctx;\r\n            const source = args.meta.$filler;\r\n            if (!source || source.fill === false) {\r\n                return;\r\n            }\r\n            const target = getTarget(source);\r\n            const {line, scale} = source;\r\n            const lineOpts = line.options;\r\n            const fillOption = lineOpts.fill;\r\n            const color = lineOpts.backgroundColor;\r\n            const {above = color, below = color} = fillOption || {};\r\n            if (target && line.points.length) {\r\n                clipArea(ctx, area);\r\n                doFill(ctx, {line, target, above, below, area, scale});\r\n                unclipArea(ctx);\r\n            }\r\n        },\r\n        defaults: {\r\n            propagate: true\r\n        }\r\n    };\r\n\r\n    const getBoxSize = (labelOpts, fontSize) => {\r\n        let {boxHeight = fontSize, boxWidth = fontSize} = labelOpts;\r\n        if (labelOpts.usePointStyle) {\r\n            boxHeight = Math.min(boxHeight, fontSize);\r\n            boxWidth = Math.min(boxWidth, fontSize);\r\n        }\r\n        return {\r\n            boxWidth,\r\n            boxHeight,\r\n            itemHeight: Math.max(fontSize, boxHeight)\r\n        };\r\n    };\r\n    const itemsEqual = (a, b) => a !== null && b !== null && a.datasetIndex === b.datasetIndex && a.index === b.index;\r\n\r\n    class Legend extends Element {\r\n        constructor(config) {\r\n            super();\r\n            this._added = false;\r\n            this.legendHitBoxes = [];\r\n            this._hoveredItem = null;\r\n            this.doughnutMode = false;\r\n            this.chart = config.chart;\r\n            this.options = config.options;\r\n            this.ctx = config.ctx;\r\n            this.legendItems = undefined;\r\n            this.columnSizes = undefined;\r\n            this.lineWidths = undefined;\r\n            this.maxHeight = undefined;\r\n            this.maxWidth = undefined;\r\n            this.top = undefined;\r\n            this.bottom = undefined;\r\n            this.left = undefined;\r\n            this.right = undefined;\r\n            this.height = undefined;\r\n            this.width = undefined;\r\n            this._margins = undefined;\r\n            this.position = undefined;\r\n            this.weight = undefined;\r\n            this.fullSize = undefined;\r\n        }\r\n\r\n        update(maxWidth, maxHeight, margins) {\r\n            const me = this;\r\n            me.maxWidth = maxWidth;\r\n            me.maxHeight = maxHeight;\r\n            me._margins = margins;\r\n            me.setDimensions();\r\n            me.buildLabels();\r\n            me.fit();\r\n        }\r\n\r\n        setDimensions() {\r\n            const me = this;\r\n            if (me.isHorizontal()) {\r\n                me.width = me.maxWidth;\r\n                me.left = 0;\r\n                me.right = me.width;\r\n            } else {\r\n                me.height = me.maxHeight;\r\n                me.top = 0;\r\n                me.bottom = me.height;\r\n            }\r\n        }\r\n\r\n        buildLabels() {\r\n            const me = this;\r\n            const labelOpts = me.options.labels || {};\r\n            let legendItems = callback(labelOpts.generateLabels, [me.chart], me) || [];\r\n            if (labelOpts.filter) {\r\n                legendItems = legendItems.filter((item) => labelOpts.filter(item, me.chart.data));\r\n            }\r\n            if (labelOpts.sort) {\r\n                legendItems = legendItems.sort((a, b) => labelOpts.sort(a, b, me.chart.data));\r\n            }\r\n            if (me.options.reverse) {\r\n                legendItems.reverse();\r\n            }\r\n            me.legendItems = legendItems;\r\n        }\r\n\r\n        fit() {\r\n            const me = this;\r\n            const {options, ctx} = me;\r\n            if (!options.display) {\r\n                me.width = me.height = 0;\r\n                return;\r\n            }\r\n            const labelOpts = options.labels;\r\n            const labelFont = toFont(labelOpts.font);\r\n            const fontSize = labelFont.size;\r\n            const titleHeight = me._computeTitleHeight();\r\n            const {boxWidth, itemHeight} = getBoxSize(labelOpts, fontSize);\r\n            let width, height;\r\n            ctx.font = labelFont.string;\r\n            if (me.isHorizontal()) {\r\n                width = me.maxWidth;\r\n                height = me._fitRows(titleHeight, fontSize, boxWidth, itemHeight) + 10;\r\n            } else {\r\n                height = me.maxHeight;\r\n                width = me._fitCols(titleHeight, fontSize, boxWidth, itemHeight) + 10;\r\n            }\r\n            me.width = Math.min(width, options.maxWidth || me.maxWidth);\r\n            me.height = Math.min(height, options.maxHeight || me.maxHeight);\r\n        }\r\n\r\n        _fitRows(titleHeight, fontSize, boxWidth, itemHeight) {\r\n            const me = this;\r\n            const {ctx, maxWidth, options: {labels: {padding}}} = me;\r\n            const hitboxes = me.legendHitBoxes = [];\r\n            const lineWidths = me.lineWidths = [0];\r\n            const lineHeight = itemHeight + padding;\r\n            let totalHeight = titleHeight;\r\n            ctx.textAlign = 'left';\r\n            ctx.textBaseline = 'middle';\r\n            let row = -1;\r\n            let top = -lineHeight;\r\n            me.legendItems.forEach((legendItem, i) => {\r\n                const itemWidth = boxWidth + (fontSize / 2) + ctx.measureText(legendItem.text).width;\r\n                if (i === 0 || lineWidths[lineWidths.length - 1] + itemWidth + 2 * padding > maxWidth) {\r\n                    totalHeight += lineHeight;\r\n                    lineWidths[lineWidths.length - (i > 0 ? 0 : 1)] = 0;\r\n                    top += lineHeight;\r\n                    row++;\r\n                }\r\n                hitboxes[i] = {left: 0, top, row, width: itemWidth, height: itemHeight};\r\n                lineWidths[lineWidths.length - 1] += itemWidth + padding;\r\n            });\r\n            return totalHeight;\r\n        }\r\n\r\n        _fitCols(titleHeight, fontSize, boxWidth, itemHeight) {\r\n            const me = this;\r\n            const {ctx, maxHeight, options: {labels: {padding}}} = me;\r\n            const hitboxes = me.legendHitBoxes = [];\r\n            const columnSizes = me.columnSizes = [];\r\n            const heightLimit = maxHeight - titleHeight;\r\n            let totalWidth = padding;\r\n            let currentColWidth = 0;\r\n            let currentColHeight = 0;\r\n            let left = 0;\r\n            let top = 0;\r\n            let col = 0;\r\n            me.legendItems.forEach((legendItem, i) => {\r\n                const itemWidth = boxWidth + (fontSize / 2) + ctx.measureText(legendItem.text).width;\r\n                if (i > 0 && currentColHeight + fontSize + 2 * padding > heightLimit) {\r\n                    totalWidth += currentColWidth + padding;\r\n                    columnSizes.push({width: currentColWidth, height: currentColHeight});\r\n                    left += currentColWidth + padding;\r\n                    col++;\r\n                    top = 0;\r\n                    currentColWidth = currentColHeight = 0;\r\n                }\r\n                currentColWidth = Math.max(currentColWidth, itemWidth);\r\n                currentColHeight += fontSize + padding;\r\n                hitboxes[i] = {left, top, col, width: itemWidth, height: itemHeight};\r\n                top += itemHeight + padding;\r\n            });\r\n            totalWidth += currentColWidth;\r\n            columnSizes.push({width: currentColWidth, height: currentColHeight});\r\n            return totalWidth;\r\n        }\r\n\r\n        adjustHitBoxes() {\r\n            const me = this;\r\n            if (!me.options.display) {\r\n                return;\r\n            }\r\n            const titleHeight = me._computeTitleHeight();\r\n            const {legendHitBoxes: hitboxes, options: {align, labels: {padding}}} = me;\r\n            if (this.isHorizontal()) {\r\n                let row = 0;\r\n                let left = _alignStartEnd(align, me.left + padding, me.right - me.lineWidths[row]);\r\n                for (const hitbox of hitboxes) {\r\n                    if (row !== hitbox.row) {\r\n                        row = hitbox.row;\r\n                        left = _alignStartEnd(align, me.left + padding, me.right - me.lineWidths[row]);\r\n                    }\r\n                    hitbox.top += me.top + titleHeight + padding;\r\n                    hitbox.left = left;\r\n                    left += hitbox.width + padding;\r\n                }\r\n            } else {\r\n                let col = 0;\r\n                let top = _alignStartEnd(align, me.top + titleHeight + padding, me.bottom - me.columnSizes[col].height);\r\n                for (const hitbox of hitboxes) {\r\n                    if (hitbox.col !== col) {\r\n                        col = hitbox.col;\r\n                        top = _alignStartEnd(align, me.top + titleHeight + padding, me.bottom - me.columnSizes[col].height);\r\n                    }\r\n                    hitbox.top = top;\r\n                    hitbox.left += me.left + padding;\r\n                    top += hitbox.height + padding;\r\n                }\r\n            }\r\n        }\r\n\r\n        isHorizontal() {\r\n            return this.options.position === 'top' || this.options.position === 'bottom';\r\n        }\r\n\r\n        draw() {\r\n            const me = this;\r\n            if (me.options.display) {\r\n                const ctx = me.ctx;\r\n                clipArea(ctx, me);\r\n                me._draw();\r\n                unclipArea(ctx);\r\n            }\r\n        }\r\n\r\n        _draw() {\r\n            const me = this;\r\n            const {options: opts, columnSizes, lineWidths, ctx} = me;\r\n            const {align, labels: labelOpts} = opts;\r\n            const defaultColor = defaults.color;\r\n            const rtlHelper = getRtlAdapter(opts.rtl, me.left, me.width);\r\n            const labelFont = toFont(labelOpts.font);\r\n            const {color: fontColor, padding} = labelOpts;\r\n            const fontSize = labelFont.size;\r\n            const halfFontSize = fontSize / 2;\r\n            let cursor;\r\n            me.drawTitle();\r\n            ctx.textAlign = rtlHelper.textAlign('left');\r\n            ctx.textBaseline = 'middle';\r\n            ctx.lineWidth = 0.5;\r\n            ctx.strokeStyle = fontColor;\r\n            ctx.fillStyle = fontColor;\r\n            ctx.font = labelFont.string;\r\n            const {boxWidth, boxHeight, itemHeight} = getBoxSize(labelOpts, fontSize);\r\n            const drawLegendBox = function (x, y, legendItem) {\r\n                if (isNaN(boxWidth) || boxWidth <= 0 || isNaN(boxHeight) || boxHeight < 0) {\r\n                    return;\r\n                }\r\n                ctx.save();\r\n                const lineWidth = valueOrDefault(legendItem.lineWidth, 1);\r\n                ctx.fillStyle = valueOrDefault(legendItem.fillStyle, defaultColor);\r\n                ctx.lineCap = valueOrDefault(legendItem.lineCap, 'butt');\r\n                ctx.lineDashOffset = valueOrDefault(legendItem.lineDashOffset, 0);\r\n                ctx.lineJoin = valueOrDefault(legendItem.lineJoin, 'miter');\r\n                ctx.lineWidth = lineWidth;\r\n                ctx.strokeStyle = valueOrDefault(legendItem.strokeStyle, defaultColor);\r\n                ctx.setLineDash(valueOrDefault(legendItem.lineDash, []));\r\n                if (labelOpts.usePointStyle) {\r\n                    const drawOptions = {\r\n                        radius: boxWidth * Math.SQRT2 / 2,\r\n                        pointStyle: legendItem.pointStyle,\r\n                        rotation: legendItem.rotation,\r\n                        borderWidth: lineWidth\r\n                    };\r\n                    const centerX = rtlHelper.xPlus(x, boxWidth / 2);\r\n                    const centerY = y + halfFontSize;\r\n                    drawPoint(ctx, drawOptions, centerX, centerY);\r\n                } else {\r\n                    const yBoxTop = y + Math.max((fontSize - boxHeight) / 2, 0);\r\n                    ctx.fillRect(rtlHelper.leftForLtr(x, boxWidth), yBoxTop, boxWidth, boxHeight);\r\n                    if (lineWidth !== 0) {\r\n                        ctx.strokeRect(rtlHelper.leftForLtr(x, boxWidth), yBoxTop, boxWidth, boxHeight);\r\n                    }\r\n                }\r\n                ctx.restore();\r\n            };\r\n            const fillText = function (x, y, legendItem) {\r\n                renderText(ctx, legendItem.text, x, y + (itemHeight / 2), labelFont, {\r\n                    strikethrough: legendItem.hidden,\r\n                    textAlign: legendItem.textAlign\r\n                });\r\n            };\r\n            const isHorizontal = me.isHorizontal();\r\n            const titleHeight = this._computeTitleHeight();\r\n            if (isHorizontal) {\r\n                cursor = {\r\n                    x: _alignStartEnd(align, me.left + padding, me.right - lineWidths[0]),\r\n                    y: me.top + padding + titleHeight,\r\n                    line: 0\r\n                };\r\n            } else {\r\n                cursor = {\r\n                    x: me.left + padding,\r\n                    y: _alignStartEnd(align, me.top + titleHeight + padding, me.bottom - columnSizes[0].height),\r\n                    line: 0\r\n                };\r\n            }\r\n            overrideTextDirection(me.ctx, opts.textDirection);\r\n            const lineHeight = itemHeight + padding;\r\n            me.legendItems.forEach((legendItem, i) => {\r\n                const textWidth = ctx.measureText(legendItem.text).width;\r\n                const textAlign = rtlHelper.textAlign(legendItem.textAlign || (legendItem.textAlign = labelOpts.textAlign));\r\n                const width = boxWidth + (fontSize / 2) + textWidth;\r\n                let x = cursor.x;\r\n                let y = cursor.y;\r\n                rtlHelper.setWidth(me.width);\r\n                if (isHorizontal) {\r\n                    if (i > 0 && x + width + padding > me.right) {\r\n                        y = cursor.y += lineHeight;\r\n                        cursor.line++;\r\n                        x = cursor.x = _alignStartEnd(align, me.left + padding, me.right - lineWidths[cursor.line]);\r\n                    }\r\n                } else if (i > 0 && y + lineHeight > me.bottom) {\r\n                    x = cursor.x = x + columnSizes[cursor.line].width + padding;\r\n                    cursor.line++;\r\n                    y = cursor.y = _alignStartEnd(align, me.top + titleHeight + padding, me.bottom - columnSizes[cursor.line].height);\r\n                }\r\n                const realX = rtlHelper.x(x);\r\n                drawLegendBox(realX, y, legendItem);\r\n                x = _textX(textAlign, x + boxWidth + halfFontSize, me.right);\r\n                fillText(rtlHelper.x(x), y, legendItem);\r\n                if (isHorizontal) {\r\n                    cursor.x += width + padding;\r\n                } else {\r\n                    cursor.y += lineHeight;\r\n                }\r\n            });\r\n            restoreTextDirection(me.ctx, opts.textDirection);\r\n        }\r\n\r\n        drawTitle() {\r\n            const me = this;\r\n            const opts = me.options;\r\n            const titleOpts = opts.title;\r\n            const titleFont = toFont(titleOpts.font);\r\n            const titlePadding = toPadding(titleOpts.padding);\r\n            if (!titleOpts.display) {\r\n                return;\r\n            }\r\n            const rtlHelper = getRtlAdapter(opts.rtl, me.left, me.width);\r\n            const ctx = me.ctx;\r\n            const position = titleOpts.position;\r\n            const halfFontSize = titleFont.size / 2;\r\n            const topPaddingPlusHalfFontSize = titlePadding.top + halfFontSize;\r\n            let y;\r\n            let left = me.left;\r\n            let maxWidth = me.width;\r\n            if (this.isHorizontal()) {\r\n                maxWidth = Math.max(...me.lineWidths);\r\n                y = me.top + topPaddingPlusHalfFontSize;\r\n                left = _alignStartEnd(opts.align, left, me.right - maxWidth);\r\n            } else {\r\n                const maxHeight = me.columnSizes.reduce((acc, size) => Math.max(acc, size.height), 0);\r\n                y = topPaddingPlusHalfFontSize + _alignStartEnd(opts.align, me.top, me.bottom - maxHeight - opts.labels.padding - me._computeTitleHeight());\r\n            }\r\n            const x = _alignStartEnd(position, left, left + maxWidth);\r\n            ctx.textAlign = rtlHelper.textAlign(_toLeftRightCenter(position));\r\n            ctx.textBaseline = 'middle';\r\n            ctx.strokeStyle = titleOpts.color;\r\n            ctx.fillStyle = titleOpts.color;\r\n            ctx.font = titleFont.string;\r\n            renderText(ctx, titleOpts.text, x, y, titleFont);\r\n        }\r\n\r\n        _computeTitleHeight() {\r\n            const titleOpts = this.options.title;\r\n            const titleFont = toFont(titleOpts.font);\r\n            const titlePadding = toPadding(titleOpts.padding);\r\n            return titleOpts.display ? titleFont.lineHeight + titlePadding.height : 0;\r\n        }\r\n\r\n        _getLegendItemAt(x, y) {\r\n            const me = this;\r\n            let i, hitBox, lh;\r\n            if (x >= me.left && x <= me.right && y >= me.top && y <= me.bottom) {\r\n                lh = me.legendHitBoxes;\r\n                for (i = 0; i < lh.length; ++i) {\r\n                    hitBox = lh[i];\r\n                    if (x >= hitBox.left && x <= hitBox.left + hitBox.width && y >= hitBox.top && y <= hitBox.top + hitBox.height) {\r\n                        return me.legendItems[i];\r\n                    }\r\n                }\r\n            }\r\n            return null;\r\n        }\r\n\r\n        handleEvent(e) {\r\n            const me = this;\r\n            const opts = me.options;\r\n            if (!isListened(e.type, opts)) {\r\n                return;\r\n            }\r\n            const hoveredItem = me._getLegendItemAt(e.x, e.y);\r\n            if (e.type === 'mousemove') {\r\n                const previous = me._hoveredItem;\r\n                const sameItem = itemsEqual(previous, hoveredItem);\r\n                if (previous && !sameItem) {\r\n                    callback(opts.onLeave, [e, previous, me], me);\r\n                }\r\n                me._hoveredItem = hoveredItem;\r\n                if (hoveredItem && !sameItem) {\r\n                    callback(opts.onHover, [e, hoveredItem, me], me);\r\n                }\r\n            } else if (hoveredItem) {\r\n                callback(opts.onClick, [e, hoveredItem, me], me);\r\n            }\r\n        }\r\n    }\r\n\r\n    function isListened(type, opts) {\r\n        if (type === 'mousemove' && (opts.onHover || opts.onLeave)) {\r\n            return true;\r\n        }\r\n        if (opts.onClick && (type === 'click' || type === 'mouseup')) {\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    var plugin_legend = {\r\n        id: 'legend',\r\n        _element: Legend,\r\n        start(chart, _args, options) {\r\n            const legend = chart.legend = new Legend({ctx: chart.ctx, options, chart});\r\n            layouts.configure(chart, legend, options);\r\n            layouts.addBox(chart, legend);\r\n        },\r\n        stop(chart) {\r\n            layouts.removeBox(chart, chart.legend);\r\n            delete chart.legend;\r\n        },\r\n        beforeUpdate(chart, _args, options) {\r\n            const legend = chart.legend;\r\n            layouts.configure(chart, legend, options);\r\n            legend.options = options;\r\n        },\r\n        afterUpdate(chart) {\r\n            const legend = chart.legend;\r\n            legend.buildLabels();\r\n            legend.adjustHitBoxes();\r\n        },\r\n        afterEvent(chart, args) {\r\n            if (!args.replay) {\r\n                chart.legend.handleEvent(args.event);\r\n            }\r\n        },\r\n        defaults: {\r\n            display: true,\r\n            position: 'top',\r\n            align: 'center',\r\n            fullSize: true,\r\n            reverse: false,\r\n            weight: 1000,\r\n            onClick(e, legendItem, legend) {\r\n                const index = legendItem.datasetIndex;\r\n                const ci = legend.chart;\r\n                if (ci.isDatasetVisible(index)) {\r\n                    ci.hide(index);\r\n                    legendItem.hidden = true;\r\n                } else {\r\n                    ci.show(index);\r\n                    legendItem.hidden = false;\r\n                }\r\n            },\r\n            onHover: null,\r\n            onLeave: null,\r\n            labels: {\r\n                color: (ctx) => ctx.chart.options.color,\r\n                boxWidth: 40,\r\n                padding: 10,\r\n                generateLabels(chart) {\r\n                    const datasets = chart.data.datasets;\r\n                    const {labels: {usePointStyle, pointStyle, textAlign}} = chart.legend.options;\r\n                    return chart._getSortedDatasetMetas().map((meta) => {\r\n                        const style = meta.controller.getStyle(usePointStyle ? 0 : undefined);\r\n                        const borderWidth = toPadding(style.borderWidth);\r\n                        return {\r\n                            text: datasets[meta.index].label,\r\n                            fillStyle: style.backgroundColor,\r\n                            hidden: !meta.visible,\r\n                            lineCap: style.borderCapStyle,\r\n                            lineDash: style.borderDash,\r\n                            lineDashOffset: style.borderDashOffset,\r\n                            lineJoin: style.borderJoinStyle,\r\n                            lineWidth: (borderWidth.width + borderWidth.height) / 4,\r\n                            strokeStyle: style.borderColor,\r\n                            pointStyle: pointStyle || style.pointStyle,\r\n                            rotation: style.rotation,\r\n                            textAlign: textAlign || style.textAlign,\r\n                            datasetIndex: meta.index\r\n                        };\r\n                    }, this);\r\n                }\r\n            },\r\n            title: {\r\n                color: (ctx) => ctx.chart.options.color,\r\n                display: false,\r\n                position: 'center',\r\n                text: '',\r\n            }\r\n        },\r\n        descriptors: {\r\n            _scriptable: (name) => !name.startsWith('on'),\r\n            labels: {\r\n                _scriptable: (name) => !['generateLabels', 'filter', 'sort'].includes(name),\r\n            }\r\n        },\r\n    };\r\n\r\n    class Title extends Element {\r\n        constructor(config) {\r\n            super();\r\n            this.chart = config.chart;\r\n            this.options = config.options;\r\n            this.ctx = config.ctx;\r\n            this._padding = undefined;\r\n            this.top = undefined;\r\n            this.bottom = undefined;\r\n            this.left = undefined;\r\n            this.right = undefined;\r\n            this.width = undefined;\r\n            this.height = undefined;\r\n            this.position = undefined;\r\n            this.weight = undefined;\r\n            this.fullSize = undefined;\r\n        }\r\n\r\n        update(maxWidth, maxHeight) {\r\n            const me = this;\r\n            const opts = me.options;\r\n            me.left = 0;\r\n            me.top = 0;\r\n            if (!opts.display) {\r\n                me.width = me.height = me.right = me.bottom = 0;\r\n                return;\r\n            }\r\n            me.width = me.right = maxWidth;\r\n            me.height = me.bottom = maxHeight;\r\n            const lineCount = isArray(opts.text) ? opts.text.length : 1;\r\n            me._padding = toPadding(opts.padding);\r\n            const textSize = lineCount * toFont(opts.font).lineHeight + me._padding.height;\r\n            if (me.isHorizontal()) {\r\n                me.height = textSize;\r\n            } else {\r\n                me.width = textSize;\r\n            }\r\n        }\r\n\r\n        isHorizontal() {\r\n            const pos = this.options.position;\r\n            return pos === 'top' || pos === 'bottom';\r\n        }\r\n\r\n        _drawArgs(offset) {\r\n            const {top, left, bottom, right, options} = this;\r\n            const align = options.align;\r\n            let rotation = 0;\r\n            let maxWidth, titleX, titleY;\r\n            if (this.isHorizontal()) {\r\n                titleX = _alignStartEnd(align, left, right);\r\n                titleY = top + offset;\r\n                maxWidth = right - left;\r\n            } else {\r\n                if (options.position === 'left') {\r\n                    titleX = left + offset;\r\n                    titleY = _alignStartEnd(align, bottom, top);\r\n                    rotation = PI * -0.5;\r\n                } else {\r\n                    titleX = right - offset;\r\n                    titleY = _alignStartEnd(align, top, bottom);\r\n                    rotation = PI * 0.5;\r\n                }\r\n                maxWidth = bottom - top;\r\n            }\r\n            return {titleX, titleY, maxWidth, rotation};\r\n        }\r\n\r\n        draw() {\r\n            const me = this;\r\n            const ctx = me.ctx;\r\n            const opts = me.options;\r\n            if (!opts.display) {\r\n                return;\r\n            }\r\n            const fontOpts = toFont(opts.font);\r\n            const lineHeight = fontOpts.lineHeight;\r\n            const offset = lineHeight / 2 + me._padding.top;\r\n            const {titleX, titleY, maxWidth, rotation} = me._drawArgs(offset);\r\n            renderText(ctx, opts.text, 0, 0, fontOpts, {\r\n                color: opts.color,\r\n                maxWidth,\r\n                rotation,\r\n                textAlign: _toLeftRightCenter(opts.align),\r\n                textBaseline: 'middle',\r\n                translation: [titleX, titleY],\r\n            });\r\n        }\r\n    }\r\n\r\n    function createTitle(chart, titleOpts) {\r\n        const title = new Title({\r\n            ctx: chart.ctx,\r\n            options: titleOpts,\r\n            chart\r\n        });\r\n        layouts.configure(chart, title, titleOpts);\r\n        layouts.addBox(chart, title);\r\n        chart.titleBlock = title;\r\n    }\r\n\r\n    var plugin_title = {\r\n        id: 'title',\r\n        _element: Title,\r\n        start(chart, _args, options) {\r\n            createTitle(chart, options);\r\n        },\r\n        stop(chart) {\r\n            const titleBlock = chart.titleBlock;\r\n            layouts.removeBox(chart, titleBlock);\r\n            delete chart.titleBlock;\r\n        },\r\n        beforeUpdate(chart, _args, options) {\r\n            const title = chart.titleBlock;\r\n            layouts.configure(chart, title, options);\r\n            title.options = options;\r\n        },\r\n        defaults: {\r\n            align: 'center',\r\n            display: false,\r\n            font: {\r\n                style: 'bold',\r\n            },\r\n            fullSize: true,\r\n            padding: 10,\r\n            position: 'top',\r\n            text: '',\r\n            weight: 2000\r\n        },\r\n        defaultRoutes: {\r\n            color: 'color'\r\n        },\r\n        descriptors: {\r\n            _scriptable: true,\r\n            _indexable: false,\r\n        },\r\n    };\r\n\r\n    const positioners = {\r\n        average(items) {\r\n            if (!items.length) {\r\n                return false;\r\n            }\r\n            let i, len;\r\n            let x = 0;\r\n            let y = 0;\r\n            let count = 0;\r\n            for (i = 0, len = items.length; i < len; ++i) {\r\n                const el = items[i].element;\r\n                if (el && el.hasValue()) {\r\n                    const pos = el.tooltipPosition();\r\n                    x += pos.x;\r\n                    y += pos.y;\r\n                    ++count;\r\n                }\r\n            }\r\n            return {\r\n                x: x / count,\r\n                y: y / count\r\n            };\r\n        },\r\n        nearest(items, eventPosition) {\r\n            let x = eventPosition.x;\r\n            let y = eventPosition.y;\r\n            let minDistance = Number.POSITIVE_INFINITY;\r\n            let i, len, nearestElement;\r\n            for (i = 0, len = items.length; i < len; ++i) {\r\n                const el = items[i].element;\r\n                if (el && el.hasValue()) {\r\n                    const center = el.getCenterPoint();\r\n                    const d = distanceBetweenPoints(eventPosition, center);\r\n                    if (d < minDistance) {\r\n                        minDistance = d;\r\n                        nearestElement = el;\r\n                    }\r\n                }\r\n            }\r\n            if (nearestElement) {\r\n                const tp = nearestElement.tooltipPosition();\r\n                x = tp.x;\r\n                y = tp.y;\r\n            }\r\n            return {\r\n                x,\r\n                y\r\n            };\r\n        }\r\n    };\r\n\r\n    function pushOrConcat(base, toPush) {\r\n        if (toPush) {\r\n            if (isArray(toPush)) {\r\n                Array.prototype.push.apply(base, toPush);\r\n            } else {\r\n                base.push(toPush);\r\n            }\r\n        }\r\n        return base;\r\n    }\r\n\r\n    function splitNewlines(str) {\r\n        if ((typeof str === 'string' || str instanceof String) && str.indexOf('\\n') > -1) {\r\n            return str.split('\\n');\r\n        }\r\n        return str;\r\n    }\r\n\r\n    function createTooltipItem(chart, item) {\r\n        const {element, datasetIndex, index} = item;\r\n        const controller = chart.getDatasetMeta(datasetIndex).controller;\r\n        const {label, value} = controller.getLabelAndValue(index);\r\n        return {\r\n            chart,\r\n            label,\r\n            parsed: controller.getParsed(index),\r\n            raw: chart.data.datasets[datasetIndex].data[index],\r\n            formattedValue: value,\r\n            dataset: controller.getDataset(),\r\n            dataIndex: index,\r\n            datasetIndex,\r\n            element\r\n        };\r\n    }\r\n\r\n    function getTooltipSize(tooltip, options) {\r\n        const ctx = tooltip._chart.ctx;\r\n        const {body, footer, title} = tooltip;\r\n        const {boxWidth, boxHeight} = options;\r\n        const bodyFont = toFont(options.bodyFont);\r\n        const titleFont = toFont(options.titleFont);\r\n        const footerFont = toFont(options.footerFont);\r\n        const titleLineCount = title.length;\r\n        const footerLineCount = footer.length;\r\n        const bodyLineItemCount = body.length;\r\n        const padding = toPadding(options.padding);\r\n        let height = padding.height;\r\n        let width = 0;\r\n        let combinedBodyLength = body.reduce((count, bodyItem) => count + bodyItem.before.length + bodyItem.lines.length + bodyItem.after.length, 0);\r\n        combinedBodyLength += tooltip.beforeBody.length + tooltip.afterBody.length;\r\n        if (titleLineCount) {\r\n            height += titleLineCount * titleFont.lineHeight\r\n                + (titleLineCount - 1) * options.titleSpacing\r\n                + options.titleMarginBottom;\r\n        }\r\n        if (combinedBodyLength) {\r\n            const bodyLineHeight = options.displayColors ? Math.max(boxHeight, bodyFont.lineHeight) : bodyFont.lineHeight;\r\n            height += bodyLineItemCount * bodyLineHeight\r\n                + (combinedBodyLength - bodyLineItemCount) * bodyFont.lineHeight\r\n                + (combinedBodyLength - 1) * options.bodySpacing;\r\n        }\r\n        if (footerLineCount) {\r\n            height += options.footerMarginTop\r\n                + footerLineCount * footerFont.lineHeight\r\n                + (footerLineCount - 1) * options.footerSpacing;\r\n        }\r\n        let widthPadding = 0;\r\n        const maxLineWidth = function (line) {\r\n            width = Math.max(width, ctx.measureText(line).width + widthPadding);\r\n        };\r\n        ctx.save();\r\n        ctx.font = titleFont.string;\r\n        each(tooltip.title, maxLineWidth);\r\n        ctx.font = bodyFont.string;\r\n        each(tooltip.beforeBody.concat(tooltip.afterBody), maxLineWidth);\r\n        widthPadding = options.displayColors ? (boxWidth + 2) : 0;\r\n        each(body, (bodyItem) => {\r\n            each(bodyItem.before, maxLineWidth);\r\n            each(bodyItem.lines, maxLineWidth);\r\n            each(bodyItem.after, maxLineWidth);\r\n        });\r\n        widthPadding = 0;\r\n        ctx.font = footerFont.string;\r\n        each(tooltip.footer, maxLineWidth);\r\n        ctx.restore();\r\n        width += padding.width;\r\n        return {width, height};\r\n    }\r\n\r\n    function determineYAlign(chart, size) {\r\n        const {y, height} = size;\r\n        if (y < height / 2) {\r\n            return 'top';\r\n        } else if (y > (chart.height - height / 2)) {\r\n            return 'bottom';\r\n        }\r\n        return 'center';\r\n    }\r\n\r\n    function doesNotFitWithAlign(xAlign, chart, options, size) {\r\n        const {x, width} = size;\r\n        const caret = options.caretSize + options.caretPadding;\r\n        if (xAlign === 'left' && x + width + caret > chart.width) {\r\n            return true;\r\n        }\r\n        if (xAlign === 'right' && x - width - caret < 0) {\r\n            return true;\r\n        }\r\n    }\r\n\r\n    function determineXAlign(chart, options, size, yAlign) {\r\n        const {x, width} = size;\r\n        const {width: chartWidth, chartArea: {left, right}} = chart;\r\n        let xAlign = 'center';\r\n        if (yAlign === 'center') {\r\n            xAlign = x <= (left + right) / 2 ? 'left' : 'right';\r\n        } else if (x <= width / 2) {\r\n            xAlign = 'left';\r\n        } else if (x >= chartWidth - width / 2) {\r\n            xAlign = 'right';\r\n        }\r\n        if (doesNotFitWithAlign(xAlign, chart, options, size)) {\r\n            xAlign = 'center';\r\n        }\r\n        return xAlign;\r\n    }\r\n\r\n    function determineAlignment(chart, options, size) {\r\n        const yAlign = options.yAlign || determineYAlign(chart, size);\r\n        return {\r\n            xAlign: options.xAlign || determineXAlign(chart, options, size, yAlign),\r\n            yAlign\r\n        };\r\n    }\r\n\r\n    function alignX(size, xAlign) {\r\n        let {x, width} = size;\r\n        if (xAlign === 'right') {\r\n            x -= width;\r\n        } else if (xAlign === 'center') {\r\n            x -= (width / 2);\r\n        }\r\n        return x;\r\n    }\r\n\r\n    function alignY(size, yAlign, paddingAndSize) {\r\n        let {y, height} = size;\r\n        if (yAlign === 'top') {\r\n            y += paddingAndSize;\r\n        } else if (yAlign === 'bottom') {\r\n            y -= height + paddingAndSize;\r\n        } else {\r\n            y -= (height / 2);\r\n        }\r\n        return y;\r\n    }\r\n\r\n    function getBackgroundPoint(options, size, alignment, chart) {\r\n        const {caretSize, caretPadding, cornerRadius} = options;\r\n        const {xAlign, yAlign} = alignment;\r\n        const paddingAndSize = caretSize + caretPadding;\r\n        const radiusAndPadding = cornerRadius + caretPadding;\r\n        let x = alignX(size, xAlign);\r\n        const y = alignY(size, yAlign, paddingAndSize);\r\n        if (yAlign === 'center') {\r\n            if (xAlign === 'left') {\r\n                x += paddingAndSize;\r\n            } else if (xAlign === 'right') {\r\n                x -= paddingAndSize;\r\n            }\r\n        } else if (xAlign === 'left') {\r\n            x -= radiusAndPadding;\r\n        } else if (xAlign === 'right') {\r\n            x += radiusAndPadding;\r\n        }\r\n        return {\r\n            x: _limitValue(x, 0, chart.width - size.width),\r\n            y: _limitValue(y, 0, chart.height - size.height)\r\n        };\r\n    }\r\n\r\n    function getAlignedX(tooltip, align, options) {\r\n        const padding = toPadding(options.padding);\r\n        return align === 'center'\r\n            ? tooltip.x + tooltip.width / 2\r\n            : align === 'right'\r\n                ? tooltip.x + tooltip.width - padding.right\r\n                : tooltip.x + padding.left;\r\n    }\r\n\r\n    function getBeforeAfterBodyLines(callback) {\r\n        return pushOrConcat([], splitNewlines(callback));\r\n    }\r\n\r\n    function createTooltipContext(parent, tooltip, tooltipItems) {\r\n        return Object.assign(Object.create(parent), {\r\n            tooltip,\r\n            tooltipItems,\r\n            type: 'tooltip'\r\n        });\r\n    }\r\n\r\n    function overrideCallbacks(callbacks, context) {\r\n        const override = context && context.dataset && context.dataset.tooltip && context.dataset.tooltip.callbacks;\r\n        return override ? callbacks.override(override) : callbacks;\r\n    }\r\n\r\n    class Tooltip extends Element {\r\n        constructor(config) {\r\n            super();\r\n            this.opacity = 0;\r\n            this._active = [];\r\n            this._chart = config._chart;\r\n            this._eventPosition = undefined;\r\n            this._size = undefined;\r\n            this._cachedAnimations = undefined;\r\n            this._tooltipItems = [];\r\n            this.$animations = undefined;\r\n            this.$context = undefined;\r\n            this.options = config.options;\r\n            this.dataPoints = undefined;\r\n            this.title = undefined;\r\n            this.beforeBody = undefined;\r\n            this.body = undefined;\r\n            this.afterBody = undefined;\r\n            this.footer = undefined;\r\n            this.xAlign = undefined;\r\n            this.yAlign = undefined;\r\n            this.x = undefined;\r\n            this.y = undefined;\r\n            this.height = undefined;\r\n            this.width = undefined;\r\n            this.caretX = undefined;\r\n            this.caretY = undefined;\r\n            this.labelColors = undefined;\r\n            this.labelPointStyles = undefined;\r\n            this.labelTextColors = undefined;\r\n        }\r\n\r\n        initialize(options) {\r\n            this.options = options;\r\n            this._cachedAnimations = undefined;\r\n            this.$context = undefined;\r\n        }\r\n\r\n        _resolveAnimations() {\r\n            const me = this;\r\n            const cached = me._cachedAnimations;\r\n            if (cached) {\r\n                return cached;\r\n            }\r\n            const chart = me._chart;\r\n            const options = me.options.setContext(me.getContext());\r\n            const opts = options.enabled && chart.options.animation && options.animations;\r\n            const animations = new Animations(me._chart, opts);\r\n            if (opts._cacheable) {\r\n                me._cachedAnimations = Object.freeze(animations);\r\n            }\r\n            return animations;\r\n        }\r\n\r\n        getContext() {\r\n            const me = this;\r\n            return me.$context ||\r\n                (me.$context = createTooltipContext(me._chart.getContext(), me, me._tooltipItems));\r\n        }\r\n\r\n        getTitle(context, options) {\r\n            const me = this;\r\n            const {callbacks} = options;\r\n            const beforeTitle = callbacks.beforeTitle.apply(me, [context]);\r\n            const title = callbacks.title.apply(me, [context]);\r\n            const afterTitle = callbacks.afterTitle.apply(me, [context]);\r\n            let lines = [];\r\n            lines = pushOrConcat(lines, splitNewlines(beforeTitle));\r\n            lines = pushOrConcat(lines, splitNewlines(title));\r\n            lines = pushOrConcat(lines, splitNewlines(afterTitle));\r\n            return lines;\r\n        }\r\n\r\n        getBeforeBody(tooltipItems, options) {\r\n            return getBeforeAfterBodyLines(options.callbacks.beforeBody.apply(this, [tooltipItems]));\r\n        }\r\n\r\n        getBody(tooltipItems, options) {\r\n            const me = this;\r\n            const {callbacks} = options;\r\n            const bodyItems = [];\r\n            each(tooltipItems, (context) => {\r\n                const bodyItem = {\r\n                    before: [],\r\n                    lines: [],\r\n                    after: []\r\n                };\r\n                const scoped = overrideCallbacks(callbacks, context);\r\n                pushOrConcat(bodyItem.before, splitNewlines(scoped.beforeLabel.call(me, context)));\r\n                pushOrConcat(bodyItem.lines, scoped.label.call(me, context));\r\n                pushOrConcat(bodyItem.after, splitNewlines(scoped.afterLabel.call(me, context)));\r\n                bodyItems.push(bodyItem);\r\n            });\r\n            return bodyItems;\r\n        }\r\n\r\n        getAfterBody(tooltipItems, options) {\r\n            return getBeforeAfterBodyLines(options.callbacks.afterBody.apply(this, [tooltipItems]));\r\n        }\r\n\r\n        getFooter(tooltipItems, options) {\r\n            const me = this;\r\n            const {callbacks} = options;\r\n            const beforeFooter = callbacks.beforeFooter.apply(me, [tooltipItems]);\r\n            const footer = callbacks.footer.apply(me, [tooltipItems]);\r\n            const afterFooter = callbacks.afterFooter.apply(me, [tooltipItems]);\r\n            let lines = [];\r\n            lines = pushOrConcat(lines, splitNewlines(beforeFooter));\r\n            lines = pushOrConcat(lines, splitNewlines(footer));\r\n            lines = pushOrConcat(lines, splitNewlines(afterFooter));\r\n            return lines;\r\n        }\r\n\r\n        _createItems(options) {\r\n            const me = this;\r\n            const active = me._active;\r\n            const data = me._chart.data;\r\n            const labelColors = [];\r\n            const labelPointStyles = [];\r\n            const labelTextColors = [];\r\n            let tooltipItems = [];\r\n            let i, len;\r\n            for (i = 0, len = active.length; i < len; ++i) {\r\n                tooltipItems.push(createTooltipItem(me._chart, active[i]));\r\n            }\r\n            if (options.filter) {\r\n                tooltipItems = tooltipItems.filter((element, index, array) => options.filter(element, index, array, data));\r\n            }\r\n            if (options.itemSort) {\r\n                tooltipItems = tooltipItems.sort((a, b) => options.itemSort(a, b, data));\r\n            }\r\n            each(tooltipItems, (context) => {\r\n                const scoped = overrideCallbacks(options.callbacks, context);\r\n                labelColors.push(scoped.labelColor.call(me, context));\r\n                labelPointStyles.push(scoped.labelPointStyle.call(me, context));\r\n                labelTextColors.push(scoped.labelTextColor.call(me, context));\r\n            });\r\n            me.labelColors = labelColors;\r\n            me.labelPointStyles = labelPointStyles;\r\n            me.labelTextColors = labelTextColors;\r\n            me.dataPoints = tooltipItems;\r\n            return tooltipItems;\r\n        }\r\n\r\n        update(changed, replay) {\r\n            const me = this;\r\n            const options = me.options.setContext(me.getContext());\r\n            const active = me._active;\r\n            let properties;\r\n            let tooltipItems = [];\r\n            if (!active.length) {\r\n                if (me.opacity !== 0) {\r\n                    properties = {\r\n                        opacity: 0\r\n                    };\r\n                }\r\n            } else {\r\n                const position = positioners[options.position].call(me, active, me._eventPosition);\r\n                tooltipItems = me._createItems(options);\r\n                me.title = me.getTitle(tooltipItems, options);\r\n                me.beforeBody = me.getBeforeBody(tooltipItems, options);\r\n                me.body = me.getBody(tooltipItems, options);\r\n                me.afterBody = me.getAfterBody(tooltipItems, options);\r\n                me.footer = me.getFooter(tooltipItems, options);\r\n                const size = me._size = getTooltipSize(me, options);\r\n                const positionAndSize = Object.assign({}, position, size);\r\n                const alignment = determineAlignment(me._chart, options, positionAndSize);\r\n                const backgroundPoint = getBackgroundPoint(options, positionAndSize, alignment, me._chart);\r\n                me.xAlign = alignment.xAlign;\r\n                me.yAlign = alignment.yAlign;\r\n                properties = {\r\n                    opacity: 1,\r\n                    x: backgroundPoint.x,\r\n                    y: backgroundPoint.y,\r\n                    width: size.width,\r\n                    height: size.height,\r\n                    caretX: position.x,\r\n                    caretY: position.y\r\n                };\r\n            }\r\n            me._tooltipItems = tooltipItems;\r\n            me.$context = undefined;\r\n            if (properties) {\r\n                me._resolveAnimations().update(me, properties);\r\n            }\r\n            if (changed && options.external) {\r\n                options.external.call(me, {chart: me._chart, tooltip: me, replay});\r\n            }\r\n        }\r\n\r\n        drawCaret(tooltipPoint, ctx, size, options) {\r\n            const caretPosition = this.getCaretPosition(tooltipPoint, size, options);\r\n            ctx.lineTo(caretPosition.x1, caretPosition.y1);\r\n            ctx.lineTo(caretPosition.x2, caretPosition.y2);\r\n            ctx.lineTo(caretPosition.x3, caretPosition.y3);\r\n        }\r\n\r\n        getCaretPosition(tooltipPoint, size, options) {\r\n            const {xAlign, yAlign} = this;\r\n            const {cornerRadius, caretSize} = options;\r\n            const {x: ptX, y: ptY} = tooltipPoint;\r\n            const {width, height} = size;\r\n            let x1, x2, x3, y1, y2, y3;\r\n            if (yAlign === 'center') {\r\n                y2 = ptY + (height / 2);\r\n                if (xAlign === 'left') {\r\n                    x1 = ptX;\r\n                    x2 = x1 - caretSize;\r\n                    y1 = y2 + caretSize;\r\n                    y3 = y2 - caretSize;\r\n                } else {\r\n                    x1 = ptX + width;\r\n                    x2 = x1 + caretSize;\r\n                    y1 = y2 - caretSize;\r\n                    y3 = y2 + caretSize;\r\n                }\r\n                x3 = x1;\r\n            } else {\r\n                if (xAlign === 'left') {\r\n                    x2 = ptX + cornerRadius + (caretSize);\r\n                } else if (xAlign === 'right') {\r\n                    x2 = ptX + width - cornerRadius - caretSize;\r\n                } else {\r\n                    x2 = this.caretX;\r\n                }\r\n                if (yAlign === 'top') {\r\n                    y1 = ptY;\r\n                    y2 = y1 - caretSize;\r\n                    x1 = x2 - caretSize;\r\n                    x3 = x2 + caretSize;\r\n                } else {\r\n                    y1 = ptY + height;\r\n                    y2 = y1 + caretSize;\r\n                    x1 = x2 + caretSize;\r\n                    x3 = x2 - caretSize;\r\n                }\r\n                y3 = y1;\r\n            }\r\n            return {x1, x2, x3, y1, y2, y3};\r\n        }\r\n\r\n        drawTitle(pt, ctx, options) {\r\n            const me = this;\r\n            const title = me.title;\r\n            const length = title.length;\r\n            let titleFont, titleSpacing, i;\r\n            if (length) {\r\n                const rtlHelper = getRtlAdapter(options.rtl, me.x, me.width);\r\n                pt.x = getAlignedX(me, options.titleAlign, options);\r\n                ctx.textAlign = rtlHelper.textAlign(options.titleAlign);\r\n                ctx.textBaseline = 'middle';\r\n                titleFont = toFont(options.titleFont);\r\n                titleSpacing = options.titleSpacing;\r\n                ctx.fillStyle = options.titleColor;\r\n                ctx.font = titleFont.string;\r\n                for (i = 0; i < length; ++i) {\r\n                    ctx.fillText(title[i], rtlHelper.x(pt.x), pt.y + titleFont.lineHeight / 2);\r\n                    pt.y += titleFont.lineHeight + titleSpacing;\r\n                    if (i + 1 === length) {\r\n                        pt.y += options.titleMarginBottom - titleSpacing;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        _drawColorBox(ctx, pt, i, rtlHelper, options) {\r\n            const me = this;\r\n            const labelColors = me.labelColors[i];\r\n            const labelPointStyle = me.labelPointStyles[i];\r\n            const {boxHeight, boxWidth} = options;\r\n            const bodyFont = toFont(options.bodyFont);\r\n            const colorX = getAlignedX(me, 'left', options);\r\n            const rtlColorX = rtlHelper.x(colorX);\r\n            const yOffSet = boxHeight < bodyFont.lineHeight ? (bodyFont.lineHeight - boxHeight) / 2 : 0;\r\n            const colorY = pt.y + yOffSet;\r\n            if (options.usePointStyle) {\r\n                const drawOptions = {\r\n                    radius: Math.min(boxWidth, boxHeight) / 2,\r\n                    pointStyle: labelPointStyle.pointStyle,\r\n                    rotation: labelPointStyle.rotation,\r\n                    borderWidth: 1\r\n                };\r\n                const centerX = rtlHelper.leftForLtr(rtlColorX, boxWidth) + boxWidth / 2;\r\n                const centerY = colorY + boxHeight / 2;\r\n                ctx.strokeStyle = options.multiKeyBackground;\r\n                ctx.fillStyle = options.multiKeyBackground;\r\n                drawPoint(ctx, drawOptions, centerX, centerY);\r\n                ctx.strokeStyle = labelColors.borderColor;\r\n                ctx.fillStyle = labelColors.backgroundColor;\r\n                drawPoint(ctx, drawOptions, centerX, centerY);\r\n            } else {\r\n                ctx.fillStyle = options.multiKeyBackground;\r\n                ctx.fillRect(rtlHelper.leftForLtr(rtlColorX, boxWidth), colorY, boxWidth, boxHeight);\r\n                ctx.lineWidth = 1;\r\n                ctx.strokeStyle = labelColors.borderColor;\r\n                ctx.strokeRect(rtlHelper.leftForLtr(rtlColorX, boxWidth), colorY, boxWidth, boxHeight);\r\n                ctx.fillStyle = labelColors.backgroundColor;\r\n                ctx.fillRect(rtlHelper.leftForLtr(rtlHelper.xPlus(rtlColorX, 1), boxWidth - 2), colorY + 1, boxWidth - 2, boxHeight - 2);\r\n            }\r\n            ctx.fillStyle = me.labelTextColors[i];\r\n        }\r\n\r\n        drawBody(pt, ctx, options) {\r\n            const me = this;\r\n            const {body} = me;\r\n            const {bodySpacing, bodyAlign, displayColors, boxHeight, boxWidth} = options;\r\n            const bodyFont = toFont(options.bodyFont);\r\n            let bodyLineHeight = bodyFont.lineHeight;\r\n            let xLinePadding = 0;\r\n            const rtlHelper = getRtlAdapter(options.rtl, me.x, me.width);\r\n            const fillLineOfText = function (line) {\r\n                ctx.fillText(line, rtlHelper.x(pt.x + xLinePadding), pt.y + bodyLineHeight / 2);\r\n                pt.y += bodyLineHeight + bodySpacing;\r\n            };\r\n            const bodyAlignForCalculation = rtlHelper.textAlign(bodyAlign);\r\n            let bodyItem, textColor, lines, i, j, ilen, jlen;\r\n            ctx.textAlign = bodyAlign;\r\n            ctx.textBaseline = 'middle';\r\n            ctx.font = bodyFont.string;\r\n            pt.x = getAlignedX(me, bodyAlignForCalculation, options);\r\n            ctx.fillStyle = options.bodyColor;\r\n            each(me.beforeBody, fillLineOfText);\r\n            xLinePadding = displayColors && bodyAlignForCalculation !== 'right'\r\n                ? bodyAlign === 'center' ? (boxWidth / 2 + 1) : (boxWidth + 2)\r\n                : 0;\r\n            for (i = 0, ilen = body.length; i < ilen; ++i) {\r\n                bodyItem = body[i];\r\n                textColor = me.labelTextColors[i];\r\n                ctx.fillStyle = textColor;\r\n                each(bodyItem.before, fillLineOfText);\r\n                lines = bodyItem.lines;\r\n                if (displayColors && lines.length) {\r\n                    me._drawColorBox(ctx, pt, i, rtlHelper, options);\r\n                    bodyLineHeight = Math.max(bodyFont.lineHeight, boxHeight);\r\n                }\r\n                for (j = 0, jlen = lines.length; j < jlen; ++j) {\r\n                    fillLineOfText(lines[j]);\r\n                    bodyLineHeight = bodyFont.lineHeight;\r\n                }\r\n                each(bodyItem.after, fillLineOfText);\r\n            }\r\n            xLinePadding = 0;\r\n            bodyLineHeight = bodyFont.lineHeight;\r\n            each(me.afterBody, fillLineOfText);\r\n            pt.y -= bodySpacing;\r\n        }\r\n\r\n        drawFooter(pt, ctx, options) {\r\n            const me = this;\r\n            const footer = me.footer;\r\n            const length = footer.length;\r\n            let footerFont, i;\r\n            if (length) {\r\n                const rtlHelper = getRtlAdapter(options.rtl, me.x, me.width);\r\n                pt.x = getAlignedX(me, options.footerAlign, options);\r\n                pt.y += options.footerMarginTop;\r\n                ctx.textAlign = rtlHelper.textAlign(options.footerAlign);\r\n                ctx.textBaseline = 'middle';\r\n                footerFont = toFont(options.footerFont);\r\n                ctx.fillStyle = options.footerColor;\r\n                ctx.font = footerFont.string;\r\n                for (i = 0; i < length; ++i) {\r\n                    ctx.fillText(footer[i], rtlHelper.x(pt.x), pt.y + footerFont.lineHeight / 2);\r\n                    pt.y += footerFont.lineHeight + options.footerSpacing;\r\n                }\r\n            }\r\n        }\r\n\r\n        drawBackground(pt, ctx, tooltipSize, options) {\r\n            const {xAlign, yAlign} = this;\r\n            const {x, y} = pt;\r\n            const {width, height} = tooltipSize;\r\n            const radius = options.cornerRadius;\r\n            ctx.fillStyle = options.backgroundColor;\r\n            ctx.strokeStyle = options.borderColor;\r\n            ctx.lineWidth = options.borderWidth;\r\n            ctx.beginPath();\r\n            ctx.moveTo(x + radius, y);\r\n            if (yAlign === 'top') {\r\n                this.drawCaret(pt, ctx, tooltipSize, options);\r\n            }\r\n            ctx.lineTo(x + width - radius, y);\r\n            ctx.quadraticCurveTo(x + width, y, x + width, y + radius);\r\n            if (yAlign === 'center' && xAlign === 'right') {\r\n                this.drawCaret(pt, ctx, tooltipSize, options);\r\n            }\r\n            ctx.lineTo(x + width, y + height - radius);\r\n            ctx.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);\r\n            if (yAlign === 'bottom') {\r\n                this.drawCaret(pt, ctx, tooltipSize, options);\r\n            }\r\n            ctx.lineTo(x + radius, y + height);\r\n            ctx.quadraticCurveTo(x, y + height, x, y + height - radius);\r\n            if (yAlign === 'center' && xAlign === 'left') {\r\n                this.drawCaret(pt, ctx, tooltipSize, options);\r\n            }\r\n            ctx.lineTo(x, y + radius);\r\n            ctx.quadraticCurveTo(x, y, x + radius, y);\r\n            ctx.closePath();\r\n            ctx.fill();\r\n            if (options.borderWidth > 0) {\r\n                ctx.stroke();\r\n            }\r\n        }\r\n\r\n        _updateAnimationTarget(options) {\r\n            const me = this;\r\n            const chart = me._chart;\r\n            const anims = me.$animations;\r\n            const animX = anims && anims.x;\r\n            const animY = anims && anims.y;\r\n            if (animX || animY) {\r\n                const position = positioners[options.position].call(me, me._active, me._eventPosition);\r\n                if (!position) {\r\n                    return;\r\n                }\r\n                const size = me._size = getTooltipSize(me, options);\r\n                const positionAndSize = Object.assign({}, position, me._size);\r\n                const alignment = determineAlignment(chart, options, positionAndSize);\r\n                const point = getBackgroundPoint(options, positionAndSize, alignment, chart);\r\n                if (animX._to !== point.x || animY._to !== point.y) {\r\n                    me.xAlign = alignment.xAlign;\r\n                    me.yAlign = alignment.yAlign;\r\n                    me.width = size.width;\r\n                    me.height = size.height;\r\n                    me.caretX = position.x;\r\n                    me.caretY = position.y;\r\n                    me._resolveAnimations().update(me, point);\r\n                }\r\n            }\r\n        }\r\n\r\n        draw(ctx) {\r\n            const me = this;\r\n            const options = me.options.setContext(me.getContext());\r\n            let opacity = me.opacity;\r\n            if (!opacity) {\r\n                return;\r\n            }\r\n            me._updateAnimationTarget(options);\r\n            const tooltipSize = {\r\n                width: me.width,\r\n                height: me.height\r\n            };\r\n            const pt = {\r\n                x: me.x,\r\n                y: me.y\r\n            };\r\n            opacity = Math.abs(opacity) < 1e-3 ? 0 : opacity;\r\n            const padding = toPadding(options.padding);\r\n            const hasTooltipContent = me.title.length || me.beforeBody.length || me.body.length || me.afterBody.length || me.footer.length;\r\n            if (options.enabled && hasTooltipContent) {\r\n                ctx.save();\r\n                ctx.globalAlpha = opacity;\r\n                me.drawBackground(pt, ctx, tooltipSize, options);\r\n                overrideTextDirection(ctx, options.textDirection);\r\n                pt.y += padding.top;\r\n                me.drawTitle(pt, ctx, options);\r\n                me.drawBody(pt, ctx, options);\r\n                me.drawFooter(pt, ctx, options);\r\n                restoreTextDirection(ctx, options.textDirection);\r\n                ctx.restore();\r\n            }\r\n        }\r\n\r\n        getActiveElements() {\r\n            return this._active || [];\r\n        }\r\n\r\n        setActiveElements(activeElements, eventPosition) {\r\n            const me = this;\r\n            const lastActive = me._active;\r\n            const active = activeElements.map(({datasetIndex, index}) => {\r\n                const meta = me._chart.getDatasetMeta(datasetIndex);\r\n                if (!meta) {\r\n                    throw new Error('Cannot find a dataset at index ' + datasetIndex);\r\n                }\r\n                return {\r\n                    datasetIndex,\r\n                    element: meta.data[index],\r\n                    index,\r\n                };\r\n            });\r\n            const changed = !_elementsEqual(lastActive, active);\r\n            const positionChanged = me._positionChanged(active, eventPosition);\r\n            if (changed || positionChanged) {\r\n                me._active = active;\r\n                me._eventPosition = eventPosition;\r\n                me.update(true);\r\n            }\r\n        }\r\n\r\n        handleEvent(e, replay) {\r\n            const me = this;\r\n            const options = me.options;\r\n            const lastActive = me._active || [];\r\n            let changed = false;\r\n            let active = [];\r\n            if (e.type !== 'mouseout') {\r\n                active = me._chart.getElementsAtEventForMode(e, options.mode, options, replay);\r\n                if (options.reverse) {\r\n                    active.reverse();\r\n                }\r\n            }\r\n            const positionChanged = me._positionChanged(active, e);\r\n            changed = replay || !_elementsEqual(active, lastActive) || positionChanged;\r\n            if (changed) {\r\n                me._active = active;\r\n                if (options.enabled || options.external) {\r\n                    me._eventPosition = {\r\n                        x: e.x,\r\n                        y: e.y\r\n                    };\r\n                    me.update(true, replay);\r\n                }\r\n            }\r\n            return changed;\r\n        }\r\n\r\n        _positionChanged(active, e) {\r\n            const me = this;\r\n            const position = positioners[me.options.position].call(me, active, e);\r\n            return me.caretX !== position.x || me.caretY !== position.y;\r\n        }\r\n    }\r\n\r\n    Tooltip.positioners = positioners;\r\n    var plugin_tooltip = {\r\n        id: 'tooltip',\r\n        _element: Tooltip,\r\n        positioners,\r\n        afterInit(chart, _args, options) {\r\n            if (options) {\r\n                chart.tooltip = new Tooltip({_chart: chart, options});\r\n            }\r\n        },\r\n        beforeUpdate(chart, _args, options) {\r\n            if (chart.tooltip) {\r\n                chart.tooltip.initialize(options);\r\n            }\r\n        },\r\n        reset(chart, _args, options) {\r\n            if (chart.tooltip) {\r\n                chart.tooltip.initialize(options);\r\n            }\r\n        },\r\n        afterDraw(chart) {\r\n            const tooltip = chart.tooltip;\r\n            const args = {\r\n                tooltip\r\n            };\r\n            if (chart.notifyPlugins('beforeTooltipDraw', args) === false) {\r\n                return;\r\n            }\r\n            if (tooltip) {\r\n                tooltip.draw(chart.ctx);\r\n            }\r\n            chart.notifyPlugins('afterTooltipDraw', args);\r\n        },\r\n        afterEvent(chart, args) {\r\n            if (chart.tooltip) {\r\n                const useFinalPosition = args.replay;\r\n                if (chart.tooltip.handleEvent(args.event, useFinalPosition)) {\r\n                    args.changed = true;\r\n                }\r\n            }\r\n        },\r\n        defaults: {\r\n            enabled: true,\r\n            external: null,\r\n            position: 'average',\r\n            backgroundColor: 'rgba(0,0,0,0.8)',\r\n            titleColor: '#fff',\r\n            titleFont: {\r\n                style: 'bold',\r\n            },\r\n            titleSpacing: 2,\r\n            titleMarginBottom: 6,\r\n            titleAlign: 'left',\r\n            bodyColor: '#fff',\r\n            bodySpacing: 2,\r\n            bodyFont: {},\r\n            bodyAlign: 'left',\r\n            footerColor: '#fff',\r\n            footerSpacing: 2,\r\n            footerMarginTop: 6,\r\n            footerFont: {\r\n                style: 'bold',\r\n            },\r\n            footerAlign: 'left',\r\n            padding: 6,\r\n            caretPadding: 2,\r\n            caretSize: 5,\r\n            cornerRadius: 6,\r\n            boxHeight: (ctx, opts) => opts.bodyFont.size,\r\n            boxWidth: (ctx, opts) => opts.bodyFont.size,\r\n            multiKeyBackground: '#fff',\r\n            displayColors: true,\r\n            borderColor: 'rgba(0,0,0,0)',\r\n            borderWidth: 0,\r\n            animation: {\r\n                duration: 400,\r\n                easing: 'easeOutQuart',\r\n            },\r\n            animations: {\r\n                numbers: {\r\n                    type: 'number',\r\n                    properties: ['x', 'y', 'width', 'height', 'caretX', 'caretY'],\r\n                },\r\n                opacity: {\r\n                    easing: 'linear',\r\n                    duration: 200\r\n                }\r\n            },\r\n            callbacks: {\r\n                beforeTitle: noop,\r\n                title(tooltipItems) {\r\n                    if (tooltipItems.length > 0) {\r\n                        const item = tooltipItems[0];\r\n                        const labels = item.chart.data.labels;\r\n                        const labelCount = labels ? labels.length : 0;\r\n                        if (this && this.options && this.options.mode === 'dataset') {\r\n                            return item.dataset.label || '';\r\n                        } else if (item.label) {\r\n                            return item.label;\r\n                        } else if (labelCount > 0 && item.dataIndex < labelCount) {\r\n                            return labels[item.dataIndex];\r\n                        }\r\n                    }\r\n                    return '';\r\n                },\r\n                afterTitle: noop,\r\n                beforeBody: noop,\r\n                beforeLabel: noop,\r\n                label(tooltipItem) {\r\n                    if (this && this.options && this.options.mode === 'dataset') {\r\n                        return tooltipItem.label + ': ' + tooltipItem.formattedValue || tooltipItem.formattedValue;\r\n                    }\r\n                    let label = tooltipItem.dataset.label || '';\r\n                    if (label) {\r\n                        label += ': ';\r\n                    }\r\n                    const value = tooltipItem.formattedValue;\r\n                    if (!isNullOrUndef(value)) {\r\n                        label += value;\r\n                    }\r\n                    return label;\r\n                },\r\n                labelColor(tooltipItem) {\r\n                    const meta = tooltipItem.chart.getDatasetMeta(tooltipItem.datasetIndex);\r\n                    const options = meta.controller.getStyle(tooltipItem.dataIndex);\r\n                    return {\r\n                        borderColor: options.borderColor,\r\n                        backgroundColor: options.backgroundColor\r\n                    };\r\n                },\r\n                labelTextColor() {\r\n                    return this.options.bodyColor;\r\n                },\r\n                labelPointStyle(tooltipItem) {\r\n                    const meta = tooltipItem.chart.getDatasetMeta(tooltipItem.datasetIndex);\r\n                    const options = meta.controller.getStyle(tooltipItem.dataIndex);\r\n                    return {\r\n                        pointStyle: options.pointStyle,\r\n                        rotation: options.rotation,\r\n                    };\r\n                },\r\n                afterLabel: noop,\r\n                afterBody: noop,\r\n                beforeFooter: noop,\r\n                footer: noop,\r\n                afterFooter: noop\r\n            }\r\n        },\r\n        defaultRoutes: {\r\n            bodyFont: 'font',\r\n            footerFont: 'font',\r\n            titleFont: 'font'\r\n        },\r\n        descriptors: {\r\n            _scriptable: (name) => name !== 'filter' && name !== 'itemSort' && name !== 'external',\r\n            _indexable: false,\r\n            callbacks: {\r\n                _scriptable: false,\r\n                _indexable: false,\r\n            },\r\n            animation: {\r\n                _fallback: false\r\n            },\r\n            animations: {\r\n                _fallback: 'animation'\r\n            }\r\n        },\r\n        additionalOptionScopes: ['interaction']\r\n    };\r\n\r\n    var plugins = /*#__PURE__*/Object.freeze({\r\n        __proto__: null,\r\n        Decimation: plugin_decimation,\r\n        Filler: plugin_filler,\r\n        Legend: plugin_legend,\r\n        Title: plugin_title,\r\n        Tooltip: plugin_tooltip\r\n    });\r\n\r\n    const addIfString = (labels, raw, index) => typeof raw === 'string'\r\n        ? labels.push(raw) - 1\r\n        : isNaN(raw) ? null : index;\r\n\r\n    function findOrAddLabel(labels, raw, index) {\r\n        const first = labels.indexOf(raw);\r\n        if (first === -1) {\r\n            return addIfString(labels, raw, index);\r\n        }\r\n        const last = labels.lastIndexOf(raw);\r\n        return first !== last ? index : first;\r\n    }\r\n\r\n    const validIndex = (index, max) => index === null ? null : _limitValue(Math.round(index), 0, max);\r\n\r\n    class CategoryScale extends Scale {\r\n        constructor(cfg) {\r\n            super(cfg);\r\n            this._startValue = undefined;\r\n            this._valueRange = 0;\r\n        }\r\n\r\n        parse(raw, index) {\r\n            if (isNullOrUndef(raw)) {\r\n                return null;\r\n            }\r\n            const labels = this.getLabels();\r\n            index = isFinite(index) && labels[index] === raw ? index\r\n                : findOrAddLabel(labels, raw, valueOrDefault(index, raw));\r\n            return validIndex(index, labels.length - 1);\r\n        }\r\n\r\n        determineDataLimits() {\r\n            const me = this;\r\n            const {minDefined, maxDefined} = me.getUserBounds();\r\n            let {min, max} = me.getMinMax(true);\r\n            if (me.options.bounds === 'ticks') {\r\n                if (!minDefined) {\r\n                    min = 0;\r\n                }\r\n                if (!maxDefined) {\r\n                    max = me.getLabels().length - 1;\r\n                }\r\n            }\r\n            me.min = min;\r\n            me.max = max;\r\n        }\r\n\r\n        buildTicks() {\r\n            const me = this;\r\n            const min = me.min;\r\n            const max = me.max;\r\n            const offset = me.options.offset;\r\n            const ticks = [];\r\n            let labels = me.getLabels();\r\n            labels = (min === 0 && max === labels.length - 1) ? labels : labels.slice(min, max + 1);\r\n            me._valueRange = Math.max(labels.length - (offset ? 0 : 1), 1);\r\n            me._startValue = me.min - (offset ? 0.5 : 0);\r\n            for (let value = min; value <= max; value++) {\r\n                ticks.push({value});\r\n            }\r\n            return ticks;\r\n        }\r\n\r\n        getLabelForValue(value) {\r\n            const me = this;\r\n            const labels = me.getLabels();\r\n            if (value >= 0 && value < labels.length) {\r\n                return labels[value];\r\n            }\r\n            return value;\r\n        }\r\n\r\n        configure() {\r\n            const me = this;\r\n            super.configure();\r\n            if (!me.isHorizontal()) {\r\n                me._reversePixels = !me._reversePixels;\r\n            }\r\n        }\r\n\r\n        getPixelForValue(value) {\r\n            const me = this;\r\n            if (typeof value !== 'number') {\r\n                value = me.parse(value);\r\n            }\r\n            return value === null ? NaN : me.getPixelForDecimal((value - me._startValue) / me._valueRange);\r\n        }\r\n\r\n        getPixelForTick(index) {\r\n            const me = this;\r\n            const ticks = me.ticks;\r\n            if (index < 0 || index > ticks.length - 1) {\r\n                return null;\r\n            }\r\n            return me.getPixelForValue(ticks[index].value);\r\n        }\r\n\r\n        getValueForPixel(pixel) {\r\n            const me = this;\r\n            return Math.round(me._startValue + me.getDecimalForPixel(pixel) * me._valueRange);\r\n        }\r\n\r\n        getBasePixel() {\r\n            return this.bottom;\r\n        }\r\n    }\r\n\r\n    CategoryScale.id = 'category';\r\n    CategoryScale.defaults = {\r\n        ticks: {\r\n            callback: CategoryScale.prototype.getLabelForValue\r\n        }\r\n    };\r\n\r\n    function generateTicks$1(generationOptions, dataRange) {\r\n        const ticks = [];\r\n        const MIN_SPACING = 1e-14;\r\n        const {step, min, max, precision, count, maxTicks} = generationOptions;\r\n        const unit = step || 1;\r\n        const maxSpaces = maxTicks - 1;\r\n        const {min: rmin, max: rmax} = dataRange;\r\n        const minDefined = !isNullOrUndef(min);\r\n        const maxDefined = !isNullOrUndef(max);\r\n        const countDefined = !isNullOrUndef(count);\r\n        let spacing = niceNum((rmax - rmin) / maxSpaces / unit) * unit;\r\n        let factor, niceMin, niceMax, numSpaces;\r\n        if (spacing < MIN_SPACING && !minDefined && !maxDefined) {\r\n            return [{value: rmin}, {value: rmax}];\r\n        }\r\n        numSpaces = Math.ceil(rmax / spacing) - Math.floor(rmin / spacing);\r\n        if (numSpaces > maxSpaces) {\r\n            spacing = niceNum(numSpaces * spacing / maxSpaces / unit) * unit;\r\n        }\r\n        if (!isNullOrUndef(precision)) {\r\n            factor = Math.pow(10, precision);\r\n            spacing = Math.ceil(spacing * factor) / factor;\r\n        }\r\n        niceMin = Math.floor(rmin / spacing) * spacing;\r\n        niceMax = Math.ceil(rmax / spacing) * spacing;\r\n        if (minDefined && maxDefined && step && almostWhole((max - min) / step, spacing / 1000)) {\r\n            numSpaces = Math.min((max - min) / spacing, maxTicks);\r\n            spacing = (max - min) / numSpaces;\r\n            niceMin = min;\r\n            niceMax = max;\r\n        } else if (countDefined) {\r\n            niceMin = minDefined ? min : niceMin;\r\n            niceMax = maxDefined ? max : niceMax;\r\n            numSpaces = count - 1;\r\n            spacing = (niceMax - niceMin) / numSpaces;\r\n        } else {\r\n            numSpaces = (niceMax - niceMin) / spacing;\r\n            if (almostEquals(numSpaces, Math.round(numSpaces), spacing / 1000)) {\r\n                numSpaces = Math.round(numSpaces);\r\n            } else {\r\n                numSpaces = Math.ceil(numSpaces);\r\n            }\r\n        }\r\n        factor = Math.pow(10, isNullOrUndef(precision) ? _decimalPlaces(spacing) : precision);\r\n        niceMin = Math.round(niceMin * factor) / factor;\r\n        niceMax = Math.round(niceMax * factor) / factor;\r\n        let j = 0;\r\n        if (minDefined) {\r\n            ticks.push({value: min});\r\n            if (niceMin < min) {\r\n                j++;\r\n            }\r\n            if (almostWhole(Math.round((niceMin + j * spacing) * factor) / factor / min, spacing / 1000)) {\r\n                j++;\r\n            }\r\n        }\r\n        for (; j < numSpaces; ++j) {\r\n            ticks.push({value: Math.round((niceMin + j * spacing) * factor) / factor});\r\n        }\r\n        if (maxDefined) {\r\n            if (almostWhole(ticks[ticks.length - 1].value / max, spacing / 1000)) {\r\n                ticks[ticks.length - 1].value = max;\r\n            } else {\r\n                ticks.push({value: max});\r\n            }\r\n        } else {\r\n            ticks.push({value: niceMax});\r\n        }\r\n        return ticks;\r\n    }\r\n\r\n    class LinearScaleBase extends Scale {\r\n        constructor(cfg) {\r\n            super(cfg);\r\n            this.start = undefined;\r\n            this.end = undefined;\r\n            this._startValue = undefined;\r\n            this._endValue = undefined;\r\n            this._valueRange = 0;\r\n        }\r\n\r\n        parse(raw, index) {\r\n            if (isNullOrUndef(raw)) {\r\n                return null;\r\n            }\r\n            if ((typeof raw === 'number' || raw instanceof Number) && !isFinite(+raw)) {\r\n                return null;\r\n            }\r\n            return +raw;\r\n        }\r\n\r\n        handleTickRangeOptions() {\r\n            const me = this;\r\n            const {beginAtZero, stacked} = me.options;\r\n            const {minDefined, maxDefined} = me.getUserBounds();\r\n            let {min, max} = me;\r\n            const setMin = v => (min = minDefined ? min : v);\r\n            const setMax = v => (max = maxDefined ? max : v);\r\n            if (beginAtZero || stacked) {\r\n                const minSign = sign(min);\r\n                const maxSign = sign(max);\r\n                if (minSign < 0 && maxSign < 0) {\r\n                    setMax(0);\r\n                } else if (minSign > 0 && maxSign > 0) {\r\n                    setMin(0);\r\n                }\r\n            }\r\n            if (min === max) {\r\n                setMax(max + 1);\r\n                if (!beginAtZero) {\r\n                    setMin(min - 1);\r\n                }\r\n            }\r\n            me.min = min;\r\n            me.max = max;\r\n        }\r\n\r\n        getTickLimit() {\r\n            const me = this;\r\n            const tickOpts = me.options.ticks;\r\n            let {maxTicksLimit, stepSize} = tickOpts;\r\n            let maxTicks;\r\n            if (stepSize) {\r\n                maxTicks = Math.ceil(me.max / stepSize) - Math.floor(me.min / stepSize) + 1;\r\n            } else {\r\n                maxTicks = me.computeTickLimit();\r\n                maxTicksLimit = maxTicksLimit || 11;\r\n            }\r\n            if (maxTicksLimit) {\r\n                maxTicks = Math.min(maxTicksLimit, maxTicks);\r\n            }\r\n            return maxTicks;\r\n        }\r\n\r\n        computeTickLimit() {\r\n            return Number.POSITIVE_INFINITY;\r\n        }\r\n\r\n        buildTicks() {\r\n            const me = this;\r\n            const opts = me.options;\r\n            const tickOpts = opts.ticks;\r\n            let maxTicks = me.getTickLimit();\r\n            maxTicks = Math.max(2, maxTicks);\r\n            const numericGeneratorOptions = {\r\n                maxTicks,\r\n                min: opts.min,\r\n                max: opts.max,\r\n                precision: tickOpts.precision,\r\n                step: tickOpts.stepSize,\r\n                count: tickOpts.count,\r\n            };\r\n            const ticks = generateTicks$1(numericGeneratorOptions, _addGrace(me, opts.grace));\r\n            if (opts.bounds === 'ticks') {\r\n                _setMinAndMaxByKey(ticks, me, 'value');\r\n            }\r\n            if (opts.reverse) {\r\n                ticks.reverse();\r\n                me.start = me.max;\r\n                me.end = me.min;\r\n            } else {\r\n                me.start = me.min;\r\n                me.end = me.max;\r\n            }\r\n            return ticks;\r\n        }\r\n\r\n        configure() {\r\n            const me = this;\r\n            const ticks = me.ticks;\r\n            let start = me.min;\r\n            let end = me.max;\r\n            super.configure();\r\n            if (me.options.offset && ticks.length) {\r\n                const offset = (end - start) / Math.max(ticks.length - 1, 1) / 2;\r\n                start -= offset;\r\n                end += offset;\r\n            }\r\n            me._startValue = start;\r\n            me._endValue = end;\r\n            me._valueRange = end - start;\r\n        }\r\n\r\n        getLabelForValue(value) {\r\n            return formatNumber(value, this.chart.options.locale);\r\n        }\r\n    }\r\n\r\n    class LinearScale extends LinearScaleBase {\r\n        determineDataLimits() {\r\n            const me = this;\r\n            const {min, max} = me.getMinMax(true);\r\n            me.min = isNumberFinite(min) ? min : 0;\r\n            me.max = isNumberFinite(max) ? max : 1;\r\n            me.handleTickRangeOptions();\r\n        }\r\n\r\n        computeTickLimit() {\r\n            const me = this;\r\n            if (me.isHorizontal()) {\r\n                return Math.ceil(me.width / 40);\r\n            }\r\n            const tickFont = me._resolveTickFontOptions(0);\r\n            return Math.ceil(me.height / tickFont.lineHeight);\r\n        }\r\n\r\n        getPixelForValue(value) {\r\n            return value === null ? NaN : this.getPixelForDecimal((value - this._startValue) / this._valueRange);\r\n        }\r\n\r\n        getValueForPixel(pixel) {\r\n            return this._startValue + this.getDecimalForPixel(pixel) * this._valueRange;\r\n        }\r\n    }\r\n\r\n    LinearScale.id = 'linear';\r\n    LinearScale.defaults = {\r\n        ticks: {\r\n            callback: Ticks.formatters.numeric\r\n        }\r\n    };\r\n\r\n    function isMajor(tickVal) {\r\n        const remain = tickVal / (Math.pow(10, Math.floor(log10(tickVal))));\r\n        return remain === 1;\r\n    }\r\n\r\n    function generateTicks(generationOptions, dataRange) {\r\n        const endExp = Math.floor(log10(dataRange.max));\r\n        const endSignificand = Math.ceil(dataRange.max / Math.pow(10, endExp));\r\n        const ticks = [];\r\n        let tickVal = finiteOrDefault(generationOptions.min, Math.pow(10, Math.floor(log10(dataRange.min))));\r\n        let exp = Math.floor(log10(tickVal));\r\n        let significand = Math.floor(tickVal / Math.pow(10, exp));\r\n        let precision = exp < 0 ? Math.pow(10, Math.abs(exp)) : 1;\r\n        do {\r\n            ticks.push({value: tickVal, major: isMajor(tickVal)});\r\n            ++significand;\r\n            if (significand === 10) {\r\n                significand = 1;\r\n                ++exp;\r\n                precision = exp >= 0 ? 1 : precision;\r\n            }\r\n            tickVal = Math.round(significand * Math.pow(10, exp) * precision) / precision;\r\n        } while (exp < endExp || (exp === endExp && significand < endSignificand));\r\n        const lastTick = finiteOrDefault(generationOptions.max, tickVal);\r\n        ticks.push({value: lastTick, major: isMajor(tickVal)});\r\n        return ticks;\r\n    }\r\n\r\n    class LogarithmicScale extends Scale {\r\n        constructor(cfg) {\r\n            super(cfg);\r\n            this.start = undefined;\r\n            this.end = undefined;\r\n            this._startValue = undefined;\r\n            this._valueRange = 0;\r\n        }\r\n\r\n        parse(raw, index) {\r\n            const value = LinearScaleBase.prototype.parse.apply(this, [raw, index]);\r\n            if (value === 0) {\r\n                this._zero = true;\r\n                return undefined;\r\n            }\r\n            return isNumberFinite(value) && value > 0 ? value : null;\r\n        }\r\n\r\n        determineDataLimits() {\r\n            const me = this;\r\n            const {min, max} = me.getMinMax(true);\r\n            me.min = isNumberFinite(min) ? Math.max(0, min) : null;\r\n            me.max = isNumberFinite(max) ? Math.max(0, max) : null;\r\n            if (me.options.beginAtZero) {\r\n                me._zero = true;\r\n            }\r\n            me.handleTickRangeOptions();\r\n        }\r\n\r\n        handleTickRangeOptions() {\r\n            const me = this;\r\n            const {minDefined, maxDefined} = me.getUserBounds();\r\n            let min = me.min;\r\n            let max = me.max;\r\n            const setMin = v => (min = minDefined ? min : v);\r\n            const setMax = v => (max = maxDefined ? max : v);\r\n            const exp = (v, m) => Math.pow(10, Math.floor(log10(v)) + m);\r\n            if (min === max) {\r\n                if (min <= 0) {\r\n                    setMin(1);\r\n                    setMax(10);\r\n                } else {\r\n                    setMin(exp(min, -1));\r\n                    setMax(exp(max, +1));\r\n                }\r\n            }\r\n            if (min <= 0) {\r\n                setMin(exp(max, -1));\r\n            }\r\n            if (max <= 0) {\r\n                setMax(exp(min, +1));\r\n            }\r\n            if (me._zero && me.min !== me._suggestedMin && min === exp(me.min, 0)) {\r\n                setMin(exp(min, -1));\r\n            }\r\n            me.min = min;\r\n            me.max = max;\r\n        }\r\n\r\n        buildTicks() {\r\n            const me = this;\r\n            const opts = me.options;\r\n            const generationOptions = {\r\n                min: me._userMin,\r\n                max: me._userMax\r\n            };\r\n            const ticks = generateTicks(generationOptions, me);\r\n            if (opts.bounds === 'ticks') {\r\n                _setMinAndMaxByKey(ticks, me, 'value');\r\n            }\r\n            if (opts.reverse) {\r\n                ticks.reverse();\r\n                me.start = me.max;\r\n                me.end = me.min;\r\n            } else {\r\n                me.start = me.min;\r\n                me.end = me.max;\r\n            }\r\n            return ticks;\r\n        }\r\n\r\n        getLabelForValue(value) {\r\n            return value === undefined ? '0' : formatNumber(value, this.chart.options.locale);\r\n        }\r\n\r\n        configure() {\r\n            const me = this;\r\n            const start = me.min;\r\n            super.configure();\r\n            me._startValue = log10(start);\r\n            me._valueRange = log10(me.max) - log10(start);\r\n        }\r\n\r\n        getPixelForValue(value) {\r\n            const me = this;\r\n            if (value === undefined || value === 0) {\r\n                value = me.min;\r\n            }\r\n            return me.getPixelForDecimal(value === me.min\r\n                ? 0\r\n                : (log10(value) - me._startValue) / me._valueRange);\r\n        }\r\n\r\n        getValueForPixel(pixel) {\r\n            const me = this;\r\n            const decimal = me.getDecimalForPixel(pixel);\r\n            return Math.pow(10, me._startValue + decimal * me._valueRange);\r\n        }\r\n    }\r\n\r\n    LogarithmicScale.id = 'logarithmic';\r\n    LogarithmicScale.defaults = {\r\n        ticks: {\r\n            callback: Ticks.formatters.logarithmic,\r\n            major: {\r\n                enabled: true\r\n            }\r\n        }\r\n    };\r\n\r\n    function getTickBackdropHeight(opts) {\r\n        const tickOpts = opts.ticks;\r\n        if (tickOpts.display && opts.display) {\r\n            const padding = toPadding(tickOpts.backdropPadding);\r\n            return valueOrDefault(tickOpts.font && tickOpts.font.size, defaults.font.size) + padding.height;\r\n        }\r\n        return 0;\r\n    }\r\n\r\n    function measureLabelSize(ctx, lineHeight, label) {\r\n        if (isArray(label)) {\r\n            return {\r\n                w: _longestText(ctx, ctx.font, label),\r\n                h: label.length * lineHeight\r\n            };\r\n        }\r\n        return {\r\n            w: ctx.measureText(label).width,\r\n            h: lineHeight\r\n        };\r\n    }\r\n\r\n    function determineLimits(angle, pos, size, min, max) {\r\n        if (angle === min || angle === max) {\r\n            return {\r\n                start: pos - (size / 2),\r\n                end: pos + (size / 2)\r\n            };\r\n        } else if (angle < min || angle > max) {\r\n            return {\r\n                start: pos - size,\r\n                end: pos\r\n            };\r\n        }\r\n        return {\r\n            start: pos,\r\n            end: pos + size\r\n        };\r\n    }\r\n\r\n    function fitWithPointLabels(scale) {\r\n        const furthestLimits = {\r\n            l: 0,\r\n            r: scale.width,\r\n            t: 0,\r\n            b: scale.height - scale.paddingTop\r\n        };\r\n        const furthestAngles = {};\r\n        let i, textSize, pointPosition;\r\n        const labelSizes = [];\r\n        const padding = [];\r\n        const valueCount = scale.getLabels().length;\r\n        for (i = 0; i < valueCount; i++) {\r\n            const opts = scale.options.pointLabels.setContext(scale.getContext(i));\r\n            padding[i] = opts.padding;\r\n            pointPosition = scale.getPointPosition(i, scale.drawingArea + padding[i]);\r\n            const plFont = toFont(opts.font);\r\n            scale.ctx.font = plFont.string;\r\n            textSize = measureLabelSize(scale.ctx, plFont.lineHeight, scale._pointLabels[i]);\r\n            labelSizes[i] = textSize;\r\n            const angleRadians = scale.getIndexAngle(i);\r\n            const angle = toDegrees(angleRadians);\r\n            const hLimits = determineLimits(angle, pointPosition.x, textSize.w, 0, 180);\r\n            const vLimits = determineLimits(angle, pointPosition.y, textSize.h, 90, 270);\r\n            if (hLimits.start < furthestLimits.l) {\r\n                furthestLimits.l = hLimits.start;\r\n                furthestAngles.l = angleRadians;\r\n            }\r\n            if (hLimits.end > furthestLimits.r) {\r\n                furthestLimits.r = hLimits.end;\r\n                furthestAngles.r = angleRadians;\r\n            }\r\n            if (vLimits.start < furthestLimits.t) {\r\n                furthestLimits.t = vLimits.start;\r\n                furthestAngles.t = angleRadians;\r\n            }\r\n            if (vLimits.end > furthestLimits.b) {\r\n                furthestLimits.b = vLimits.end;\r\n                furthestAngles.b = angleRadians;\r\n            }\r\n        }\r\n        scale._setReductions(scale.drawingArea, furthestLimits, furthestAngles);\r\n        scale._pointLabelItems = [];\r\n        const opts = scale.options;\r\n        const tickBackdropHeight = getTickBackdropHeight(opts);\r\n        const outerDistance = scale.getDistanceFromCenterForValue(opts.ticks.reverse ? scale.min : scale.max);\r\n        for (i = 0; i < valueCount; i++) {\r\n            const extra = (i === 0 ? tickBackdropHeight / 2 : 0);\r\n            const pointLabelPosition = scale.getPointPosition(i, outerDistance + extra + padding[i]);\r\n            const angle = toDegrees(scale.getIndexAngle(i));\r\n            const size = labelSizes[i];\r\n            adjustPointPositionForLabelHeight(angle, size, pointLabelPosition);\r\n            const textAlign = getTextAlignForAngle(angle);\r\n            let left;\r\n            if (textAlign === 'left') {\r\n                left = pointLabelPosition.x;\r\n            } else if (textAlign === 'center') {\r\n                left = pointLabelPosition.x - (size.w / 2);\r\n            } else {\r\n                left = pointLabelPosition.x - size.w;\r\n            }\r\n            const right = left + size.w;\r\n            scale._pointLabelItems[i] = {\r\n                x: pointLabelPosition.x,\r\n                y: pointLabelPosition.y,\r\n                textAlign,\r\n                left,\r\n                top: pointLabelPosition.y,\r\n                right,\r\n                bottom: pointLabelPosition.y + size.h,\r\n            };\r\n        }\r\n    }\r\n\r\n    function getTextAlignForAngle(angle) {\r\n        if (angle === 0 || angle === 180) {\r\n            return 'center';\r\n        } else if (angle < 180) {\r\n            return 'left';\r\n        }\r\n        return 'right';\r\n    }\r\n\r\n    function adjustPointPositionForLabelHeight(angle, textSize, position) {\r\n        if (angle === 90 || angle === 270) {\r\n            position.y -= (textSize.h / 2);\r\n        } else if (angle > 270 || angle < 90) {\r\n            position.y -= textSize.h;\r\n        }\r\n    }\r\n\r\n    function drawPointLabels(scale, labelCount) {\r\n        const {ctx, options: {pointLabels}} = scale;\r\n        for (let i = labelCount - 1; i >= 0; i--) {\r\n            const optsAtIndex = pointLabels.setContext(scale.getContext(i));\r\n            const plFont = toFont(optsAtIndex.font);\r\n            const {x, y, textAlign, left, top, right, bottom} = scale._pointLabelItems[i];\r\n            const {backdropColor} = optsAtIndex;\r\n            if (!isNullOrUndef(backdropColor)) {\r\n                const padding = toPadding(optsAtIndex.backdropPadding);\r\n                ctx.fillStyle = backdropColor;\r\n                ctx.fillRect(left - padding.left, top - padding.top, right - left + padding.width, bottom - top + padding.height);\r\n            }\r\n            renderText(\r\n                ctx,\r\n                scale._pointLabels[i],\r\n                x,\r\n                y + (plFont.lineHeight / 2),\r\n                plFont,\r\n                {\r\n                    color: optsAtIndex.color,\r\n                    textAlign: textAlign,\r\n                    textBaseline: 'middle'\r\n                }\r\n            );\r\n        }\r\n    }\r\n\r\n    function pathRadiusLine(scale, radius, circular, labelCount) {\r\n        const {ctx} = scale;\r\n        if (circular) {\r\n            ctx.arc(scale.xCenter, scale.yCenter, radius, 0, TAU);\r\n        } else {\r\n            let pointPosition = scale.getPointPosition(0, radius);\r\n            ctx.moveTo(pointPosition.x, pointPosition.y);\r\n            for (let i = 1; i < labelCount; i++) {\r\n                pointPosition = scale.getPointPosition(i, radius);\r\n                ctx.lineTo(pointPosition.x, pointPosition.y);\r\n            }\r\n        }\r\n    }\r\n\r\n    function drawRadiusLine(scale, gridLineOpts, radius, labelCount) {\r\n        const ctx = scale.ctx;\r\n        const circular = gridLineOpts.circular;\r\n        const {color, lineWidth} = gridLineOpts;\r\n        if ((!circular && !labelCount) || !color || !lineWidth || radius < 0) {\r\n            return;\r\n        }\r\n        ctx.save();\r\n        ctx.strokeStyle = color;\r\n        ctx.lineWidth = lineWidth;\r\n        ctx.setLineDash(gridLineOpts.borderDash);\r\n        ctx.lineDashOffset = gridLineOpts.borderDashOffset;\r\n        ctx.beginPath();\r\n        pathRadiusLine(scale, radius, circular, labelCount);\r\n        ctx.closePath();\r\n        ctx.stroke();\r\n        ctx.restore();\r\n    }\r\n\r\n    function numberOrZero(param) {\r\n        return isNumber(param) ? param : 0;\r\n    }\r\n\r\n    class RadialLinearScale extends LinearScaleBase {\r\n        constructor(cfg) {\r\n            super(cfg);\r\n            this.xCenter = undefined;\r\n            this.yCenter = undefined;\r\n            this.drawingArea = undefined;\r\n            this._pointLabels = [];\r\n            this._pointLabelItems = [];\r\n        }\r\n\r\n        setDimensions() {\r\n            const me = this;\r\n            me.width = me.maxWidth;\r\n            me.height = me.maxHeight;\r\n            me.paddingTop = getTickBackdropHeight(me.options) / 2;\r\n            me.xCenter = Math.floor(me.width / 2);\r\n            me.yCenter = Math.floor((me.height - me.paddingTop) / 2);\r\n            me.drawingArea = Math.min(me.height - me.paddingTop, me.width) / 2;\r\n        }\r\n\r\n        determineDataLimits() {\r\n            const me = this;\r\n            const {min, max} = me.getMinMax(false);\r\n            me.min = isNumberFinite(min) && !isNaN(min) ? min : 0;\r\n            me.max = isNumberFinite(max) && !isNaN(max) ? max : 0;\r\n            me.handleTickRangeOptions();\r\n        }\r\n\r\n        computeTickLimit() {\r\n            return Math.ceil(this.drawingArea / getTickBackdropHeight(this.options));\r\n        }\r\n\r\n        generateTickLabels(ticks) {\r\n            const me = this;\r\n            LinearScaleBase.prototype.generateTickLabels.call(me, ticks);\r\n            me._pointLabels = me.getLabels().map((value, index) => {\r\n                const label = callback(me.options.pointLabels.callback, [value, index], me);\r\n                return label || label === 0 ? label : '';\r\n            });\r\n        }\r\n\r\n        fit() {\r\n            const me = this;\r\n            const opts = me.options;\r\n            if (opts.display && opts.pointLabels.display) {\r\n                fitWithPointLabels(me);\r\n            } else {\r\n                me.setCenterPoint(0, 0, 0, 0);\r\n            }\r\n        }\r\n\r\n        _setReductions(largestPossibleRadius, furthestLimits, furthestAngles) {\r\n            const me = this;\r\n            let radiusReductionLeft = furthestLimits.l / Math.sin(furthestAngles.l);\r\n            let radiusReductionRight = Math.max(furthestLimits.r - me.width, 0) / Math.sin(furthestAngles.r);\r\n            let radiusReductionTop = -furthestLimits.t / Math.cos(furthestAngles.t);\r\n            let radiusReductionBottom = -Math.max(furthestLimits.b - (me.height - me.paddingTop), 0) / Math.cos(furthestAngles.b);\r\n            radiusReductionLeft = numberOrZero(radiusReductionLeft);\r\n            radiusReductionRight = numberOrZero(radiusReductionRight);\r\n            radiusReductionTop = numberOrZero(radiusReductionTop);\r\n            radiusReductionBottom = numberOrZero(radiusReductionBottom);\r\n            me.drawingArea = Math.max(largestPossibleRadius / 2, Math.min(\r\n                Math.floor(largestPossibleRadius - (radiusReductionLeft + radiusReductionRight) / 2),\r\n                Math.floor(largestPossibleRadius - (radiusReductionTop + radiusReductionBottom) / 2)));\r\n            me.setCenterPoint(radiusReductionLeft, radiusReductionRight, radiusReductionTop, radiusReductionBottom);\r\n        }\r\n\r\n        setCenterPoint(leftMovement, rightMovement, topMovement, bottomMovement) {\r\n            const me = this;\r\n            const maxRight = me.width - rightMovement - me.drawingArea;\r\n            const maxLeft = leftMovement + me.drawingArea;\r\n            const maxTop = topMovement + me.drawingArea;\r\n            const maxBottom = (me.height - me.paddingTop) - bottomMovement - me.drawingArea;\r\n            me.xCenter = Math.floor(((maxLeft + maxRight) / 2) + me.left);\r\n            me.yCenter = Math.floor(((maxTop + maxBottom) / 2) + me.top + me.paddingTop);\r\n        }\r\n\r\n        getIndexAngle(index) {\r\n            const angleMultiplier = TAU / this.getLabels().length;\r\n            const startAngle = this.options.startAngle || 0;\r\n            return _normalizeAngle(index * angleMultiplier + toRadians(startAngle));\r\n        }\r\n\r\n        getDistanceFromCenterForValue(value) {\r\n            const me = this;\r\n            if (isNullOrUndef(value)) {\r\n                return NaN;\r\n            }\r\n            const scalingFactor = me.drawingArea / (me.max - me.min);\r\n            if (me.options.reverse) {\r\n                return (me.max - value) * scalingFactor;\r\n            }\r\n            return (value - me.min) * scalingFactor;\r\n        }\r\n\r\n        getValueForDistanceFromCenter(distance) {\r\n            if (isNullOrUndef(distance)) {\r\n                return NaN;\r\n            }\r\n            const me = this;\r\n            const scaledDistance = distance / (me.drawingArea / (me.max - me.min));\r\n            return me.options.reverse ? me.max - scaledDistance : me.min + scaledDistance;\r\n        }\r\n\r\n        getPointPosition(index, distanceFromCenter) {\r\n            const me = this;\r\n            const angle = me.getIndexAngle(index) - HALF_PI;\r\n            return {\r\n                x: Math.cos(angle) * distanceFromCenter + me.xCenter,\r\n                y: Math.sin(angle) * distanceFromCenter + me.yCenter,\r\n                angle\r\n            };\r\n        }\r\n\r\n        getPointPositionForValue(index, value) {\r\n            return this.getPointPosition(index, this.getDistanceFromCenterForValue(value));\r\n        }\r\n\r\n        getBasePosition(index) {\r\n            return this.getPointPositionForValue(index || 0, this.getBaseValue());\r\n        }\r\n\r\n        getPointLabelPosition(index) {\r\n            const {left, top, right, bottom} = this._pointLabelItems[index];\r\n            return {\r\n                left,\r\n                top,\r\n                right,\r\n                bottom,\r\n            };\r\n        }\r\n\r\n        drawBackground() {\r\n            const me = this;\r\n            const {backgroundColor, grid: {circular}} = me.options;\r\n            if (backgroundColor) {\r\n                const ctx = me.ctx;\r\n                ctx.save();\r\n                ctx.beginPath();\r\n                pathRadiusLine(me, me.getDistanceFromCenterForValue(me._endValue), circular, me.getLabels().length);\r\n                ctx.closePath();\r\n                ctx.fillStyle = backgroundColor;\r\n                ctx.fill();\r\n                ctx.restore();\r\n            }\r\n        }\r\n\r\n        drawGrid() {\r\n            const me = this;\r\n            const ctx = me.ctx;\r\n            const opts = me.options;\r\n            const {angleLines, grid} = opts;\r\n            const labelCount = me.getLabels().length;\r\n            let i, offset, position;\r\n            if (opts.pointLabels.display) {\r\n                drawPointLabels(me, labelCount);\r\n            }\r\n            if (grid.display) {\r\n                me.ticks.forEach((tick, index) => {\r\n                    if (index !== 0) {\r\n                        offset = me.getDistanceFromCenterForValue(tick.value);\r\n                        const optsAtIndex = grid.setContext(me.getContext(index - 1));\r\n                        drawRadiusLine(me, optsAtIndex, offset, labelCount);\r\n                    }\r\n                });\r\n            }\r\n            if (angleLines.display) {\r\n                ctx.save();\r\n                for (i = me.getLabels().length - 1; i >= 0; i--) {\r\n                    const optsAtIndex = angleLines.setContext(me.getContext(i));\r\n                    const {color, lineWidth} = optsAtIndex;\r\n                    if (!lineWidth || !color) {\r\n                        continue;\r\n                    }\r\n                    ctx.lineWidth = lineWidth;\r\n                    ctx.strokeStyle = color;\r\n                    ctx.setLineDash(optsAtIndex.borderDash);\r\n                    ctx.lineDashOffset = optsAtIndex.borderDashOffset;\r\n                    offset = me.getDistanceFromCenterForValue(opts.ticks.reverse ? me.min : me.max);\r\n                    position = me.getPointPosition(i, offset);\r\n                    ctx.beginPath();\r\n                    ctx.moveTo(me.xCenter, me.yCenter);\r\n                    ctx.lineTo(position.x, position.y);\r\n                    ctx.stroke();\r\n                }\r\n                ctx.restore();\r\n            }\r\n        }\r\n\r\n        drawLabels() {\r\n            const me = this;\r\n            const ctx = me.ctx;\r\n            const opts = me.options;\r\n            const tickOpts = opts.ticks;\r\n            if (!tickOpts.display) {\r\n                return;\r\n            }\r\n            const startAngle = me.getIndexAngle(0);\r\n            let offset, width;\r\n            ctx.save();\r\n            ctx.translate(me.xCenter, me.yCenter);\r\n            ctx.rotate(startAngle);\r\n            ctx.textAlign = 'center';\r\n            ctx.textBaseline = 'middle';\r\n            me.ticks.forEach((tick, index) => {\r\n                if (index === 0 && !opts.reverse) {\r\n                    return;\r\n                }\r\n                const optsAtIndex = tickOpts.setContext(me.getContext(index));\r\n                const tickFont = toFont(optsAtIndex.font);\r\n                offset = me.getDistanceFromCenterForValue(me.ticks[index].value);\r\n                if (optsAtIndex.showLabelBackdrop) {\r\n                    width = ctx.measureText(tick.label).width;\r\n                    ctx.fillStyle = optsAtIndex.backdropColor;\r\n                    const padding = toPadding(optsAtIndex.backdropPadding);\r\n                    ctx.fillRect(\r\n                        -width / 2 - padding.left,\r\n                        -offset - tickFont.size / 2 - padding.top,\r\n                        width + padding.width,\r\n                        tickFont.size + padding.height\r\n                    );\r\n                }\r\n                renderText(ctx, tick.label, 0, -offset, tickFont, {\r\n                    color: optsAtIndex.color,\r\n                });\r\n            });\r\n            ctx.restore();\r\n        }\r\n\r\n        drawTitle() {\r\n        }\r\n    }\r\n\r\n    RadialLinearScale.id = 'radialLinear';\r\n    RadialLinearScale.defaults = {\r\n        display: true,\r\n        animate: true,\r\n        position: 'chartArea',\r\n        angleLines: {\r\n            display: true,\r\n            lineWidth: 1,\r\n            borderDash: [],\r\n            borderDashOffset: 0.0\r\n        },\r\n        grid: {\r\n            circular: false\r\n        },\r\n        startAngle: 0,\r\n        ticks: {\r\n            showLabelBackdrop: true,\r\n            backdropColor: 'rgba(255,255,255,0.75)',\r\n            backdropPadding: 2,\r\n            callback: Ticks.formatters.numeric\r\n        },\r\n        pointLabels: {\r\n            backdropColor: undefined,\r\n            backdropPadding: 2,\r\n            display: true,\r\n            font: {\r\n                size: 10\r\n            },\r\n            callback(label) {\r\n                return label;\r\n            },\r\n            padding: 5\r\n        }\r\n    };\r\n    RadialLinearScale.defaultRoutes = {\r\n        'angleLines.color': 'borderColor',\r\n        'pointLabels.color': 'color',\r\n        'ticks.color': 'color'\r\n    };\r\n    RadialLinearScale.descriptors = {\r\n        angleLines: {\r\n            _fallback: 'grid'\r\n        }\r\n    };\r\n\r\n    const INTERVALS = {\r\n        millisecond: {common: true, size: 1, steps: 1000},\r\n        second: {common: true, size: 1000, steps: 60},\r\n        minute: {common: true, size: 60000, steps: 60},\r\n        hour: {common: true, size: 3600000, steps: 24},\r\n        day: {common: true, size: 86400000, steps: 30},\r\n        week: {common: false, size: 604800000, steps: 4},\r\n        month: {common: true, size: 2.628e9, steps: 12},\r\n        quarter: {common: false, size: 7.884e9, steps: 4},\r\n        year: {common: true, size: 3.154e10}\r\n    };\r\n    const UNITS = (Object.keys(INTERVALS));\r\n\r\n    function sorter(a, b) {\r\n        return a - b;\r\n    }\r\n\r\n    function parse(scale, input) {\r\n        if (isNullOrUndef(input)) {\r\n            return null;\r\n        }\r\n        const adapter = scale._adapter;\r\n        const options = scale.options.time;\r\n        const {parser, round, isoWeekday} = options;\r\n        let value = input;\r\n        if (typeof parser === 'function') {\r\n            value = parser(value);\r\n        }\r\n        if (!isNumberFinite(value)) {\r\n            value = typeof parser === 'string'\r\n                ? adapter.parse(value, parser)\r\n                : adapter.parse(value);\r\n        }\r\n        if (value === null) {\r\n            return null;\r\n        }\r\n        if (round) {\r\n            value = round === 'week' && (isNumber(isoWeekday) || isoWeekday === true)\r\n                ? adapter.startOf(value, 'isoWeek', isoWeekday)\r\n                : adapter.startOf(value, round);\r\n        }\r\n        return +value;\r\n    }\r\n\r\n    function determineUnitForAutoTicks(minUnit, min, max, capacity) {\r\n        const ilen = UNITS.length;\r\n        for (let i = UNITS.indexOf(minUnit); i < ilen - 1; ++i) {\r\n            const interval = INTERVALS[UNITS[i]];\r\n            const factor = interval.steps ? interval.steps : Number.MAX_SAFE_INTEGER;\r\n            if (interval.common && Math.ceil((max - min) / (factor * interval.size)) <= capacity) {\r\n                return UNITS[i];\r\n            }\r\n        }\r\n        return UNITS[ilen - 1];\r\n    }\r\n\r\n    function determineUnitForFormatting(scale, numTicks, minUnit, min, max) {\r\n        for (let i = UNITS.length - 1; i >= UNITS.indexOf(minUnit); i--) {\r\n            const unit = UNITS[i];\r\n            if (INTERVALS[unit].common && scale._adapter.diff(max, min, unit) >= numTicks - 1) {\r\n                return unit;\r\n            }\r\n        }\r\n        return UNITS[minUnit ? UNITS.indexOf(minUnit) : 0];\r\n    }\r\n\r\n    function determineMajorUnit(unit) {\r\n        for (let i = UNITS.indexOf(unit) + 1, ilen = UNITS.length; i < ilen; ++i) {\r\n            if (INTERVALS[UNITS[i]].common) {\r\n                return UNITS[i];\r\n            }\r\n        }\r\n    }\r\n\r\n    function addTick(ticks, time, timestamps) {\r\n        if (!timestamps) {\r\n            ticks[time] = true;\r\n        } else if (timestamps.length) {\r\n            const {lo, hi} = _lookup(timestamps, time);\r\n            const timestamp = timestamps[lo] >= time ? timestamps[lo] : timestamps[hi];\r\n            ticks[timestamp] = true;\r\n        }\r\n    }\r\n\r\n    function setMajorTicks(scale, ticks, map, majorUnit) {\r\n        const adapter = scale._adapter;\r\n        const first = +adapter.startOf(ticks[0].value, majorUnit);\r\n        const last = ticks[ticks.length - 1].value;\r\n        let major, index;\r\n        for (major = first; major <= last; major = +adapter.add(major, 1, majorUnit)) {\r\n            index = map[major];\r\n            if (index >= 0) {\r\n                ticks[index].major = true;\r\n            }\r\n        }\r\n        return ticks;\r\n    }\r\n\r\n    function ticksFromTimestamps(scale, values, majorUnit) {\r\n        const ticks = [];\r\n        const map = {};\r\n        const ilen = values.length;\r\n        let i, value;\r\n        for (i = 0; i < ilen; ++i) {\r\n            value = values[i];\r\n            map[value] = i;\r\n            ticks.push({\r\n                value,\r\n                major: false\r\n            });\r\n        }\r\n        return (ilen === 0 || !majorUnit) ? ticks : setMajorTicks(scale, ticks, map, majorUnit);\r\n    }\r\n\r\n    class TimeScale extends Scale {\r\n        constructor(props) {\r\n            super(props);\r\n            this._cache = {\r\n                data: [],\r\n                labels: [],\r\n                all: []\r\n            };\r\n            this._unit = 'day';\r\n            this._majorUnit = undefined;\r\n            this._offsets = {};\r\n            this._normalized = false;\r\n        }\r\n\r\n        init(scaleOpts, opts) {\r\n            const time = scaleOpts.time || (scaleOpts.time = {});\r\n            const adapter = this._adapter = new _adapters._date(scaleOpts.adapters.date);\r\n            mergeIf(time.displayFormats, adapter.formats());\r\n            super.init(scaleOpts);\r\n            this._normalized = opts.normalized;\r\n        }\r\n\r\n        parse(raw, index) {\r\n            if (raw === undefined) {\r\n                return null;\r\n            }\r\n            return parse(this, raw);\r\n        }\r\n\r\n        beforeLayout() {\r\n            super.beforeLayout();\r\n            this._cache = {\r\n                data: [],\r\n                labels: [],\r\n                all: []\r\n            };\r\n        }\r\n\r\n        determineDataLimits() {\r\n            const me = this;\r\n            const options = me.options;\r\n            const adapter = me._adapter;\r\n            const unit = options.time.unit || 'day';\r\n            let {min, max, minDefined, maxDefined} = me.getUserBounds();\r\n\r\n            function _applyBounds(bounds) {\r\n                if (!minDefined && !isNaN(bounds.min)) {\r\n                    min = Math.min(min, bounds.min);\r\n                }\r\n                if (!maxDefined && !isNaN(bounds.max)) {\r\n                    max = Math.max(max, bounds.max);\r\n                }\r\n            }\r\n\r\n            if (!minDefined || !maxDefined) {\r\n                _applyBounds(me._getLabelBounds());\r\n                if (options.bounds !== 'ticks' || options.ticks.source !== 'labels') {\r\n                    _applyBounds(me.getMinMax(false));\r\n                }\r\n            }\r\n            min = isNumberFinite(min) && !isNaN(min) ? min : +adapter.startOf(Date.now(), unit);\r\n            max = isNumberFinite(max) && !isNaN(max) ? max : +adapter.endOf(Date.now(), unit) + 1;\r\n            me.min = Math.min(min, max - 1);\r\n            me.max = Math.max(min + 1, max);\r\n        }\r\n\r\n        _getLabelBounds() {\r\n            const arr = this.getLabelTimestamps();\r\n            let min = Number.POSITIVE_INFINITY;\r\n            let max = Number.NEGATIVE_INFINITY;\r\n            if (arr.length) {\r\n                min = arr[0];\r\n                max = arr[arr.length - 1];\r\n            }\r\n            return {min, max};\r\n        }\r\n\r\n        buildTicks() {\r\n            const me = this;\r\n            const options = me.options;\r\n            const timeOpts = options.time;\r\n            const tickOpts = options.ticks;\r\n            const timestamps = tickOpts.source === 'labels' ? me.getLabelTimestamps() : me._generate();\r\n            if (options.bounds === 'ticks' && timestamps.length) {\r\n                me.min = me._userMin || timestamps[0];\r\n                me.max = me._userMax || timestamps[timestamps.length - 1];\r\n            }\r\n            const min = me.min;\r\n            const max = me.max;\r\n            const ticks = _filterBetween(timestamps, min, max);\r\n            me._unit = timeOpts.unit || (tickOpts.autoSkip\r\n                ? determineUnitForAutoTicks(timeOpts.minUnit, me.min, me.max, me._getLabelCapacity(min))\r\n                : determineUnitForFormatting(me, ticks.length, timeOpts.minUnit, me.min, me.max));\r\n            me._majorUnit = !tickOpts.major.enabled || me._unit === 'year' ? undefined\r\n                : determineMajorUnit(me._unit);\r\n            me.initOffsets(timestamps);\r\n            if (options.reverse) {\r\n                ticks.reverse();\r\n            }\r\n            return ticksFromTimestamps(me, ticks, me._majorUnit);\r\n        }\r\n\r\n        initOffsets(timestamps) {\r\n            const me = this;\r\n            let start = 0;\r\n            let end = 0;\r\n            let first, last;\r\n            if (me.options.offset && timestamps.length) {\r\n                first = me.getDecimalForValue(timestamps[0]);\r\n                if (timestamps.length === 1) {\r\n                    start = 1 - first;\r\n                } else {\r\n                    start = (me.getDecimalForValue(timestamps[1]) - first) / 2;\r\n                }\r\n                last = me.getDecimalForValue(timestamps[timestamps.length - 1]);\r\n                if (timestamps.length === 1) {\r\n                    end = last;\r\n                } else {\r\n                    end = (last - me.getDecimalForValue(timestamps[timestamps.length - 2])) / 2;\r\n                }\r\n            }\r\n            const limit = timestamps.length < 3 ? 0.5 : 0.25;\r\n            start = _limitValue(start, 0, limit);\r\n            end = _limitValue(end, 0, limit);\r\n            me._offsets = {start, end, factor: 1 / (start + 1 + end)};\r\n        }\r\n\r\n        _generate() {\r\n            const me = this;\r\n            const adapter = me._adapter;\r\n            const min = me.min;\r\n            const max = me.max;\r\n            const options = me.options;\r\n            const timeOpts = options.time;\r\n            const minor = timeOpts.unit || determineUnitForAutoTicks(timeOpts.minUnit, min, max, me._getLabelCapacity(min));\r\n            const stepSize = valueOrDefault(timeOpts.stepSize, 1);\r\n            const weekday = minor === 'week' ? timeOpts.isoWeekday : false;\r\n            const hasWeekday = isNumber(weekday) || weekday === true;\r\n            const ticks = {};\r\n            let first = min;\r\n            let time, count;\r\n            if (hasWeekday) {\r\n                first = +adapter.startOf(first, 'isoWeek', weekday);\r\n            }\r\n            first = +adapter.startOf(first, hasWeekday ? 'day' : minor);\r\n            if (adapter.diff(max, min, minor) > 100000 * stepSize) {\r\n                throw new Error(min + ' and ' + max + ' are too far apart with stepSize of ' + stepSize + ' ' + minor);\r\n            }\r\n            const timestamps = options.ticks.source === 'data' && me.getDataTimestamps();\r\n            for (time = first, count = 0; time < max; time = +adapter.add(time, stepSize, minor), count++) {\r\n                addTick(ticks, time, timestamps);\r\n            }\r\n            if (time === max || options.bounds === 'ticks' || count === 1) {\r\n                addTick(ticks, time, timestamps);\r\n            }\r\n            return Object.keys(ticks).sort((a, b) => a - b).map(x => +x);\r\n        }\r\n\r\n        getLabelForValue(value) {\r\n            const me = this;\r\n            const adapter = me._adapter;\r\n            const timeOpts = me.options.time;\r\n            if (timeOpts.tooltipFormat) {\r\n                return adapter.format(value, timeOpts.tooltipFormat);\r\n            }\r\n            return adapter.format(value, timeOpts.displayFormats.datetime);\r\n        }\r\n\r\n        _tickFormatFunction(time, index, ticks, format) {\r\n            const me = this;\r\n            const options = me.options;\r\n            const formats = options.time.displayFormats;\r\n            const unit = me._unit;\r\n            const majorUnit = me._majorUnit;\r\n            const minorFormat = unit && formats[unit];\r\n            const majorFormat = majorUnit && formats[majorUnit];\r\n            const tick = ticks[index];\r\n            const major = majorUnit && majorFormat && tick && tick.major;\r\n            const label = me._adapter.format(time, format || (major ? majorFormat : minorFormat));\r\n            const formatter = options.ticks.callback;\r\n            return formatter ? formatter(label, index, ticks) : label;\r\n        }\r\n\r\n        generateTickLabels(ticks) {\r\n            let i, ilen, tick;\r\n            for (i = 0, ilen = ticks.length; i < ilen; ++i) {\r\n                tick = ticks[i];\r\n                tick.label = this._tickFormatFunction(tick.value, i, ticks);\r\n            }\r\n        }\r\n\r\n        getDecimalForValue(value) {\r\n            const me = this;\r\n            return value === null ? NaN : (value - me.min) / (me.max - me.min);\r\n        }\r\n\r\n        getPixelForValue(value) {\r\n            const me = this;\r\n            const offsets = me._offsets;\r\n            const pos = me.getDecimalForValue(value);\r\n            return me.getPixelForDecimal((offsets.start + pos) * offsets.factor);\r\n        }\r\n\r\n        getValueForPixel(pixel) {\r\n            const me = this;\r\n            const offsets = me._offsets;\r\n            const pos = me.getDecimalForPixel(pixel) / offsets.factor - offsets.end;\r\n            return me.min + pos * (me.max - me.min);\r\n        }\r\n\r\n        _getLabelSize(label) {\r\n            const me = this;\r\n            const ticksOpts = me.options.ticks;\r\n            const tickLabelWidth = me.ctx.measureText(label).width;\r\n            const angle = toRadians(me.isHorizontal() ? ticksOpts.maxRotation : ticksOpts.minRotation);\r\n            const cosRotation = Math.cos(angle);\r\n            const sinRotation = Math.sin(angle);\r\n            const tickFontSize = me._resolveTickFontOptions(0).size;\r\n            return {\r\n                w: (tickLabelWidth * cosRotation) + (tickFontSize * sinRotation),\r\n                h: (tickLabelWidth * sinRotation) + (tickFontSize * cosRotation)\r\n            };\r\n        }\r\n\r\n        _getLabelCapacity(exampleTime) {\r\n            const me = this;\r\n            const timeOpts = me.options.time;\r\n            const displayFormats = timeOpts.displayFormats;\r\n            const format = displayFormats[timeOpts.unit] || displayFormats.millisecond;\r\n            const exampleLabel = me._tickFormatFunction(exampleTime, 0, ticksFromTimestamps(me, [exampleTime], me._majorUnit), format);\r\n            const size = me._getLabelSize(exampleLabel);\r\n            const capacity = Math.floor(me.isHorizontal() ? me.width / size.w : me.height / size.h) - 1;\r\n            return capacity > 0 ? capacity : 1;\r\n        }\r\n\r\n        getDataTimestamps() {\r\n            const me = this;\r\n            let timestamps = me._cache.data || [];\r\n            let i, ilen;\r\n            if (timestamps.length) {\r\n                return timestamps;\r\n            }\r\n            const metas = me.getMatchingVisibleMetas();\r\n            if (me._normalized && metas.length) {\r\n                return (me._cache.data = metas[0].controller.getAllParsedValues(me));\r\n            }\r\n            for (i = 0, ilen = metas.length; i < ilen; ++i) {\r\n                timestamps = timestamps.concat(metas[i].controller.getAllParsedValues(me));\r\n            }\r\n            return (me._cache.data = me.normalize(timestamps));\r\n        }\r\n\r\n        getLabelTimestamps() {\r\n            const me = this;\r\n            const timestamps = me._cache.labels || [];\r\n            let i, ilen;\r\n            if (timestamps.length) {\r\n                return timestamps;\r\n            }\r\n            const labels = me.getLabels();\r\n            for (i = 0, ilen = labels.length; i < ilen; ++i) {\r\n                timestamps.push(parse(me, labels[i]));\r\n            }\r\n            return (me._cache.labels = me._normalized ? timestamps : me.normalize(timestamps));\r\n        }\r\n\r\n        normalize(values) {\r\n            return _arrayUnique(values.sort(sorter));\r\n        }\r\n    }\r\n\r\n    TimeScale.id = 'time';\r\n    TimeScale.defaults = {\r\n        bounds: 'data',\r\n        adapters: {},\r\n        time: {\r\n            parser: false,\r\n            unit: false,\r\n            round: false,\r\n            isoWeekday: false,\r\n            minUnit: 'millisecond',\r\n            displayFormats: {}\r\n        },\r\n        ticks: {\r\n            source: 'auto',\r\n            major: {\r\n                enabled: false\r\n            }\r\n        }\r\n    };\r\n\r\n    function interpolate(table, val, reverse) {\r\n        let prevSource, nextSource, prevTarget, nextTarget;\r\n        if (reverse) {\r\n            prevSource = Math.floor(val);\r\n            nextSource = Math.ceil(val);\r\n            prevTarget = table[prevSource];\r\n            nextTarget = table[nextSource];\r\n        } else {\r\n            const result = _lookup(table, val);\r\n            prevTarget = result.lo;\r\n            nextTarget = result.hi;\r\n            prevSource = table[prevTarget];\r\n            nextSource = table[nextTarget];\r\n        }\r\n        const span = nextSource - prevSource;\r\n        return span ? prevTarget + (nextTarget - prevTarget) * (val - prevSource) / span : prevTarget;\r\n    }\r\n\r\n    class TimeSeriesScale extends TimeScale {\r\n        constructor(props) {\r\n            super(props);\r\n            this._table = [];\r\n            this._maxIndex = undefined;\r\n        }\r\n\r\n        initOffsets() {\r\n            const me = this;\r\n            const timestamps = me._getTimestampsForTable();\r\n            me._table = me.buildLookupTable(timestamps);\r\n            me._maxIndex = me._table.length - 1;\r\n            super.initOffsets(timestamps);\r\n        }\r\n\r\n        buildLookupTable(timestamps) {\r\n            const me = this;\r\n            const {min, max} = me;\r\n            if (!timestamps.length) {\r\n                return [\r\n                    {time: min, pos: 0},\r\n                    {time: max, pos: 1}\r\n                ];\r\n            }\r\n            const items = [min];\r\n            let i, ilen, curr;\r\n            for (i = 0, ilen = timestamps.length; i < ilen; ++i) {\r\n                curr = timestamps[i];\r\n                if (curr > min && curr < max) {\r\n                    items.push(curr);\r\n                }\r\n            }\r\n            items.push(max);\r\n            return items;\r\n        }\r\n\r\n        _getTimestampsForTable() {\r\n            const me = this;\r\n            let timestamps = me._cache.all || [];\r\n            if (timestamps.length) {\r\n                return timestamps;\r\n            }\r\n            const data = me.getDataTimestamps();\r\n            const label = me.getLabelTimestamps();\r\n            if (data.length && label.length) {\r\n                timestamps = me.normalize(data.concat(label));\r\n            } else {\r\n                timestamps = data.length ? data : label;\r\n            }\r\n            timestamps = me._cache.all = timestamps;\r\n            return timestamps;\r\n        }\r\n\r\n        getPixelForValue(value, index) {\r\n            const me = this;\r\n            const offsets = me._offsets;\r\n            const pos = me._normalized && me._maxIndex > 0 && !isNullOrUndef(index)\r\n                ? index / me._maxIndex : me.getDecimalForValue(value);\r\n            return me.getPixelForDecimal((offsets.start + pos) * offsets.factor);\r\n        }\r\n\r\n        getDecimalForValue(value) {\r\n            return interpolate(this._table, value) / this._maxIndex;\r\n        }\r\n\r\n        getValueForPixel(pixel) {\r\n            const me = this;\r\n            const offsets = me._offsets;\r\n            const decimal = me.getDecimalForPixel(pixel) / offsets.factor - offsets.end;\r\n            return interpolate(me._table, decimal * this._maxIndex, true);\r\n        }\r\n    }\r\n\r\n    TimeSeriesScale.id = 'timeseries';\r\n    TimeSeriesScale.defaults = TimeScale.defaults;\r\n\r\n    var scales = /*#__PURE__*/Object.freeze({\r\n        __proto__: null,\r\n        CategoryScale: CategoryScale,\r\n        LinearScale: LinearScale,\r\n        LogarithmicScale: LogarithmicScale,\r\n        RadialLinearScale: RadialLinearScale,\r\n        TimeScale: TimeScale,\r\n        TimeSeriesScale: TimeSeriesScale\r\n    });\r\n\r\n    Chart.register(controllers, scales, elements, plugins);\r\n    Chart.helpers = {...helpers};\r\n    Chart._adapters = _adapters;\r\n    Chart.Animation = Animation;\r\n    Chart.Animations = Animations;\r\n    Chart.animator = animator;\r\n    Chart.controllers = registry.controllers.items;\r\n    Chart.DatasetController = DatasetController;\r\n    Chart.Element = Element;\r\n    Chart.elements = elements;\r\n    Chart.Interaction = Interaction;\r\n    Chart.layouts = layouts;\r\n    Chart.platforms = platforms;\r\n    Chart.Scale = Scale;\r\n    Chart.Ticks = Ticks;\r\n    Object.assign(Chart, controllers, scales, elements, plugins, platforms);\r\n    Chart.Chart = Chart;\r\n    if (typeof window !== 'undefined') {\r\n        window.Chart = Chart;\r\n    }\r\n\r\n    return Chart;\r\n\r\n})));\r\n"]}